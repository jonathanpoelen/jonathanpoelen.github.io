<!DOCTYPE html>
<html lang="fr-FR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Le blog de Jonathan Poelen</title>
<meta name="generator" content="Hugo 0.83.1" /><link rel="alternate" type="application/rss+xml" title="Le blog de Jonathan Poelen Feed" href="/index.xml" />

<link rel="stylesheet" type="text/css" media="all" href="/css/style.min.061e5fb8f10fc49af4099c8c4fb46564f559ce4359d97001cbf764669ef02a8f.css">
<link rel="stylesheet" type="text/css" media="all" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous" />
<link rel="shortcut icon" href="/favicon.jpg"/>
<link rel="icon" sizes="32x32" href="/favicon-32.jpg" type="image/jpeg">
<link rel="icon" sizes="64x64" href="/favicon-64.jpg" type="image/jpeg">
<link rel="icon" sizes="96x96" href="/favicon-96.jpg" type="image/jpeg"> 
<link rel="icon" sizes="128x128" href="/favicon-128.jpg" type="image/jpeg">
<meta property="og:site_name" content="Le blog de Jonathan Poelen">
<meta property="og:title" content="Le blog de Jonathan Poelen">
<meta property="og:url" content="https://jonathanpoelen.github.io/">
<meta property="og:language" content="fr-FR">
<meta property="twitter:domain" content="https://jonathanpoelen.github.io/">
<meta property="twitter:card" content="summary">
<meta property="twitter:url" content="https://jonathanpoelen.github.io/">
<meta property="twitter:title" content="Le blog de Jonathan Poelen">
<meta name="description" content="Le blog de Jonathan Poelen. Mon petit mémo sur tout ce qui touche à la programmation =)">
<meta property="twitter:description" content="Le blog de Jonathan Poelen. Mon petit mémo sur tout ce qui touche à la programmation =)">

</head>
<body itemscope="itemscope" itemtype="http://schema.org/WebPage">
  <div id="avoidance-link">
    <a class="evitement" href="#main-content" title="Aller au contenu">Aller au contenu</a>
    <a class="evitement" href="#main-menu" title="Aller au menu">Aller au menu</a>
  </div>
  <div class="container container-outer">
    <header class="header" itemscope="itemscope" itemtype="http://schema.org/WPHeader">
      <div class="container-inner">
        <div class="logo" role="banner" itemscope="itemscope" itemtype="http://schema.org/Brand">
          <a class="logo__link" href="/" title="Le blog de Jonathan Poelen" rel="home">
            <h1 class="logo__title">Le blog de Jonathan Poelen</h1>
            <h2 class="logo__tagline">Mon petit mémo sur tout ce qui touche à la programmation =)</h2>
          </a>
        </div>
        <nav class="menu" itemscope="itemscope" itemtype="http://schema.org/SiteNavigationElement">
  <ul class="menu__list">
    <li class="menu__item"><a class="menu__link" title="GitHub" rel="noopener noreferrer" href="https://github.com/jonathanpoelen">
      <i class="fab fa-github" aria-hidden="true"></i> Github
    </a></li>
    <li class="menu__item "><a class="menu__link" title="Archives" href="/archives">
      <i class="fas fa-archive" aria-hidden="true"></i> Archives</a>
    </li>
    <li class="menu__item"><a class="menu__link" type="application/rss+xml" title="Flux RSS" href="/post/index.xml">
      <i class="fas fa-rss" aria-hidden="true"></i> RSS</a>
    </li>
  </ul>
</nav>


      </div>
    </header>
    <div class="wrapper clearfix">


<aside class="sidebar" itemscope="itemscope" itemtype="http://schema.org/WPSideBar">
	
<div class="widget-search widget">
  <form class="widget-search__form" role="search" method="get" action="https://duckduckgo.com">
    <label>
      <span class="screen-reader-text">Search for:</span>
      <input class="widget-search__field" type="search" placeholder="SEARCH..." value="" name="q">
    </label>
    <input class="widget-search__submit" type="submit" value="Search">
    <input type="hidden" name="sites" value="https://jonathanpoelen.github.io/" />
  </form>
</div>

	
<div class="widget-recent widget" id="main-menu">
  <h4 class="widget__title"><i class="fas fa-file-text-o" aria-hidden="true"></i> Articles récents</h4>
  <div class="widget__content">
    <ul class="widget__list">
      <li class="widget__item"><a class="widget__link" href="/2021/05/la-semantique-de-deplacement/">La sémantique de déplacement</a></li>
      <li class="widget__item"><a class="widget__link" href="/2020/04/sfinae/">SFINAE</a></li>
      <li class="widget__item"><a class="widget__link" href="/2019/09/effets-et-utilisations-de-noexcept/">Effets et utilisations de noexcept</a></li>
      <li class="widget__item"><a class="widget__link" href="/2019/03/stdarray-oui-mais-pourquoi/">std::array, oui, mais pourquoi ?</a></li>
      
      <li class="widget__item"><a class="widget__link widget__link__other" href="/archives">36 autres…</a></li>
    </ul>
  </div>
</div>
<div class="widget-recent widget">
  <h4 class="widget__title"><i class="fas fa-clock-o" aria-hidden="true"></i> Articles récemment mis à jour</h4>
  <div class="widget__content">
    <ul class="widget__list">

    </ul>
  </div>
</div>

	
<div class="widget-categories widget">
  <h4 class="widget__title"><i class="fas fa-folder-o" aria-hidden="true"></i> Catégories</h4>
  <div class="widget__content">
    <ul class="widget__list">
      <li class="widget__item">
        <a class="rss-link" href="/categories/c&#43;&#43;/index.xml" type="application/rss+xml" title="Flux RSS pour C&#43;&#43;">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/c&#43;&#43;">C&#43;&#43; (27)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/script-shell/index.xml" type="application/rss+xml" title="Flux RSS pour Script-Shell">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/script-shell">Script-Shell (7)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/accessibilite-web/index.xml" type="application/rss+xml" title="Flux RSS pour Accessibilite-Web">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/accessibilite-web">Accessibilite-Web (2)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/javascript/index.xml" type="application/rss+xml" title="Flux RSS pour Javascript">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/javascript">Javascript (2)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/zsh/index.xml" type="application/rss+xml" title="Flux RSS pour Zsh">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/zsh">Zsh (2)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/make/index.xml" type="application/rss+xml" title="Flux RSS pour Make">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/make">Make (1)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/sqlite/index.xml" type="application/rss+xml" title="Flux RSS pour Sqlite">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/sqlite">Sqlite (1)</a>
      </li>
    </ul>
  </div>
</div>

	
	

</aside>

  <main class="main-content list content" role="main" id="main-content">
        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="la-s%C3%A9mantique-de-d%C3%A9placement"><span>
        &nbsp;
        <a href="#sfinae"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: SFINAE"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/">La sémantique de déplacement</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#sfinae">Article précédent: SFINAE</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2021-05-11T22:14:00">11 mai 2021
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>15 minutes ;
  <a href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#06c44e7418e7b77e55af140ca92232ab-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
  

</p>


  </header>
  <div class="post__content">
      <p>L&rsquo;objectif derrière la sémantique de déplacement est de transférer les données d&rsquo;un objet <code>A</code> à un objet <code>B</code>. Si les 2 objets sont du même type, on parle de constructeur de déplacement ou affectation par déplacement. Cela permet 2 choses:</p>
<ul>
<li>Garantir l&rsquo;unicité d&rsquo;une ressource. La responsabilité étant passée à quelqu&rsquo;un d&rsquo;autre, il n&rsquo;y a toujours qu&rsquo;un seul propriétaire en charge de la durée de vie de celle-ci.</li>
<li>Éviter des copies profondes en les remplaçant par des copies superficielles plus performantes.</li>
</ul>
<p>Toute autre raison est une erreur.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#principe-dunicité"><h2 id="principe-dunicité">Principe d&rsquo;unicité</h2></a>
<p>Prenons un petit animal sauvage et nommons-le Pikachu. Ce Pikachu est unique, il n&rsquo;en existe qu&rsquo;un seul dans tout l&rsquo;univers. Si on compare notre Pikachu à un autre Pikachu, ils sont différents, il n&rsquo;y en a pas 2 pareils, même s&rsquo;ils ont le même nom.</p>
<p>Rangeons-le dans sa pokéball.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Pokemon</span><span class="o">&gt;</span> <span class="n">my_bag</span><span class="p">;</span>
<span class="n">my_bag</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;Pikachu&#34;</span><span class="p">);</span>
</code></pre></div><p>Un soir, au coin du feu, un brigand passe par là et prend notre sac.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">brigand</span><span class="p">.</span><span class="n">bag</span> <span class="o">=</span> <span class="n">my_bag</span><span class="p">;</span>
</code></pre></div><p>Et tout l&rsquo;univers est sans dessus-dessous, notre Pikachu existe en double, le principe d&rsquo;unicité est brisé !</p>
<p>Heureusement, <code>Pokemon</code> n&rsquo;étant pas copiable, le code ne compile pas. Ouf, l&rsquo;univers est sauf !</p>
<p>Du coup, plutôt que copier le sac, on le déplace directement dans celui de brigand en utilisant la fonction <code>std::move</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">brigand</span><span class="p">.</span><span class="n">bag</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">my_bag</span><span class="p">);</span>
</code></pre></div><p>Au passage, on vient d&rsquo;écraser tout ce qu&rsquo;il y avait dans le sac de notre voleur ; bien fait pour lui ! Mais le plus important est là: Pikachu appartient maintenant au brigand. <code>my_bag</code> est vide, sa taille est de 0. On a bien eu un transfert des pokémons d&rsquo;un sac <code>A</code> vers un sac <code>B</code>, il y a eu déplacement.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#copie-profonde-et-copie-superficielle"><h2 id="copie-profonde-et-copie-superficielle">Copie profonde et copie superficielle</h2></a>
<p>La copie profonde est une copie de tous les membres, y compris des données référencées par un pointeur lorsque leur durée de vie est gérée par la classe. Ce dernier point est important, car sans pointeur &ndash; et pour aller plus loin, sans ressource, &ndash; il n&rsquo;y a pas de différence entre une copie classique ou une copie superficielle. Vouloir les opérateurs de déplacement dans cette dernière situation <strong>ne sert à rien</strong>, l&rsquo;implémentation serait strictement identique à celle d&rsquo;une copie. Autre point, même s&rsquo;il y a un pointeur, il faut que les fonctions de copie fassent une copie profonde pour que les fonctions de déplacements puissent faire une copie superficielle, sinon, rebelote, aucune différence avec la copie.</p>
<p>Comme une illustration est plus parlante, supposons une classe <code>vector</code> avec 2 variables membres:</p>
<ul>
<li><code>int* p</code>, un pointeur alloué dynamiquement et désalloué dans le destructeur</li>
<li><code>size_t n</code> qui représente le nombre d&rsquo;éléments alloué</li>
</ul>
<p>L&rsquo;instance de référence nommé <code>A</code> contient les nombres 7, 1, 3, 7, 0, 5, ce qui donne en mémoire</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">A</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">=</span> <span class="cm">/*adresse=*/</span><span class="mh">0x12345678</span> <span class="cm">/*valeurs=*/</span><span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span>
  <span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">}</span>
</code></pre></div><p>La copie profonde va faire une nouvelle allocation dynamique et copier les valeurs de <code>A.p</code> dans <code>B.p</code>. L&rsquo;adresse du pointeur est donc différente, mais le contenu est identique.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// B = A
</span><span class="c1"></span><span class="n">B</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">=</span> <span class="cm">/*adresse=*/</span><span class="mh">0x87654321</span> <span class="cm">/*valeurs=*/</span><span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span>
  <span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">}</span>
</code></pre></div><p>La copie superficielle effectuée par un déplacement n&rsquo;alloue pas de mémoire, elle copie simplement <code>A.p</code> dans <code>B.p</code> qui est une opération bien plus rapide. L&rsquo;adresse des pointeurs est identique.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// B = std::move(A)
</span><span class="c1"></span><span class="n">B</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">=</span> <span class="cm">/*adresse=*/</span><span class="mh">0x12345678</span> <span class="cm">/*valeurs=*/</span><span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span>
  <span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">}</span>
</code></pre></div><p>Malheureusement, lorsque le destructeur est appelé, il libère la mémoire du pointeur <code>p</code> qui est partagé entre <code>A</code> et <code>B</code>. Cela donne inévitablement une double désallocation qui finit sur un crash de l&rsquo;application. Pour prévenir cette erreur, <code>A.p</code> ne doit pas être libéré, par exemple en mettant le pointeur à <code>nullptr</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// B = std::move(A)
</span><span class="c1"></span><span class="n">A</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span>
  <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><p>Le déplacement a le même fonctionnement que le principe d&rsquo;unicité: l&rsquo;allocation dynamique (la ressource) ne doit être possédée que par une seule instance.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#catégorie-de-valeur"><h2 id="catégorie-de-valeur">Catégorie de valeur</h2></a>
<p>Tout le principe de sémantique de déplacement repose sur l&rsquo;introduction des rvalues. Les rvalues font partie d&rsquo;un ensemble de 5 catégories de valeur qui sont: lvalue, prvalue, xvalue, glvalue et rvalue. Ça c&rsquo;est ce que dit la norme, en tant que développeur, il n&rsquo;y a que 2 types qui sont différenciables dans un programme: lvalue et rvalue. Les autres deviennent automatiquement soit des lvalues, soit rvalues suivant le contexte. On peut les oublier.</p>
<p>Une lvalue (noté <code>T&amp;</code>) est une référence. Une rvalue (noté <code>T&amp;&amp;</code>) est une expression qui se veut temporaire. Si la valeur de cette expression provient d&rsquo;une opération, elle doit être capturée dans une variable, autrement, elle est perdue. À savoir que toutes variables &ndash; quel que soit son type réel &ndash; <strong>est toujours</strong> manipulée comme une lvalue. C’est-à-dire qu&rsquo;avec <code>int i; foo(i);</code>, la fonction <code>foo()</code> reçoit une référence (<code>int&amp;</code>), pas juste <code>int</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">lvalue</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// Erreur, 3 n&#39;est pas une variable, ni une référence,
</span><span class="c1"></span>                    <span class="c1">// mais une valeur temporaire
</span><span class="c1"></span>  <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">rvalue</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// Ok, mais cela est dangereux à cause de l&#39;aspect temporaire
</span><span class="c1"></span>                     <span class="c1">// des rvalues (la variable est détruite en fin de scope).
</span><span class="c1"></span>                     <span class="c1">// Il faut éviter de les conserver, mais plutôt les &#34;accrocher&#34;
</span><span class="c1"></span>                     <span class="c1">// à une variable qui n&#39;est pas une référence
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// C&#39;est... Un point d&#39;encrage d&#39;un temporaire
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">lvalue</span> <span class="o">=</span> <span class="n">rvalue</span><span class="p">;</span> <span class="c1">// rvalue est une variable,
</span><span class="c1"></span>                         <span class="c1">// on peut donc avoir une référence dessus
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>Un des aspects essentiels de la sémantique de déplacement est la conversion d&rsquo;une lvalue en une rvalue en utilisant <code>std::move()</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">rvalue</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="c1">// value est une lvalue
</span><span class="c1"></span>                                    <span class="c1">// std::move() retourne une rvalue
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#constructeur-de-déplacement"><h2 id="constructeur-de-déplacement">Constructeur de déplacement</h2></a>
<p>Pour prendre un exemple connu, les chapitres suivants reposent sur le fonctionnement de <code>std::unique_ptr</code>, un pointeur intelligent qui fait une désallocation automatique de la mémoire dans son destructeur et interdit la copie pour respecter le principe d&rsquo;unicité.</p>
<p>Pour simplifier les codes, la classe ne travaille qu&rsquo;avec des <code>int</code> et ne possède que <code>operator*</code> et <code>operator bool ()</code> comme fonction membre.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">struct</span> <span class="nc">unique_ptr</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// normalement un type template,
</span><span class="c1"></span>                          <span class="c1">// mais pour cet exemple, juste un int
</span><span class="c1"></span>
  <span class="n">unique_ptr</span><span class="p">(</span><span class="n">value_type</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_p</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">unique_ptr</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">m_p</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// notre constructeur de déplacement
</span><span class="c1"></span>  <span class="n">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span>

  <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span> <span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">m_p</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">value_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m_p</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">m_p</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">value_type</span><span class="o">*</span> <span class="n">m_p</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>Et un premier exemple d&rsquo;utilisation.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// exemple
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="k">else</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;nullptr&#34;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">unique_ptr</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
  <span class="n">unique_ptr</span> <span class="n">p2</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">)};</span> <span class="c1">// on déplace p1 dans p2
</span><span class="c1"></span>
  <span class="c1">// p1 est vide, cela affiche nullptr
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;p1: &#34;</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>

  <span class="c1">// p2 possède un pointer valide, cela affiche 3
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;p2: &#34;</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Reste l&rsquo;implémentation du constructeur de déplacement. Comme dit précédemment, seule une instance doit posséder le pointeur interne. L&rsquo;instance déplacée doit être modifiée pour ne plus y faire référence, tout en restant dans un état dit <strong>destructible</strong> pour que le destructeur fonctionne convenablement. Les prérequis de <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible">MoveConstructible</a> parlent d&rsquo;un état non spécifié. C&rsquo;est-à-dire que l&rsquo;implémentation est libre de faire ce qu&rsquo;elle veut du moment que la destruction fonctionne encore. Cependant, chaque fonction peut explicitement documenter le comportement. Le plus simple ici est de mettre le pointeur déplacé à <code>nullptr</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unique_ptr</span><span class="o">::</span><span class="n">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="o">:</span> <span class="n">_p</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_p</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">))</span>
<span class="p">{}</span>
</code></pre></div><p>Finalement beaucoup d&rsquo;explications pour 1 ligne de code. Mais nous sommes loin d&rsquo;avoir terminé, notre <code>unique_ptr</code> ne respecte pas tous les prérequis nécessaires pour un bon constructeur de déplacement. Il n&rsquo;y a pas non plus d&rsquo;affectation par déplacement qui amène à de grosse surprise. Et surtout, qui nous dit qu&rsquo;il n&rsquo;est pas copiable ?</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#fonctions-spéciales"><h2 id="fonctions-spéciales">Fonctions spéciales</h2></a>
<p>Une classe possède 6 fonctions spéciales générées automatiquement par le compilateur:</p>
<ul>
<li>le constructeur par défaut</li>
<li>le constructeur par copie</li>
<li>l&rsquo;affectation par copie</li>
<li>le constructeur par déplacement</li>
<li>l&rsquo;affectation par déplacement</li>
<li>le destructeur</li>
</ul>
<p>Si aucune de ces fonctions n&rsquo;est déclarée dans la classe, leur existence dépend des membres la composant. Ainsi, si un membre comme <code>std::unique_ptr</code> existe, les 2 fonctions liées à la copie seront implicitement supprimées car inexistantes pour le type <code>std::unique_ptr</code>.</p>
<p>À l&rsquo;inverse, définir explicitement certaines fonctions va en désactiver d&rsquo;autres. Il est nécessaire d&rsquo;utiliser <code>=default</code> pour les réactiver.</p>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted -->déclare<!-- raw HTML omitted --> / <!-- raw HTML omitted -->existe<!-- raw HTML omitted --></th>
<th>default-ctor</th>
<th>copy-ctor</th>
<th>copy-assignment</th>
<th>move-ctor</th>
<th>move-assignment</th>
</tr>
</thead>
<tbody>
<tr>
<td>default-constructor</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>copy-constructor</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>copy-assignment</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>move-constructor</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>move-assignment</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>destructor</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>À cela s&rsquo;ajoute que le constructeur par défaut n&rsquo;est plus défini en présence de n&rsquo;importe quel autre constructeur (pas uniquement ceux de copie ou de déplacement).</p>
<p>Si on reprend notre <code>unique_ptr</code> précédemment, ce tableau affirme une chose: la copie n&rsquo;est pas possible et l&rsquo;affectation par déplacement est bien manquante.</p>
<p>À titre personnel, je pense qu&rsquo;il vaut mieux explicitement indiquer que la copie est interdite, soit via une classe spécifique comme boost::noncopyable soit en ajoutant les prototypes suivants:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_ptr</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</code></pre></div><p>Quitte à déclarer certaines fonctions comme étant supprimées, il est aussi plus explicite pour l&rsquo;utilisateur de la classe de mettre explicitement <code>=default</code> pour les autres fonctions. C&rsquo;est le principe de la <a href="https://en.cppreference.com/w/cpp/language/rule_of_three#Rule_of_five">règle de 5</a> qui consiste à définir explicitement les fonctions spéciales (en excluant le constructeur par défaut dans cette règle).</p>
<p>À savoir aussi que &ndash; sauf cas très spécifique &ndash; les constructeurs et <code>operator=</code> vont par paire. Si l&rsquo;un est implémenté, l&rsquo;autre devrait l&rsquo;être également. Ce que nous allons faire dans le prochain chapitre.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#affectation-par-déplacement"><h2 id="affectation-par-déplacement">Affectation par déplacement</h2></a>
<p>Cette fonction est proche du constructeur de déplacement, mais possède un petit piège qu&rsquo;il est bon de savoir. Commençons par l&rsquo;implémentation classique:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">delete</span> <span class="n">m_p</span><span class="p">;</span>
  <span class="n">m_p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_p</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span> <span class="c1">// ligne qu&#39;on retrouve dans le constructeur
</span><span class="c1"></span>  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>En apparence, aucun problème, le pointeur à l&rsquo;intérieur de <code>other</code> est déplacé puis remis à zéro, alors que l&rsquo;ancien se fait détruire. Un petit test le confirme:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">unique_ptr</span> <span class="n">p1</span><span class="p">{</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">3</span><span class="p">)};</span>
  <span class="n">unique_ptr</span> <span class="n">p2</span><span class="p">;</span>

  <span class="n">print</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span> <span class="c1">// nullptr
</span><span class="c1"></span>  <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span> <span class="c1">// p2 contient int* sur 3
</span><span class="c1"></span>  <span class="n">print</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span> <span class="c1">// p1 est maintenant nullptr
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>Mais que se passe-t-il si on fait un déplacement sur soi-même ?</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">unique_ptr</span> <span class="n">p</span><span class="p">{</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">3</span><span class="p">)};</span>
  <span class="n">print</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 3
</span><span class="c1"></span>  <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// ???
</span><span class="c1"></span><span class="p">}</span> <span class="c1">// double-free !!!
</span></code></pre></div><p>Le code affiche n&rsquo;importe quoi et explose ! La raison est toute bête, on désalloue le pointeur puis on récupère celui dans <code>other</code> qui est identique au pointeur précédemment libéré. Une écriture aussi explicite que <code>p = std::move(p)</code> n&rsquo;a pas beaucoup de sens, mais il est possible d&rsquo;arriver dans une telle situation avec un code plus complexe et 2 variables à priori bien distinctes.</p>
<p>Si on se réfère au prérequis de <a href="https://en.cppreference.com/w/cpp/named_req/MoveAssignable">MoveAssignable</a>, il n&rsquo;y a aucune indication sur l&rsquo;état de <code>t</code> dans <code>t = rv</code> lorsque <code>t</code> et <code>rv</code> sont la même référence. Plusieurs choix s&rsquo;offrent à nous en cas de self-move-assignment:</p>
<ul>
<li>considérer cela comme un comportement indéfini</li>
<li>définir <code>rv</code> comme étant égal à nul (donc le pointeur est ici supprimé)</li>
<li>définir <code>t</code> comme contenant le pointeur de <code>rv</code> (et donc ici ne rien faire)</li>
</ul>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#self-move-assignment-comme-comportement-indéfini"><h3 id="self-move-assignment-comme-comportement-indéfini">Self-move-assignment comme comportement indéfini</h3></a>
<p>Ce choix peut paraitre étrange voire dangereux, mais il est justifié pour un besoin de performance: le déplacement doit être rapide. Gérer un tel scénario demande du code supplémentaire &ndash; généralement un <code>if (this != &amp;other)</code> &ndash; et cela peut avoir un impact signification pour un cas de figure fortement marginal. Le choix du standard penche beaucoup pour un comportement indéfini et seules certaines classes l&rsquo;autorisent.</p>
<p>Pour information, les implémentations de libc++ et libstdc++ (clang et gcc) vident les containers tel que <code>std::vector</code>. Il y a même une assertion si on utilise libstdc++ avec la macro <code>_GLIBCXX_DEBUG</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// kaboum avec -D_GLIBCXX_DEBUG: https://godbolt.org/z/Gn4KWe
</span><span class="c1"></span>  <span class="c1">// v.size() == 0
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">g++ test.cpp -D_GLIBCXX_DEBUG <span class="o">&amp;&amp;</span> ./a.out
<span class="o">[</span>...<span class="o">]</span>
Error: attempt to self move assign.
<span class="o">[</span>...<span class="o">]</span>
</code></pre></div><a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#définir-létat-de-rv-sur-self-move-assignment"><h3 id="définir-létat-de-rv-sur-self-move-assignment">Définir l&rsquo;état de rv sur self-move-assignment</h3></a>
<p>Dans ce scénario, seul l&rsquo;état de rv dans <code>t = rv</code> est défini comme étant à nul. Pour ce faire, on désalloue le pointeur de <code>t</code> puis on le met à <code>nullptr</code>. Après un déplacement sur soi-même, le pointeur est systématiquement détruit.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">delete</span> <span class="n">m_p</span><span class="p">;</span>
  <span class="n">m_p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// other.m_p devient nullptr quand other.m_p == m_p
</span><span class="c1"></span>  <span class="n">m_p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_p</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Ce comportement n&rsquo;est pas très logique. Ce qui importe dans un déplacement est de connaître l&rsquo;état de la destination (<code>t</code>). De plus, se retrouver avec <code>t == nullptr</code> est en contradiction avec le comportement principal du déplacement: « la valeur de <code>t</code> est équivalent à la valeur de <code>rv</code> avant affectation ».</p>
<p>Finalement ce choix n&rsquo;est pas très judicieux.</p>
<h3 id="définir-létat-de-t-sur-self-move-assignment">Définir l&rsquo;état de <code>t</code> sur self-move-assignment</h3>
<p>Ici l&rsquo;état de <code>t</code> est défini, même quand <code>t = rv</code> équivaut à un déplacement sur soi-même. Si c&rsquo;est le cas, on ne désalloue rien et le déplacement ne fait rien: on a bien <code>t</code> équivalent à la valeur de <code>rv</code> avant affectation.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span><span class="o">*</span> <span class="n">new_p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_p</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
  <span class="k">delete</span> <span class="n">m_p</span><span class="p">;</span> <span class="c1">// m_p = nullptr quand other.m_p == m_p
</span><span class="c1"></span>  <span class="n">m_p</span> <span class="o">=</span> <span class="n">new_p</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Cette dernière peut aussi s&rsquo;écrire avec l&rsquo;idiome <a href="https://en.cppreference.com/w/cpp/language/operators#Assignment_operator">copy-and-swap</a> ou avec <code>if (this == &amp;other) return *this</code> en début de fonction pour complètement ignorer l&rsquo;affectation sur soi-même. Personnellement, j&rsquo;évite les conditions dans les fonctions de déplacement lorsque cela est possible.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// copy-and-swap
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_ptr</span> <span class="n">other</span><span class="p">)</span> <span class="c1">// on prend par valeur
</span><span class="c1"></span><span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_p</span><span class="p">,</span> <span class="n">m_p</span><span class="p">);</span> <span class="c1">// et on swap
</span><span class="c1"></span>  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="c1">// le destructeur de other va libérer la mémoire à sa destruction
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>Ce comportement pour le déplacement est celui documenté dans <code>std::unique_ptr</code> qui impose l&rsquo;équivalence à <code>reset(r.release())</code>: la valeur ne change pas lorsque <code>t</code> et <code>rv</code> référencent le même objet.</p>
<h2 id="les-déplacements-devraient-être-noexcept">Les déplacements devraient être <code>noexcept</code></h2>
<p>C&rsquo;est une chose qu&rsquo;on oublie facilement, mais les fonctions de déplacement devraient être <code>noexcept</code> pour 2 raisons simples:</p>
<ul>
<li>Le déplacement est une opération qui se veut la plus triviale possible. Les risques d&rsquo;exception sont normalement nuls.</li>
<li>Les containers de la STL utilisent les fonctions de déplacement à la condition que ceux-ci sont <code>noexcept</code> ou qu&rsquo;il n&rsquo;y ait pas de fonction de copie. Voici un exemple qui montre le problème.</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// copie interdite
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="n">A</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
  <span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">delete</span><span class="p">;</span>
  <span class="n">A</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">puts</span><span class="p">(</span><span class="s">&#34;A&amp;&amp;&#34;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// copie autorisée, mais déplacement qui n&#39;est pas noexcept
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">B</span>
<span class="p">{</span>
  <span class="n">B</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
  <span class="n">B</span><span class="p">(</span><span class="n">B</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
  <span class="n">B</span><span class="p">(</span><span class="n">B</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">puts</span><span class="p">(</span><span class="s">&#34;B&amp;&amp;&#34;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// copie autorisée et déplacement noexcept
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">C</span>
<span class="p">{</span>
  <span class="n">C</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
  <span class="n">C</span><span class="p">(</span><span class="n">C</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
  <span class="n">C</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">puts</span><span class="p">(</span><span class="s">&#34;C&amp;&amp;&#34;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// va afficher au moins un A&amp;&amp;
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>
  <span class="n">a</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>
  <span class="n">a</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>

  <span class="c1">// aucun B&amp;&amp;
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">b</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>
  <span class="n">b</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>
  <span class="n">b</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>

  <span class="c1">// va afficher au moins un C&amp;&amp;
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">c</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>
  <span class="n">c</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>
  <span class="n">c</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>(Je n&rsquo;ai pas mis <code>operator=</code>, mais il est évident que la version par déplacement devrait aussi être noexcept.)</p>
<p>Une note sur l&rsquo;implémentation derrière: les containers se basent sur la fonction <a href="https://en.cppreference.com/w/cpp/utility/move_if_noexcept">std::move_if_noexcept</a>.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#la-vérité-vraie-du-mensonge-quest-stdmove"><h2 id="la-vérité-vraie-du-mensonge-quest-stdmove">La vérité vraie du mensonge qu&rsquo;est std::move</h2></a>
<p>Je ne vais pas mentir, tout le baratin précédent n&rsquo;est là que pour placer ce chapitre. Autant de bla bla juste pour le plaisir de mettre ce titre :).</p>
<p>Ceci dit, arrivé ici, vous devriez être conscient que <code>std::move</code> ne fait pas grand-chose: tout se situe dans les constructeurs et opérateurs de déplacement.</p>
<p>Mais alors, que fait <code>std::move</code> ? Eh bien, rien&hellip; Ou plus précisément, la fonction ne touche pas à l&rsquo;instance, mais à la catégorie de valeur. Ce n&rsquo;est rien de plus qu&rsquo;un cast d&rsquo;une lvalue en rvalue ! On pourrait tout aussi bien remplacer <code>std::move(x)</code> par <code>static_cast&lt;std::remove_reference_t&lt;decltype(x)&gt;&amp;&amp;&gt;(x) </code>, le résultat serait exactement le même &ndash; à la verbosité près.</p>
<p>Puisque <code>std::move</code> n&rsquo;est rien de plus qu&rsquo;un cast, il est inutile de l&rsquo;utiliser sur des rvalues. <code>std::move(Bidule{})</code> n&rsquo;a aucun sens, <code>Bidule{}</code> est déjà une rvalue (mieux, c&rsquo;est une prvalue). Il n&rsquo;est pas non plus nécessaire de l&rsquo;utiliser sur le retour des fonctions qui bénéficient de la <a href="https://cpp.developpez.com/faq/cpp/?page=Optimisation#Qu-est-ce-que-la-RVO">RVO</a> et de l&rsquo;élision de copie en général.</p>
<p>Pire, utiliser <code>std::move</code> lorsque cela n&rsquo;est pas nécessaire désactive certaines optimisations. Sur ce point, gcc et clang ont tous deux les avertissements <code>-Wpessimizing-move</code> et <code>-Wredundant-move</code> qui se déclenchent sur une utilisation inappropriée de <code>std::move</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">A</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">A</span> <span class="n">ret</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="c1">// -Wpessimizing-move
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">// NRVO
</span><span class="c1"></span><span class="p">}</span>

<span class="n">A</span> <span class="nf">foo</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// -Wredundant-move
</span><span class="c1"></span><span class="p">}</span>

<span class="n">A</span> <span class="nf">bar</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">A</span><span class="p">{}));</span> <span class="c1">// -Wpessimizing-move
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">foo</span><span class="p">());</span> <span class="c1">// -Wpessimizing-move
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">foo</span><span class="p">();</span> <span class="c1">// RVO
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#stdforward"><h2 id="stdforward">std::forward</h2></a>
<p>Pour finaliser les explications sur le déplacement, il faut introduire <code>std::forward</code> et les règles de <a href="https://en.cppreference.com/w/cpp/language/reference#Reference_collapsing">reference collapsing</a>.</p>
<p><code>std::forward</code> n&rsquo;est utile que sur des types templates dont la catégorie de valeur n&rsquo;est pas connue. L&rsquo;exemple le plus simple est une fonction <code>template&lt;class T&gt; void foo(T&amp;&amp; x);</code> où <code>T</code> représente une forwarding reference. Càd une référence qui est soit une lvalue, soit une rvalue. On peut aussi croiser le nom de référence universelle venant d&rsquo;avant la normalisation du nom officiel.</p>
<p>Sur un usage classique de <code>foo()</code>, le type réel de <code>T</code> est le suivant:</p>
<ul>
<li><code>foo(std::string())</code>: <code>T</code> = <code>std::string</code>. <code>T&amp;&amp;</code> = <code>std::string</code></li>
<li><code>foo(str)</code>: <code>T</code> = <code>std::string&amp;</code>. <code>T&amp;&amp;</code> = <code>std::string&amp;</code></li>
</ul>
<p>Appliquer une rvalue sur un type qui est une lvalue donne une lvalue. C&rsquo;est le point essentiel de la references collapsing.</p>
<table>
<thead>
<tr>
<th>lhs</th>
<th>rhs</th>
<th>référence</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td><code>&amp;</code></td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td><code>&amp;&amp;</code></td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td><code>&amp;</code></td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td><code>&amp;&amp;</code></td>
<td><code>&amp;&amp;</code></td>
</tr>
</tbody>
</table>
<p>Le but de <code>std::forward</code> est de propager la catégorie de valeur en castant vers une rvalue quand le type d&rsquo;origine est une rvalue (n&rsquo;oublions pas qu&rsquo;à ce niveau, la variable <code>x</code> est une lvalue, même si son type est une rvalue).</p>
<p>Pour ce faire, <code>std::forward&lt;T&gt;(x)</code> combine simplement <code>T</code> à une rvalue pour caster la variable dans la bonne catégorie de valeur. Ceci est strictement équivalent à <code>static_cast&lt;T&amp;&amp;&gt;(x)</code> ou <code>static_cast&lt;decltype(x)&amp;&amp;&gt;(x)</code>. Certains projets définissent une macro <code>FWD(x)</code> qui fonctionne ainsi.</p>
<p>Les explications sont complexes, mais la chose importante à retenir est qu&rsquo;un type template de la forme <code>T&amp;&amp;</code> doit être propagé avec <code>std::forward&lt;T&gt;()</code> pour conserver le type de référence.</p>
<p>Il faut aussi bien comprendre que les forwarding references s&rsquo;appliquent sur un type template complet, ce qui n&rsquo;est pas le cas par exemple pour <code>void foo(std::vector&lt;T&gt;&amp;&amp; vec)</code> où la fonction attend toujours une rvalue.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/#que-personne-ne-bouge-vlà-la-conclusion"><h2 id="que-personne-ne-bouge-vlà-la-conclusion">Que personne ne bouge, v&rsquo;là la conclusion</h2></a>
<p>Pour résumer tout ça:</p>
<ul>
<li><code>std::move</code> n&rsquo;est qu&rsquo;un cast user-friendly vers une rvalue, ce n&rsquo;est pas lui qui fait le déplacement à proprement parler. Mal l&rsquo;utiliser désactive aussi certaines optimisations.</li>
<li>Le comportement du déplacement est défini par les fonctions qui reçoivent une rvalue.</li>
<li>Définir certaines fonctions spéciales en désactivent d&rsquo;autres, il est préférable d&rsquo;indiquer explicitement le comportement de chacune de préférence avec <code>=default</code> ou <code>=delete</code>. Pour rappel, les fonctions spéciales sont ici les constructeurs de déplacement et de copie, l&rsquo;affectation par déplacement et de copie ainsi que le destructeur.</li>
<li>le constructeur de déplacement et l&rsquo;affectation par déplacement devrait être noexcept pour que les containers de la STL les utilisent.</li>
<li><code>std::forward</code> s&rsquo;utilise pour des paramètres template de la forme <code>T&amp;&amp;</code> pour propager la catégorie de référence (lvalue ou rvalue).</li>
</ul>
<p>Voilà qui clôture cet article sur la sémantique de déplacement. Et n&rsquo;oubliez pas, une variable n&rsquo;est jamais une rvalue et &ndash; sauf exception de la NRVO &ndash; il faut explicitement utiliser <code>std::move</code> pour l&rsquo;utiliser comme une rvalue.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2021-05-11T22:14:00">11 mai 2021
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  

  <br/><a href="https://jonathanpoelen.github.io/2021/05/la-semantique-de-deplacement/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="06c44e7418e7b77e55af140ca92232ab-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=la-s%25C3%25A9mantique-de-d%25C3%25A9placement&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2021%2f05%2fla-semantique-de-deplacement%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2021%2f05%2fla-semantique-de-deplacement%2f&amp;title=la-s%25C3%25A9mantique-de-d%25C3%25A9placement" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2021%2f05%2fla-semantique-de-deplacement%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2021%2f05%2fla-semantique-de-deplacement%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2021%2f05%2fla-semantique-de-deplacement%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2021%2f05%2fla-semantique-de-deplacement%2f&amp;name=la-s%25C3%25A9mantique-de-d%25C3%25A9placement" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="sfinae"><span>
        <a href="#la-s%25C3%25A9mantique-de-d%25C3%25A9placement"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: La sémantique de déplacement"></i></a>
        <a href="#effets-et-utilisations-de-noexcept"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Effets et utilisations de noexcept"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2020/04/sfinae/">SFINAE</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#la-s%25C3%25A9mantique-de-d%25C3%25A9placement">Article suivant: La sémantique de déplacement</a><br/>
        <a href="#effets-et-utilisations-de-noexcept">Article précédent: Effets et utilisations de noexcept</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2020-04-07T09:29:25">07 avril 2020
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>12 minutes ;
  <a href="https://jonathanpoelen.github.io/2020/04/sfinae/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#387a37cf3aa969713e423816ed3561c7-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
  

</p>


  </header>
  <div class="post__content">
      <p><a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> (Substitution Failure Is Not An Error) est un mécanisme du compilateur pour ignorer certaines instanciations de fonction ou de classe qui ne compilent pas, sans pour autant émettre une erreur de compilation.</p>
<p>Pour comprendre pleinement le mécanisme derrière, il faut assimiler le principe de substitution appliquée par le compilateur. Lorsqu&rsquo;une expression dépend d&rsquo;un <strong>paramètre template</strong>, le compilateur va évaluer l&rsquo;expression en la substituant par le type ou la valeur de l&rsquo;expression. Par exemple</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span> <span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span> <span class="n">value</span><span class="p">);</span>

<span class="n">foo</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div><p>À l&rsquo;appel de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span></code></span>, le compilateur remplace <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span></code></span> par <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">A</span><span class="o">::</span><span class="n">type</span></code></span>, qui correspond ici à <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span></code></span>. C&rsquo;est la substitution. Lorsque le compilateur n&rsquo;arrive pas à faire cette substitution &ndash; car par exemple il n&rsquo;y a pas de membre <code>type</code> &ndash; il va chercher une autre fonction <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span></code></span> qui pourrait être utilisée.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span> <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span> <span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span> <span class="n">value</span><span class="p">);</span> <span class="c1">// B::type n&#39;existe pas, cette fonction est ignorée
</span><span class="c1"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="n">value</span><span class="p">);</span>

<span class="n">foo</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div><p>Bien sûr, si le compilateur peut utiliser les 2 fonctions <code>foo</code> précédentes, il y aura ambiguïté et finalement une erreur.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">C</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">foo</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">test</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">call</span> <span class="n">to</span> <span class="err">&#39;</span><span class="n">foo</span><span class="err">&#39;</span> <span class="n">is</span> <span class="n">ambiguous</span>
  <span class="n">foo</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="o">^~~~~~</span>
<span class="n">test</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span> <span class="nl">note</span><span class="p">:</span> <span class="n">candidate</span> <span class="n">function</span> <span class="p">[</span><span class="n">with</span> <span class="n">T</span> <span class="o">=</span> <span class="n">C</span><span class="p">]</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span> <span class="n">value</span><span class="p">);</span>
     <span class="o">^</span>
<span class="n">test</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span> <span class="nl">note</span><span class="p">:</span> <span class="n">candidate</span> <span class="n">function</span> <span class="p">[</span><span class="n">with</span> <span class="n">T</span> <span class="o">=</span> <span class="n">C</span><span class="p">]</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="n">value</span><span class="p">);</span>
     <span class="o">^</span>
</code></pre></div><p>Il faut bien comprendre que SFINAE n&rsquo;est pas un mécanisme pour simplifier les messages d&rsquo;erreur, ni pour les ignorer. Le résultat est même plutôt inverse, à un certain point, il est difficile de savoir pourquoi une fonction est utilisée à la place d&rsquo;une autre, le compilateur ne donnant aucun diagnostic. Les erreurs sont plus verbeuses &ndash; l&rsquo;ensemble des prototypes sont listés &ndash; et les ambiguïtés difficiles à corriger sans ajouter de la complexité.</p>
<p>Plus le nombre de prototypes liés à un nom de fonction croît, plus le code devient difficile et les erreurs &ndash; principalement d&rsquo;ambiguïtés &ndash; nombreuses. Il faut bien réfléchir à la manière de s&rsquo;y prendre pour ne pas être happé par le code avec des prototypes à rallonge à ne plus savoir quoi en faire. Le but de cet article est de présenter différentes solutions pour exploiter SFINAE sans être enfermé dans un usage unique qui se limite souvent à la superposition de condition dans un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span></code></span>.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2020/04/sfinae/#dépendance-de-typevaleur"><h2 id="dépendance-de-typevaleur">Dépendance de type/valeur</h2></a>
<p>Le SFINAE repose entièrement sur les valeurs ou types template, on parle de value-dependent ou type-dependent (je ne ferais pas de distinction entre les 2). Tout ce qui n&rsquo;est pas lié à une valeur template sera évalué automatiquement par le compilateur, que l&rsquo;expression soit ou non dans une classe ou une fonction template.</p>
<p>Par exemple:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span> <span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="o">::</span><span class="n">type</span> <span class="n">y</span><span class="p">)</span> <span class="c1">// A::type doit exister, car le type n&#39;est pas type-dependent
</span><span class="c1"></span>                        <span class="c1">// Si A::type n&#39;existe pas, il y aura une erreur
</span><span class="c1"></span>                        <span class="c1">// même si foo() n&#39;est pas utilisée
</span><span class="c1"></span><span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Cette expression dépend de x qui est template,
</span><span class="c1"></span>                <span class="c1">// une erreur ne pourra survenir qu&#39;au moment de l&#39;instanciation de foo()
</span><span class="c1"></span>  <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">;</span> <span class="c1">// cette expression n&#39;a aucune dépendance -&gt; il devrait y avoir une erreur
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>Si le compilateur respecte scrupuleusement la norme et sans la moindre utilisation de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">()</span></code></span>, tout ce qui n&rsquo;a pas de dépendance doit être évalué au plus tôt et systématiquement.</p>
<ul>
<li>le type <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">A</span><span class="o">::</span><span class="n">type</span></code></span> doit exister</li>
<li>le second retour ne doit pas compiler</li>
</ul>
<p>Étrangement, du moment que la fonction n&rsquo;est pas utilisée, gcc ne vérifie pas si le retour est convertible vers celui de la fonction, mais demande quand même une expression valide, alors que msvc ne fait aucune vérification au sein de la fonction. Par contre clang indique qu&rsquo;une chaîne de caractères n&rsquo;est pas convertible en int.</p>
<p>L&rsquo;évaluation systématique des types indépendants explique pourquoi le code ci-dessous donne toujours une erreur.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">xxx</span><span class="p">)</span>
<span class="p">{}</span>
<span class="k">else</span>
<span class="p">{</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="c1">// toujours évalué -&gt; erreur de compilation
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>On touche ici au contexte d&rsquo;évaluation: le prototype, suivi du corps de fonction. Le second est évalué différemment selon les compilateurs, mais cela ne cause pas réellement de problème, car les erreurs apparaissent au moment de l&rsquo;utilisation de la fonction.</p>
<p>Quand on parle de contexte, on parle aussi de sous-contexte. Dans le cas de SFINAE, la dépendance d&rsquo;un contexte au contexte parent <strong>ne peut pas être attrapé</strong>, ce qui résultera dans tous les cas à une erreur de compilation. Le corps d&rsquo;une fonction est un exemple, un autre concerne les membres d&rsquo;une classe:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">B</span>
<span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">C</span> <span class="c1">// contexte principal (instanciation de la structure)
</span><span class="c1"></span><span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">;</span> <span class="c1">// sous-contexte,
</span><span class="c1"></span>                                 <span class="c1">// T::type dépend de T du contexte parent
</span><span class="c1"></span><span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">foo</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">foo</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">foo</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">foo</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// erreur
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">test</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">12</span><span class="o">:</span><span class="mi">28</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">no</span> <span class="n">type</span> <span class="n">named</span> <span class="err">&#39;</span><span class="n">type</span><span class="err">&#39;</span> <span class="n">in</span> <span class="sc">&#39;B&#39;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">;</span> <span class="c1">// sous-contexte,
</span><span class="c1"></span>               <span class="o">~~~~~~~~~~~~^~~~</span>
<span class="n">test</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">16</span><span class="o">:</span><span class="mi">36</span><span class="o">:</span> <span class="nl">note</span><span class="p">:</span> <span class="n">in</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="k">template</span> <span class="k">class</span> <span class="err">&#39;</span><span class="nc">C</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="err">&#39;</span> <span class="n">requested</span> <span class="n">here</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="o">&gt;</span>
                                   <span class="o">^</span>
</code></pre></div><p>Pour que <code>C</code> fonctionne avec SFINAE, il faut une spécialisation de <code>C</code> sans le membre <code>type</code>. Cela requière un développement spécifique qui rend le support de SFINAE quelquefois difficile à mettre en place.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2020/04/sfinae/#emplacement-des-expressions-pour-le-sfinae"><h2 id="emplacement-des-expressions-pour-le-sfinae">Emplacement des expressions pour le SFINAE</h2></a>
<p>Partout où il est possible de mettre un type ou une valeur est propice à la substitution: paramètre template, contenu de noexcept, decltype, sizeof et même les paramètres par défaut. Quel que soit l&rsquo;emplacement, si le compilateur ne trouve pas une expression qu&rsquo;il peut compiler, il va simplement ignorer la fonction ou l&rsquo;instanciation.</p>
<p>Généralement, pour vérifier une expression, le plus simple est d&rsquo;ajouter un paramètre de template initialisé avec l&rsquo;expression qui doit être valide ou passer par <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">decltype</span></code></span>. Pour ce dernier, une petite astuce pour ajouter plusieurs expressions consiste à les séparer par des virgules et entourer le tout d&rsquo;une paire de parenthèse:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="p">...,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">decltype</span><span class="p">(...)</span><span class="o">&gt;</span> <span class="c1">// ici ou
</span><span class="c1"></span><span class="k">auto</span> <span class="n">f</span><span class="p">(...)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(((</span><span class="kt">void</span><span class="p">)</span><span class="n">expr1</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">expr2</span><span class="p">),</span> <span class="n">expr3</span><span class="p">));</span>
                     <span class="c1">// ^ pour que decltype ne voit qu&#39;une expression
</span><span class="c1"></span>                     <span class="c1">//  ^ le cast en void permet d&#39;inhiber d&#39;éventuelle surcharge de ,
</span><span class="c1"></span>                     <span class="c1">//             ^ la virgule pour séparer chacune des expressions
</span><span class="c1"></span>                     <span class="c1">//                              ^ l&#39;expression pour le type de retour
</span></code></pre></div><a class="headline-hash" href="https://jonathanpoelen.github.io/2020/04/sfinae/#technique-et-usage-du-sfinae"><h2 id="technique-et-usage-du-sfinae">Technique et usage du SFINAE</h2></a>
<p>À partir de maintenant, je vais présenter les techniques qui me viennent à l&rsquo;esprit en me basant si possible sur des éléments de la STL pour des exemples pratiques. Les plus curieux pourront comparer avec l&rsquo;implémentation de la STL qu&rsquo;ils utilisent (<a href="https://github.com/microsoft/STL/">msvc</a>, <a href="https://github.com/llvm-mirror/libcxx">clang (libc++)</a> et <a href="https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3">gcc (libstdc++)</a> pour les plus connues).</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2020/04/sfinae/#sélection-de-fonction-à-travers-un-type-membre"><h3 id="sélection-de-fonction-à-travers-un-type-membre">Sélection de fonction à travers un type membre</h3></a>
<p>Dans ce premier exemple, nous allons voir comment implémenter <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span></code></span>. Pour rappel, il existe 3 versions:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// arrays of unknown bound
</span><span class="c1"></span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">...)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// arrays of known bound
</span></code></pre></div><p>Comme le premier type template influence les paramètres et le type de retour, le plus simple est un trait qui va sélectionner le bon prototype. Contrairement au trait que l&rsquo;on rencontre habituellement, celui-ci va définir un type membre différent pour chaque spécialisation utilisée par un prototype. Ainsi, seul un prototype pourra être utilisé pendant que les autres ne trouveront pas le membre attendu. Cette implémentation est tout droit sortie des STLs.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">make_unique_select</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="n">single_object</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">make_unique_select</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[]</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="n">array</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">make_unique_select</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">invalid_type</span> <span class="p">{};</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">make_unique_select</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">single_object</span>
<span class="n">make_unique</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">make_unique_select</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">array</span>
<span class="n">make_unique</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_extent_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">[</span><span class="n">num</span><span class="p">]());</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">make_unique_select</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">invalid_type</span>
<span class="n">make_unique</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</code></pre></div><p>Si le C++ supportait la spécialisation partielle de fonction, on pourrait se passer de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">detail</span><span class="o">::</span><span class="n">make_unique_select</span></code></span>. Par contre, comme l&rsquo;implémentation de <code>make_unique</code> dépend uniquement d&rsquo;un type template qui doit être explicitement mis, on peut simplifier le code grâce aux variables template et en déplaçant l&rsquo;implémentation des fonctions dans les spécialisations de structure.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">make_unique_impl</span>
  <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
       <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">make_unique_impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[]</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[]</span><span class="o">&gt;</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">num</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_extent_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">[</span><span class="n">num</span><span class="p">]());</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">make_unique_impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">invalid_type</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">detail</span><span class="o">::</span><span class="n">make_unique_impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_unique</span> <span class="p">{};</span>
</code></pre></div><p>Ce qui revient à des bêtes spécialisations de template.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2020/04/sfinae/#condition-dans-une-spécialisation-template"><h3 id="condition-dans-une-spécialisation-template">Condition dans une spécialisation template</h3></a>
<p>Grâce à un paramètre supplémentaire, il est possible d&rsquo;ajouter des conditions dans une spécialisation pour y ajouter des contraintes. Voici un exemple simplifié avec une implémentation de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span></code></span>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">From</span><span class="p">,</span> <span class="k">class</span> <span class="nc">To</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">is_convertible</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span>
<span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">From</span><span class="p">,</span> <span class="k">class</span> <span class="nc">To</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">is_convertible</span><span class="o">&lt;</span><span class="n">From</span><span class="p">,</span> <span class="n">To</span><span class="p">,</span>
  <span class="c1">// on utilise le paramètre &#34;fantôme&#34;,
</span><span class="c1"></span>  <span class="c1">// mais le type final de l&#39;expression doit être le même que la valeur par défaut
</span><span class="c1"></span>  <span class="k">class</span> <span class="err">= </span><span class="nc">decltype</span><span class="p">(</span>
    <span class="c1">// fonction créée à la volée qui prend un paramètre To
</span><span class="c1"></span>    <span class="c1">// qui échouera si From n&#39;est pas convertible
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="o">&amp;</span><span class="p">)(</span><span class="n">To</span><span class="p">)</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">From</span><span class="o">&gt;</span><span class="p">())</span>
  <span class="p">)</span>
<span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
<span class="p">{};</span>
</code></pre></div><p>Cette technique permet de n&rsquo;instancier un type que si tous les prérequis sont acceptés. Au début de l&rsquo;article, j&rsquo;ai présenté un exemple de classe où <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">T</span><span class="o">::</span><span class="n">type</span></code></span> (avec <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">T</span> <span class="o">=</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span></code></span>) donne une erreur, car le sous-membre (<code>type</code>) dépend d&rsquo;un contexte parent. Voici comment on peut palier à ce problème:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">C</span>
<span class="p">{</span>
  <span class="c1">// par défaut aucun membre
</span><span class="c1"></span><span class="p">};</span>

<span class="c1">// si T::type existe bien, cette spécialisation sera utilisée
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">C</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">void_t</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="o">&gt;&gt;</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>Ceci fonctionne pour des types, mais les compilateurs sont plus capricieux avec des valeurs. Par exemple, une spécialisation sur des valeurs divisibles par 16 comme ci-dessus donne une erreur avec gcc, msvc et icc. Étrangement, seul clang l&rsquo;accepte.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">=</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">is_mod16</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span>
<span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">is_mod16</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="mi">16</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="c1">// erreur
</span><span class="c1"></span><span class="p">{};</span>
</code></pre></div><p>Faute de mieux, le plus simple est de passer par <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">%</span> <span class="mi">16</span> <span class="o">==</span> <span class="mi">0</span><span class="o">&gt;</span></code></span> et prendre un type comme second paramètre de template.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2020/04/sfinae/#jouer-avec-les-conversions-implicites"><h3 id="jouer-avec-les-conversions-implicites">Jouer avec les conversions implicites</h3></a>
<p>Il est possible d&rsquo;ajouter un paramètre dans une fonction et jouer avec les conversions implicites pour prioriser l&rsquo;ordre d&rsquo;appel.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>

<span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">B</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">C</span> <span class="o">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span>
<span class="p">{};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">foo</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">foo</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
<span class="c1">// les 2 fonctions sont valides, mais T::type est prioritaire car 42 est un int
</span><span class="c1"></span><span class="k">static_assert</span><span class="p">(</span><span class="n">foo</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div><p>On peut même ajouter autant de paramètres que nécessaire pour avoir une chaîne de priorité. Par exemple, on pourrait faire une fonction <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">front</span><span class="p">()</span></code></span> qui utilise en priorité la fonction <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">front</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span></code></span> dans le namespace de l&rsquo;objet (règles d'<a href="https://en.cppreference.com/w/cpp/language/adl">ADL</a>), sinon <code>cont.front()</code> et en dernier recours <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="o">*</span><span class="n">begin</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span></code></span>.</p>

  <div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// juste pour simplifier l&#39;écriture des fonctions
</span><span class="c1"></span><span class="cp">#define DECLTYPE_AUTO_RETURN_NOEXCEPT(...)                 \
</span><span class="cp">  noexcept(noexcept(__VA_ARGS__)) -&gt; decltype(__VA_ARGS__) \
</span><span class="cp">  {                                                        \
</span><span class="cp">    return (__VA_ARGS__);                                  \
</span><span class="cp">  }
</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">adl_barrier</span>
<span class="p">{</span>
  <span class="c1">// pour que front_impl() voit une fonction front() qu&#39;elle pourrait utiliser
</span><span class="c1"></span>  <span class="k">struct</span> <span class="nc">na</span> <span class="p">{};</span>
  <span class="kt">void</span> <span class="nf">front</span><span class="p">(</span><span class="n">na</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="c1">// pour que begin(cont) utilise le begin de son namespace (ADL) ou std::begin()
</span><span class="c1"></span>  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">;</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Cont</span><span class="o">&gt;</span>
  <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">front_impl</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
  <span class="n">DECLTYPE_AUTO_RETURN_NOEXCEPT</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">cont</span><span class="p">))</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Cont</span><span class="o">&gt;</span>
  <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">front_impl</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">)</span>
  <span class="n">DECLTYPE_AUTO_RETURN_NOEXCEPT</span><span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">front</span><span class="p">())</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Cont</span><span class="o">&gt;</span>
  <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">front_impl</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">char</span><span class="p">)</span>
  <span class="n">DECLTYPE_AUTO_RETURN_NOEXCEPT</span><span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">(</span><span class="n">cont</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Cont</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">front</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;&amp;</span> <span class="n">cont</span><span class="p">)</span>
<span class="c1">// le perfect forwarding n&#39;est pas respecté pour simplifier l&#39;exemple
</span><span class="c1"></span><span class="n">DECLTYPE_AUTO_RETURN_NOEXCEPT</span><span class="p">(</span><span class="n">adl_barrier</span><span class="o">::</span><span class="n">front_impl</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">namespace</span> <span class="n">mylib</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">A</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">constexpr</span> <span class="kt">char</span> <span class="nf">front</span><span class="p">(</span><span class="n">A</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">}</span>


  <span class="k">struct</span> <span class="nc">B</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">constexpr</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="nf">begin</span><span class="p">(</span><span class="n">B</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">s</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="k">struct</span> <span class="nc">C</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="kt">char</span> <span class="nf">front</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">mylib</span><span class="o">::</span><span class="n">A</span><span class="p">{</span><span class="s">&#34;ax&#34;</span><span class="p">})</span> <span class="o">==</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span> <span class="c1">// mylib::front(A)
</span><span class="c1"></span><span class="k">static_assert</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">mylib</span><span class="o">::</span><span class="n">B</span><span class="p">{</span><span class="s">&#34;bx&#34;</span><span class="p">})</span> <span class="o">==</span> <span class="sc">&#39;b&#39;</span><span class="p">);</span> <span class="c1">// *mylib::begin(B)
</span><span class="c1"></span><span class="k">static_assert</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">mylib</span><span class="o">::</span><span class="n">C</span><span class="p">{</span><span class="s">&#34;cx&#34;</span><span class="p">})</span> <span class="o">==</span> <span class="sc">&#39;c&#39;</span><span class="p">);</span> <span class="c1">// C::front()
</span><span class="c1"></span><span class="k">constexpr</span> <span class="kt">char</span> <span class="n">carr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;dx&#34;</span><span class="p">;</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">carr</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;d&#39;</span><span class="p">);</span> <span class="c1">// *std::begin(carr)
</span></code></pre></div>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2020/04/sfinae/#les-variadiques-de-la-dernière-chance"><h3 id="les-variadiques-de-la-dernière-chance">Les variadiques de la dernière chance</h3></a>
<p>Il existe en C des paramètres variadiques dont l&rsquo;usage est limité aux types de base et aux pointeurs. Ce genre de paramètre à une particularité intéressante: il n&rsquo;est pris en compte qu&rsquo;à la seule condition qu&rsquo;aucune autre fonction ne pourrait correspondre. Il a donc une priorité inférieure à la conversion et ne rentre pas en conflit avec. On pourrait réécrire <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span></code></span> comme suit</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">From</span><span class="p">,</span> <span class="k">class</span> <span class="nc">To</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">is_convertible_impl</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="n">test</span><span class="p">(</span><span class="n">To</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="n">test</span><span class="p">(...);</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">From</span><span class="p">,</span> <span class="k">class</span> <span class="nc">To</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">is_convertible</span> <span class="o">=</span> <span class="k">decltype</span><span class="p">(</span><span class="n">is_convertible_impl</span><span class="o">&lt;</span><span class="n">From</span><span class="p">,</span> <span class="n">To</span><span class="o">&gt;::</span><span class="n">test</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">From</span><span class="o">&gt;</span><span class="p">()));</span>
</code></pre></div><a class="headline-hash" href="https://jonathanpoelen.github.io/2020/04/sfinae/#rendre-dépendant-un-type-indépendant"><h3 id="rendre-dépendant-un-type-indépendant">Rendre dépendant un type indépendant</h3></a>
<p>Cela peut paraître idiot, mais pour rendre dépendant un type indépendant du contexte, il suffit qu&rsquo;il traverse un type dépendant.</p>
<p>Voici un exemple pour avoir le plus proche d&rsquo;un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="nf">constexpr</span> <span class="p">()</span> <span class="p">{}</span> <span class="k">else</span> <span class="k">static_assert</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span></code></span>:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">fn_identity</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">auto</span> <span class="n">dependent_identity</span> <span class="o">=</span> <span class="n">fn_identity</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_array_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="c1">// _ depend de T, mais est toujours égal à fn_identity
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dependent_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="c1">// _(false) retourne false,
</span><span class="c1"></span>    <span class="c1">// mais la valeur est indirectement dépendante de T
</span><span class="c1"></span>    <span class="k">static_assert</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
    <span class="c1">// on notera que même si _ n&#39;est pas une variable constexpr
</span><span class="c1"></span>    <span class="c1">// le résultat de _(false) l&#39;est :)
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// on peut aussi utiliser la variable x plutôt que T, avec quelque chose comme
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">first</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//...
</span><span class="c1"></span><span class="k">static_assert</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">x</span><span class="p">));</span>
</code></pre></div><p>Cela s&rsquo;applique aussi au membre d&rsquo;une classe en ajoutant un template avec un paramètre par défaut qui ne sera jamais modifié par l&rsquo;extérieur.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">U</span><span class="o">::</span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// son écriture en est par contre fortement alourdie:
</span><span class="c1"></span><span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&lt;&gt;</span>
<span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">type</span><span class="o">&lt;&gt;</span> <span class="c1">// dans une fonction/classe template
</span></code></pre></div><p>Ou sur une fonction membre:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="c1">// sans ce template, le type T doit obligatoirement avoir une fonction foo()
</span><span class="c1"></span>  <span class="c1">// sinon, l&#39;instanciation de A ne pourra pas se faire et A&lt;int&gt; donnerait
</span><span class="c1"></span>  <span class="c1">// request for member ‘foo’ in ‘std::declval&lt;int&amp;&gt;()’, which is of non-class type ‘int’
</span><span class="c1"></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&amp;&gt;</span><span class="p">().</span><span class="n">foo</span><span class="p">())</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><a class="headline-hash" href="https://jonathanpoelen.github.io/2020/04/sfinae/#c20-et-concept"><h2 id="c20-et-concept">C++20 et concept</h2></a>
<p>Depuis C++20, il existe un nouvel outil pour exploiter le SFINAE: <a href="https://en.cppreference.com/w/cpp/language/constraints">les concepts</a>. Les concepts sont des contraintes ajoutées aux types qui doivent être vérifiées pour que le compilateur accepte d&rsquo;utiliser la fonction ou d&rsquo;instancier le type. Cela simplifie l&rsquo;utilisation du SFINAE et rend le code beaucoup plus lisible. La fonctionnalité étant récente, la plupart des compilateurs ne la supporte pas encore.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2020-04-07T09:29:25">07 avril 2020
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  

  <br/><a href="https://jonathanpoelen.github.io/2020/04/sfinae/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="387a37cf3aa969713e423816ed3561c7-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=sfinae&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2020%2f04%2fsfinae%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2020%2f04%2fsfinae%2f&amp;title=sfinae" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2020%2f04%2fsfinae%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2020%2f04%2fsfinae%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2020%2f04%2fsfinae%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2020%2f04%2fsfinae%2f&amp;name=sfinae" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="effets-et-utilisations-de-noexcept"><span>
        <a href="#sfinae"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: SFINAE"></i></a>
        <a href="#stdarray-oui-mais-pourquoi"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: std::array, oui, mais pourquoi ?"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2019/09/effets-et-utilisations-de-noexcept/">Effets et utilisations de noexcept</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#sfinae">Article suivant: SFINAE</a><br/>
        <a href="#stdarray-oui-mais-pourquoi">Article précédent: std::array, oui, mais pourquoi ?</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2019-09-01T16:09:32">01 septembre 2019
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>11 minutes ;
  <a href="https://jonathanpoelen.github.io/2019/09/effets-et-utilisations-de-noexcept/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#fb46726ec0a3919cca046288d3ed51bc-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
  

</p>


  </header>
  <div class="post__content">
      <a class="headline-hash" href="https://jonathanpoelen.github.io/2019/09/effets-et-utilisations-de-noexcept/#fonction-noexcept"><h2 id="fonction-noexcept">Fonction noexcept</h2></a>
<p><code>noexcept</code> est un mot clef apparu en C++11. Dans le prototype d&rsquo;une fonction, il indique que cette dernière ne jette pas d&rsquo;exception. Cela ne veut pas dire qu&rsquo;aucune exception ne sera présente dans la fonction, mais qu'<strong>aucune exception ne sortira</strong> de la fonction. Dans le cas contraire, le programme s&rsquo;arrête subitement avec un appel à <a href="https://en.cppreference.com/w/cpp/error/terminate"><code>std::terminate</code></a>.</p>
<p><code>noexcept</code> n&rsquo;impose aucune restriction sur ce que peut faire la fonction. Il est tout à fait possible d&rsquo;utiliser des fonctions qui ne sont pas marquées <code>noexcept</code> à l&rsquo;intérieur d&rsquo;une fonction <code>noexcept</code>, voire, de jeter des exceptions. La seule contrainte se trouve sur le chemin de sortie: il ne doit pas se faire avec une exception.</p>
<p>Voici un code totalement inutile de démonstration avec une exception qui traverse une fonction <code>foo()</code> marquée <code>noexcept</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">throw</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// noexcept ? Pas vu
</span><span class="c1"></span><span class="p">}</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span> <span class="c1">// le programme s&#39;arrête ici
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ok</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="c1">// ne s&#39;affiche jamais
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>La compilation puis l&rsquo;exécution donne:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="err">$</span> <span class="n">g</span><span class="o">++</span> <span class="n">test</span><span class="p">.</span><span class="n">cpp</span> <span class="o">&amp;&amp;</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span>
<span class="n">test</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">function</span> <span class="err">‘</span><span class="kt">void</span> <span class="n">foo</span><span class="p">()</span><span class="err">’</span><span class="o">:</span>
<span class="n">test</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">9</span><span class="o">:</span> <span class="nl">warning</span><span class="p">:</span> <span class="k">throw</span> <span class="n">will</span> <span class="n">always</span> <span class="n">call</span> <span class="n">terminate</span><span class="p">()</span> <span class="p">[</span><span class="o">-</span><span class="n">Wterminate</span><span class="p">]</span>
    <span class="mi">3</span> <span class="o">|</span>   <span class="k">throw</span> <span class="mi">42</span><span class="p">;</span>
      <span class="o">|</span>         <span class="o">^~</span>
<span class="n">terminate</span> <span class="n">called</span> <span class="n">after</span> <span class="n">throwing</span> <span class="n">an</span> <span class="n">instance</span> <span class="n">of</span> <span class="err">&#39;</span><span class="kt">int</span><span class="err">&#39;</span>
<span class="nl">zsh</span><span class="p">:</span> <span class="n">abort</span> <span class="p">(</span><span class="n">core</span> <span class="n">dumped</span><span class="p">)</span>  <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span>
</code></pre></div><p>G++, Clang et MSVC émettent tous 3 un avertissement et le programme explose comme attendu.</p>
<p>L&rsquo;avertissement ici est évident, mais ce n&rsquo;est pas toujours le cas, le compilateur ne pouvant garantir que toutes les fonctions utilisées dans une fonction noexcept ne jettent pas elles-mêmes des exceptions.</p>
<p>Notre fonction <code>foo()</code> est une énorme bombe à retardement. Chouette, une raison supplémentaire pour faire planter un programme ;)</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/09/effets-et-utilisations-de-noexcept/#les-bénéfices-de-noexcept"><h2 id="les-bénéfices-de-noexcept">Les bénéfices de noexcept</h2></a>
<p>Une mauvaise utilisation de <code>noexcept</code> peut faire planter un programme. Mais une fonctionnalité à risque ne vient jamais sans avantage. Puisque <code>noexcept</code> garantit qu&rsquo;aucune exception ne sorte de la fonction, le compilateur peut éjecter le code qui s&rsquo;en occupe. Si les fonctions ne lancent pas d&rsquo;exception, il peut déterminer avec certitude quels sont les chemins de sortie, supprimer du code, réordonner les instructions et appliquer autres obscures magies dont il a le secret.</p>
<p>Dit comme ça, on pourrait croire que plein d&rsquo;optimisations s&rsquo;offrent à nous, mais non. Premièrement, les compilateurs sont capables de faire des exceptions qui n&rsquo;ont de coût qu&rsquo;au moment de l&rsquo;appel. Bien sûr, l&rsquo;exécutable est plus gros et peut impacter le cache d&rsquo;instruction, mais le coût d&rsquo;une exception non utilisée est nulle. Secundo, ce n&rsquo;est pas évident de produire un exécutable qui supprime vraiment du code, à moins d&rsquo;avoir absolument toutes les fonctions en <code>noexcept</code>, la magie du compilateur se verra limité. Surtout que les bonnes options d&rsquo;optimisation donnent des résultats comparables.</p>
<p>Après plusieurs essais d&rsquo;exemples de code pseudo-réaliste, en voici 2 basés sur une fonction très simple</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// foo.cpp
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="n">NOEXCEPT</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>NOEXCEPT</code> sera à remplacer par <code>noexcept</code> ou rien. Respectivement les options de compilation <code>-DNOEXCEPT=noexcept</code> et <code>-DNOEXCEPT=</code>.</p>
<p>Ce premier exemple prouve que le compilateur est capable de prendre en compte <code>noexcept</code> pour supprimer du code.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// main.cpp
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">NOEXCEPT</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">err</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="c1">// trace de l&#39;étape en cours
</span><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="s">&#34;foo step&#34;</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// fin du &#34;traitement&#34;
</span><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">;</span> <span class="c1">// ceci peut lancer une exception std::ios_base::failure
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// err != nullptr uniquement si foo() lance une exception
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;oups: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Ce code permet d&rsquo;afficher un message sur l&rsquo;étape en cours avant une éventuelle exception. Dans notre cas, <code>foo()</code> ne lance pas d&rsquo;exception, mais en l&rsquo;absence de <code>noexcept</code>, <code>main.cpp</code> ne le sait pas.</p>
<p>Si <code>foo()</code> ne lance pas d&rsquo;exception, alors <code>err</code> sera toujours égal à <code>nullptr</code> dans le <code>catch</code>. Il est alors possible de supprimer la condition qui serait toujours évaluée à <code>false</code>, ce qui doit donner un exécutable plus petit.</p>
<p>Le petit script suivant va compiler chaque <code>.cpp</code> avec et sans <code>noexcept</code> puis afficher la taille de l&rsquo;exécutable.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="k">for</span> x in noexcept <span class="s1">&#39;&#39;</span> <span class="p">;</span> <span class="k">do</span>
  <span class="nv">d</span><span class="o">=</span><span class="nv">NOEXCEPT</span><span class="o">=</span><span class="nv">$x</span>
  g++ -O3 -D<span class="nv">$d</span> *.cpp <span class="o">&amp;&amp;</span>
  <span class="nb">echo</span> <span class="nv">$d</span> <span class="o">&amp;&amp;</span>
  stat ./a.out *.o --format<span class="o">=</span><span class="s2">&#34;</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;%n\t%s&#34;</span><span class="k">)</span><span class="s2">&#34;</span>
<span class="k">done</span>
</code></pre></div><table>
<thead>
<tr>
<th> </th>
<th>NOEXCEPT=</th>
<th>NOEXCEPT=noexcept</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stat ./a.out</code></td>
<td>17632</td>
<td>16816</td>
</tr>
</tbody>
</table>
<p>Pronostic vérifié. On peut même regarder l'<a href="https://godbolt.org/z/xBmjdI">assembleur sur godbolt</a> pour s&rsquo;en convaincre.</p>
<p>Voici un second exemple plus simple qui montre que le compilateur supprime totalement la gestion des exceptions lorsqu&rsquo;il lui est permis de le faire.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">NOEXCEPT</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;&amp;</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// some stuff
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">u</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">u</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Et l&rsquo;asm de <a href="https://godbolt.org/z/-yIB7m">https://godbolt.org/z/-yIB7m</a></p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">bar</span><span class="p">(</span><span class="no">std</span><span class="p">::</span><span class="no">unique_ptr</span><span class="err">&lt;</span><span class="no">int</span><span class="p">,</span> <span class="no">std</span><span class="p">::</span><span class="no">default_delete</span><span class="err">&lt;</span><span class="no">int</span><span class="err">&gt;</span> <span class="err">&gt;&amp;&amp;</span><span class="p">):</span>
        <span class="nf">push</span>    <span class="no">r12</span>
        <span class="nf">push</span>    <span class="no">rbp</span>
        <span class="nf">sub</span>     <span class="no">rsp</span><span class="p">,</span> <span class="mi">8</span>
        <span class="nf">mov</span>     <span class="no">rbp</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="p">]</span>
        <span class="nf">mov</span>     <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="p">],</span> <span class="mi">0</span>
        <span class="nf">mov</span>     <span class="no">edi</span><span class="p">,</span> <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rbp</span><span class="err">+</span><span class="mi">0</span><span class="p">]</span>
        <span class="nf">call</span>    <span class="no">foo</span><span class="p">(</span><span class="no">int</span><span class="p">)</span>
        <span class="nf">mov</span>     <span class="no">rdi</span><span class="p">,</span> <span class="no">rbp</span>
        <span class="nf">mov</span>     <span class="no">esi</span><span class="p">,</span> <span class="mi">4</span>
        <span class="nf">mov</span>     <span class="no">r12d</span><span class="p">,</span> <span class="no">eax</span>
        <span class="nf">call</span>    <span class="no">operator</span> <span class="no">delete</span><span class="p">(</span><span class="no">void</span><span class="p">*,</span> <span class="no">unsigned</span> <span class="no">long</span><span class="p">)</span>
        <span class="nf">add</span>     <span class="no">rsp</span><span class="p">,</span> <span class="mi">8</span>
        <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">r12d</span>
        <span class="nf">pop</span>     <span class="no">rbp</span>
        <span class="nf">pop</span>     <span class="no">r12</span>
        <span class="nf">ret</span>
<span class="c">; ce qui suit ne concerne que l&#39;éventuelle exception de foo()
</span><span class="c"></span>        <span class="nf">mov</span>     <span class="no">r12</span><span class="p">,</span> <span class="no">rax</span>
        <span class="nf">jmp</span>     <span class="no">.L2</span>
<span class="nf">bar</span><span class="p">(</span><span class="no">std</span><span class="p">::</span><span class="no">unique_ptr</span><span class="err">&lt;</span><span class="no">int</span><span class="p">,</span> <span class="no">std</span><span class="p">::</span><span class="no">default_delete</span><span class="err">&lt;</span><span class="no">int</span><span class="err">&gt;</span> <span class="err">&gt;&amp;&amp;</span><span class="p">)</span> <span class="p">[</span><span class="no">clone</span> <span class="no">.cold</span><span class="p">]:</span>
<span class="nl">.L2:</span>
        <span class="nf">mov</span>     <span class="no">rdi</span><span class="p">,</span> <span class="no">rbp</span>
        <span class="nf">mov</span>     <span class="no">esi</span><span class="p">,</span> <span class="mi">4</span>
        <span class="nf">call</span>    <span class="no">operator</span> <span class="no">delete</span><span class="p">(</span><span class="no">void</span><span class="p">*,</span> <span class="no">unsigned</span> <span class="no">long</span><span class="p">)</span>
        <span class="nf">mov</span>     <span class="no">rdi</span><span class="p">,</span> <span class="no">r12</span>
        <span class="nf">call</span>    <span class="no">_Unwind_Resume</span>
</code></pre></div><p>La seconde partie du code asm n&rsquo;est utilisée que pour le traitement d&rsquo;une exception, elle se situe en dehors du flux normal d&rsquo;exécution et disparait lorsque foo() ne lance pas d&rsquo;exception.</p>
<p>Mais attention, si une fonction <code>noexcept</code> appelle une fonction qui n&rsquo;est pas <code>noexcept</code>, le compilo va ajouter du code pour forcer l&rsquo;utilisation de <code>std::terminate()</code>. Cela revient presque à un support d&rsquo;exception, mais en plus léger.</p>
<p>Maintenant, il faut savoir qu&rsquo;avec l&rsquo;option <code>-flto</code> la taille des exécutables sont les mêmes que foo() soit <code>noexcept</code> ou pas. Simplement parce que le compilateur déduit que foo() ne lance pas d&rsquo;exception. Mais dans le cas de bibliothèque partagée, <code>-flto</code> ne pourra rien faire et la différence subsistera.</p>
<p>Puisque le compilateur peut déduire lui-même qu&rsquo;une fonction ne lance pas d&rsquo;exception, pourquoi et surtout quand mettre noexcept ?</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/09/effets-et-utilisations-de-noexcept/#quand-mettre-noexcept"><h2 id="quand-mettre-noexcept">Quand mettre noexcept</h2></a>
<p>Déjà, on peut dire qu&rsquo;une fonction qui ne lance absolument pas d&rsquo;exception peut être <code>noexcept</code>. Cette information est surtout utile dans les APIs ou bibliothèques qui ont cette garantie. Un analyseur statique pourrait aussi vérifier qu&rsquo;aucune exception ne la traverse. Dans le cas contraire, c&rsquo;est plutôt risqué.</p>
<p>Néanmoins, <code>noexcept</code> est vraiment important sur les constructeurs déplacement.</p>
<p>Pour être plus précis, conjointement avec les conteneurs de la STL, cela va déterminer si le conteneur utilise ou non le déplacement. Si la fonction est <code>noexcept</code>, le déplacement d&rsquo;un élément ne peut pas échouer. Dans le cas d&rsquo;un <code>std::vector&lt;T&gt;</code>, cela veut dire qu&rsquo;après un agrandissement de la capacité, tous les éléments peuvent être déplacés sans échec. Par contre, si le déplacement lance une exception, une partie des données pourrait se perdre et <code>std::vector</code> utilise alors la copie. On parle de résistance aux exceptions ou d'<a href="https://en.wikipedia.org/wiki/Exception_guarantees">exception-safety</a>. Dans le cas de <code>std::vector</code>, c&rsquo;est une garantie forte: l&rsquo;état du vector est inchangé s&rsquo;il y a une exception sur l&rsquo;augmentation de la capacité. Pour en savoir un peu plus sur l&rsquo;exception-safety, c&rsquo;est <a href="https://www.boost.org/community/exception_safety.html">par là</a>.</p>
<p>Pour illustrer l&rsquo;influence de <code>noexcept</code> avec std::vector, voici une petite classe qui affiche quel constructeur est utilisé. Le constructeur de déplacement est toujours présent, seule la présence de <code>noexcept</code> diffère.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A&amp;(&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>

  <span class="n">A</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="nl">NOEXCEPT</span> <span class="p">:</span> <span class="n">i</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A&amp;&amp;(&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// agrandissement de la capacité + déplacement/copie de A(1)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>Et les résultats après compilation:</p>
<table>
<thead>
<tr>
<th> </th>
<th>NOEXCEPT=</th>
<th>NOEXCEPT=noexcept</th>
</tr>
</thead>
<tbody>
<tr>
<td>./a.out</td>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">A</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">A</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code></span></td>
</tr>
</tbody>
</table>
<p>Maintenant imaginons que notre classe <code>A</code> contienne des <code>std::string</code> et des <code>std::vector</code>. Si le constructeur de déplacement n&rsquo;est pas <code>noexcept</code>, alors il y aura de nombreuses copies qui auront un gros impact sur les performances. Ce n&rsquo;est généralement pas ce qu&rsquo;on veut.</p>
<p>Personnellement, je déconseille d&rsquo;écrire le constructeur et operator= de déplacement ou de copie. 99% du temps, la version par défaut fait le job, le compilateur déduisant lui-même <code>noexcept</code> pour les fonctions par défaut &ndash; et c&rsquo;est bien le seul moment. S&rsquo;il y a une véritable nécessité, il est généralement possible d&rsquo;avoir une classe qui ne fournit que ce service et l&rsquo;utiliser en variable membre.</p>
<p>Si on écrit explicitement <code>noexcept</code> sur une fonction par défaut &ndash; par exemple <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">X</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span></code></span> &ndash; le compilateur va <strong>vérifier</strong> que le déplacement de chaque membre ne lance pas d&rsquo;exception. Et dans le cas contraire, ne compile pas.</p>
<p>Pour finir, <strong>les destructeurs sont implicitement <code>noexcept</code></strong>. Si un destructeur balance une exception, le programme va s&rsquo;arrêter. Les raisons sont assez simples: il est difficile de catcher une exception d&rsquo;un destructeur et il est impossible d&rsquo;arriver à un état cohérent sans code spécifique si les objets ne peuvent être détruits. De plus, il faut savoir que jeter une exception pendant le traitement d&rsquo;une exception appelle automatiquement <code>std::terminate()</code>. Du coup, les exceptions dans un destructeur sont plutôt une mauvaise idée.</p>
<p>Mais si on veut autoriser le destructeur à jeter des exceptions ou pouvoir marquer nos fonctions en <code>noexcept</code> à la seule condition qu&rsquo;une expression précise soit elle-même <code>noexcept</code> il existe un nouveau mot clef: <code>noexcept</code>. Oui, mais non, il est différent.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/09/effets-et-utilisations-de-noexcept/#spécificateur-dexception-et-opérateur-noexcept"><h2 id="spécificateur-dexception-et-opérateur-noexcept">Spécificateur d&rsquo;exception et opérateur noexcept</h2></a>
<p>Il existe 2 mots clef pour <code>noexcept</code>: le spécificateur d&rsquo;exception et l&rsquo;opérateur.</p>
<ul>
<li>Le spécificateur <code>noexcept</code> ou <code>noexcept(bool)</code> se met toujours dans le prototype de la fonction. <code>noexcept</code> et <code>noexcept(true)</code> indiquent que la fonction ne jette pas d&rsquo;exception, <code>noexcept(false)</code> indique que la fonction jette potentiellement une exception.</li>
<li>L&rsquo;opérateur <code>noexcept(expr)</code> prend une expression est retourne un booléen qui indique si oui ou non une expression peut lancer une exception.</li>
</ul>
<p>Voici quelques exemples:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">f1</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">f2</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f3</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">foo</span><span class="p">());</span> <span class="c1">// -&gt; noexcept(true)
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">f4</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">f1</span><span class="p">()));</span> <span class="c1">// noexcept seulement si f1() est noexcept
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">f5</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">));</span>
<span class="kt">void</span> <span class="nf">f6</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">f1</span><span class="p">())</span>  <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="c1">// true
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">f2</span><span class="p">())</span>  <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="c1">// false
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">f3</span><span class="p">())</span>  <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="c1">// true
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">f4</span><span class="p">())</span>  <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="c1">// true
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">f5</span><span class="p">())</span>  <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="c1">// false
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">f6</span><span class="p">())</span>  <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="c1">// true
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>  <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="c1">// true
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="c1">// true
</span></code></pre></div><p>Pas très compliqué dans l&rsquo;ensemble, même si bien que logique, le résultat de <code>f6()</code> et la dernière ligne peuvent surprendre: <code>false</code> est une expression qui ne retourne jamais d&rsquo;exception, par conséquent, l&rsquo;opérateur <code>noexcept</code> retourne <code>true</code>.</p>
<p>La STL offre aussi les traits <a href="https://en.cppreference.com/w/cpp/types#Supported_operations"><code>std::is_nothrow_*</code></a> pour vérifier si certaines expressions sont <code>noexcept</code> ; ainsi qu&rsquo;une fonction <a href="https://en.cppreference.com/w/cpp/utility/move_if_noexcept"><code>std::move_if_noexcept</code></a> qui retourne une rvalue si le constructeur de déplacement est noexcept et une lvalue constante dans le cas inverse.</p>
<p>Avant C++11, il existait le spécificateur <code>throw()</code> pour indiquer qu&rsquo;une fonction ne jette pas d&rsquo;exception. Son comportement est très différent et pas du tout efficace. En C++17, il devient l&rsquo;équivalent de <code>noexcept(true)</code> pour finalement être supprimé en C++20.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/09/effets-et-utilisations-de-noexcept/#signature-et-type-de-fonction"><h2 id="signature-et-type-de-fonction">Signature et type de fonction</h2></a>
<p>2 fonctions qui ne diffèrent que par la spécification d&rsquo;exception ne peuvent être surchargées car leur signature est identique. Ceci n&rsquo;est pas autorisé:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">// erreur
</span></code></pre></div><p>Du fait de la signature identique, <code>noexcept</code> peut très bien apparaître dans le prototype d&rsquo;une fonction exposée dans une bibliothèque C (<span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="s">&#34;C&#34;</span></code></span>), mais cette information disparaît dans la bibliothèque elle-même. Mieux que ça, si la bibliothèque est compilée sans <code>noexcept</code>, mais que le <code>.h</code> distribué les met, le compilateur retrouve ses petits, car le name mangling est le même.</p>
<p>Par contre, avant C++17 le type d&rsquo;une fonction ne prend jamais en compte <code>noexcept</code>. C’est-à-dire que les types <code>void(*)()</code> et <code>void(*)() noexcept</code> sont identiques.</p>
<p>À partir de C++17, <code>noexcept</code> fait partie intégrante du type de la fonction. Un pointeur de fonction <code>noexcept</code> n&rsquo;est pas compatible avec un pointeur de fonction qui jette potentiellement une exception. Néanmoins, une fonction <code>noexcept</code> est convertible en un pointeur de fonction qui n&rsquo;est pas <code>noexcept</code>. Les posts conditions sont plus fortes ce qui ne brise pas le <a href="https://fr.wikipedia.org/wiki/Principe_de_substitution_de_Liskov">LSP</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">();</span>

<span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>
<span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// non depuis C++17
</span><span class="c1"></span>
<span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">)()</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span>
<span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">)()</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">// ok
</span></code></pre></div><p>Cette caractéristique s&rsquo;applique aussi aux fonctions <code>virtual</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="n">A</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// il manque noexcept
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="k">noexcept</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// ok, plus de restriction sur les conditions de sortie
</span><span class="c1"></span><span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="n">B</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// erreur, même si A::bar() n&#39;est pas noexcept, B::bar() l&#39;est
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><a class="headline-hash" href="https://jonathanpoelen.github.io/2019/09/effets-et-utilisations-de-noexcept/#ce-quil-faut-retenir"><h2 id="ce-quil-faut-retenir">Ce qu&rsquo;il faut retenir</h2></a>
<p>Finalement il n&rsquo;y a pas grand chose à retenir. <code>noexcept</code> permet certaines optimisations, mais appliqué n&rsquo;importe comment il est source de bug. Si vous n&rsquo;êtes pas sûr, ne l&rsquo;utilisez pas.</p>
<p>Cependant, comme cela influence les conteneurs de la STL, il faut impérativement penser à le mettre sur le constructeur de déplacement.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2019-09-01T16:09:32">01 septembre 2019
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  

  <br/><a href="https://jonathanpoelen.github.io/2019/09/effets-et-utilisations-de-noexcept/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="fb46726ec0a3919cca046288d3ed51bc-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=effets-et-utilisations-de-noexcept&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f09%2feffets-et-utilisations-de-noexcept%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f09%2feffets-et-utilisations-de-noexcept%2f&amp;title=effets-et-utilisations-de-noexcept" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f09%2feffets-et-utilisations-de-noexcept%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f09%2feffets-et-utilisations-de-noexcept%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f09%2feffets-et-utilisations-de-noexcept%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f09%2feffets-et-utilisations-de-noexcept%2f&amp;name=effets-et-utilisations-de-noexcept" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="stdarray-oui-mais-pourquoi"><span>
        <a href="#effets-et-utilisations-de-noexcept"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Effets et utilisations de noexcept"></i></a>
        <a href="#grep-sed-awk-sort...-non-zsh"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Grep, sed, awk, sort... Non ! Zsh"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2019/03/stdarray-oui-mais-pourquoi/">std::array, oui, mais pourquoi ?</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#effets-et-utilisations-de-noexcept">Article suivant: Effets et utilisations de noexcept</a><br/>
        <a href="#grep-sed-awk-sort...-non-zsh">Article précédent: Grep, sed, awk, sort... Non ! Zsh</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2019-03-29T17:28:19">29 mars 2019
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>5 minutes ;
  <a href="https://jonathanpoelen.github.io/2019/03/stdarray-oui-mais-pourquoi/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#8f57f6c0a6a13d37f24c60e9a5993627-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
  

</p>


  </header>
  <div class="post__content">
      <p>Depuis C++11, un nouveau type de tableau fait son apparition: <code>std::array</code>. S&rsquo;il est là, ce n&rsquo;est pas uniquement parce que la STL est cool, mais bien parce que les tableaux C posent des problèmes dans lesquels les débutants sautent à pieds joints.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/03/stdarray-oui-mais-pourquoi/#les-tableaux-c-se-convertissent-en-pointeur-trop-facilement"><h2 id="les-tableaux-c-se-convertissent-en-pointeur-trop-facilement">Les tableaux C se convertissent en pointeur trop facilement</h2></a>
<p>Le tableau C a l&rsquo;alarmante faculté de se convertir en pointeur par simple affectation ou opération arithmétique. Par exemple, Soustraire 2 tableaux donne la distance qui sépare les 2 variables dans la mémoire, ce qui n&rsquo;a aucun sens. Mais puisque les tableaux se dégradent en pointeur, le compilateur l&rsquo;accepte sans broncher.</p>
<p>Le seul pseudo-avantage est l&rsquo;arithmétique des pointeurs qui permet de manipuler un tableau presque comme un pointeur &ndash; à la différence que l&rsquo;incrémentation et la décrémentation ne sont pas possibles.</p>
<p>Ainsi, on pourra écrire <code>auto* p = a + i</code> plutôt que <code>auto* p = &amp;a[i]</code>.</p>
<p>Ou encore <code>&amp;i[a]</code> (i.e. <code>&amp;2[a]</code>), forme uniquement valide avec des tableaux ou des pointeurs. Tant qu&rsquo;à hériter du C, prenons le meilleur&hellip; :D</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/03/stdarray-oui-mais-pourquoi/#votre-prototype-de-fonction-ment"><h2 id="votre-prototype-de-fonction-ment">Votre prototype de fonction ment</h2></a>
<p>Voici une fonction tout à fait banale qui affiche les valeurs d&rsquo;un tableau:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="k">const</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">array</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Fonction qui ne compile pas, car <code>array</code> n&rsquo;est pas un tableau, mais un pointeur. Et un pointeur ne fonctionne pas avec les boucles sur intervalle. Gcc indique l&rsquo;erreur en affichant le prototype tel qu&rsquo;il devrait être lu: &ldquo;dans la fonction <code>void print(const int*)</code>&rdquo;. Clang va même jusqu&rsquo;à dire qu&rsquo;un paramètre de type <code>int[3]</code> est considéré comme un pointeur. La conversion en pointeur se propage même à ce niveau.</p>
<p>Ce qui veut dire qu&rsquo;écrire un prototype qui prend un tableau de 3 <code>int</code> est un mensonge. Le compilateur ne fera aucune vérification sur la taille du tableau passé en paramètre. Pour lui, que l&rsquo;argument soit un tableau de 1, 2, 3 ou plus d&rsquo;éléments, c&rsquo;est pareil: un pointeur. Par conséquent, les 4 prototypes suivants sont strictement identiques:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="k">const</span> <span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="k">const</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="k">const</span> <span class="n">array</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="k">const</span><span class="o">*</span> <span class="n">array</span><span class="p">);</span>
</code></pre></div><p>Bien sûr, il est possible d&rsquo;avoir un vrai tableau en paramètre avec l&rsquo;aide des références et d&rsquo;une syntaxe alambiquée:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="k">const</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">)[</span><span class="mi">3</span><span class="p">]);</span> <span class="c1">// bienvenue dans le monde merveilleux de C++
</span></code></pre></div><p>À ce moment, le compilateur considère <code>array</code> comme étant un tableau de 3 entiers constants et la boucle précédente pourra fonctionner. Si l&rsquo;utilisateur met un tableau de moins ou de plus de 3 éléments, le compilateur va gentiment l&rsquo;envoyer bouler.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/03/stdarray-oui-mais-pourquoi/#un-tableau-c-nest-pas-copiable"><h2 id="un-tableau-c-nest-pas-copiable">Un tableau C n&rsquo;est pas copiable</h2></a>
<p>Le tableau est le seul type du C qui ne supporte ni la copie, ni l&rsquo;affectation, ce qui le rend inutilisable dans n&rsquo;importe quel conteneur de la STL tel que <code>std::vector</code>. Il n&rsquo;est pas non plus possible de construire un tableau directement dans l&rsquo;appel d&rsquo;une fonction (sauf en C99 avec un cast: <code>foo((int[]){1,2})</code>).</p>
<p>Par contre, une structure qui contient un tableau est aussi bien copiable qu&rsquo;affectable. Manipuler un tableau directement impose plusieurs contraintes complètement loufoques, mais mettez le tout dans une boîte et tout est permis. Ce qui m&rsquo;amène à <code>std::array</code>, car il fait justement office de boîte.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/03/stdarray-oui-mais-pourquoi/#stdarray-un-conteneur-comme-les-autres"><h2 id="stdarray-un-conteneur-comme-les-autres">Std::array, un conteneur comme les autres</h2></a>
<p>Le gros avantage de <code>std::array</code> est son interface commune avec les autres conteneurs:</p>
<ul>
<li><code>size()</code></li>
<li><code>empty()</code></li>
<li><code>begin()</code>/<code>end()</code></li>
<li><code>data()</code></li>
</ul>
<p>Ainsi que quelques membres utilitaires comme <code>fill()</code>, <code>front()</code>, <code>back()</code> et la panoplie de type comme <code>value_type</code>, <code>reference</code>, etc qu&rsquo;on s&rsquo;attend à voir.</p>
<p>Si je prends le cas de <code>size()</code>, la version tableau C est beaucoup plus compliquée: <code>sizeof(array)/sizeof(array[0])</code>, Mais aussi dangereuse, car le comportement sera totalement imprévisible si, suite à un refactoring, notre tableau est remplacé par <code>std::vector</code>.</p>
<p>La manière intelligente de faire consiste en une fonction libre <code>size(T(&amp;)[N])</code> qui s&rsquo;occupe de cela pour nous. Si le type change, alors la fonction ne correspond plus et des erreurs apparaissent. Au passage, C++17 introduit <code>std::size(cont)</code>, <code>std::empty(cont)</code> et <code>std::data(cont)</code> valides pour tous les conteneurs, y compris les tableaux. Voici <a href="https://linuxfr.org/news/cpp17-libere-size-data-et-empty">un article de Lmghs</a> sur le sujet et les raisons de ce choix.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/03/stdarray-oui-mais-pourquoi/#un-tableau-de-0-élément"><h2 id="un-tableau-de-0-élément">Un tableau de 0 élément</h2></a>
<p>Dans certaines circonstances, on peut vouloir un tableau de 0 élément. Cela fonctionne très bien avec <code>std::array</code> contrairement au tableau C qui doit utiliser une extension du compilateur pour le supporter (c&rsquo;est interdit par le standard). Pour pallier à ce problème, la taille du tableau est généralement forcée à 1, mais d&rsquo;autres complications surviennent dès que les types ne sont pas trivialement constructibles.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/03/stdarray-oui-mais-pourquoi/#stdarray-est-un-tuple"><h2 id="stdarray-est-un-tuple">Std::array est un tuple</h2></a>
<p>Propriété anecdotique, les fonctions et classes associées au tuple sont disponibles pour <code>std::array</code>. Cela permet par exemple de jouer avec <code>std::apply</code> pour transformer un <code>std::array</code> en un pack variadique.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">...</span> <span class="n">xs</span><span class="p">){</span> <span class="k">return</span> <span class="n">xs</span> <span class="o">+</span> <span class="p">...;</span> <span class="p">},</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div><p>Dans la pratique, il n&rsquo;y a pas d&rsquo;inconvénient à le faire sur un tableau C ici, mais le standard ne le prévoit pas.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/03/stdarray-oui-mais-pourquoi/#déduction-de-taille-vs-taille-explicite"><h2 id="déduction-de-taille-vs-taille-explicite">Déduction de taille VS taille explicite</h2></a>
<p>Un gros avantage du tableau C se situe sur la déclaration de la taille au moment de l&rsquo;initialisation: le compilateur peut la déduire. Alors qu&rsquo;avec <code>std::array</code> il faut la mettre en paramètre template au risque d&rsquo;y mettre une valeur trop grande (une valeur trop petite donne une erreur).</p>
<p>Sauf que depuis C++17, les <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">guides de déduction</a> rendent optionnels les paramètres template. Ce n&rsquo;est pas un strict équivalent puisque le type est aussi déduit, mais c&rsquo;est généralement ce qu&rsquo;on veut car tous les éléments doivent être du même type<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. Dans le pire des cas, on peut se tourner vers quelque chose comme <code>std::make_array&lt;T&gt;(xs...)</code> (en TS) qui permet de spécifier le type du tableau sans indiquer explicitement la taille.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">a1</span><span class="p">[</span><span class="mi">3</span><span class="p">]{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="kt">int</span> <span class="n">a2</span><span class="p">[]{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span> <span class="c1">// taille implicite
</span><span class="c1"></span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">a3</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="n">a4</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// taille et type implicites
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="n">a5</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// taille implicite
</span></code></pre></div><section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>On notera que <code>auto a[] {1,2,3}</code> n&rsquo;est pas autorisé.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2019-03-29T17:28:19">29 mars 2019
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  

  <br/><a href="https://jonathanpoelen.github.io/2019/03/stdarray-oui-mais-pourquoi/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="8f57f6c0a6a13d37f24c60e9a5993627-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=stdarray-oui-mais-pourquoi&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f03%2fstdarray-oui-mais-pourquoi%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f03%2fstdarray-oui-mais-pourquoi%2f&amp;title=stdarray-oui-mais-pourquoi" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f03%2fstdarray-oui-mais-pourquoi%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f03%2fstdarray-oui-mais-pourquoi%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f03%2fstdarray-oui-mais-pourquoi%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f03%2fstdarray-oui-mais-pourquoi%2f&amp;name=stdarray-oui-mais-pourquoi" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="grep-sed-awk-sort...-non-zsh"><span>
        <a href="#stdarray-oui-mais-pourquoi"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: std::array, oui, mais pourquoi ?"></i></a>
        <a href="#presque-toujours-stdmove"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Presque toujours std::move"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/">Grep, sed, awk, sort... Non ! Zsh</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#stdarray-oui-mais-pourquoi">Article suivant: std::array, oui, mais pourquoi ?</a><br/>
        <a href="#presque-toujours-stdmove">Article précédent: Presque toujours std::move</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2019-01-28T22:45:03">28 janvier 2019
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/zsh" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>zsh</a>, <a class="meta-categories__link" href="/categories/script-shell" rel="category">script shell</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>5 minutes ;
  <a href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#ffdfc9a9c9da44f723144c5e62cea7d4-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
  

</p>


  </header>
  <div class="post__content">
      <p>Depuis plusieurs années maintenant, j&rsquo;utilise Zsh comme shell par défaut. Et par la force des choses, il m&rsquo;arrive de taper des commandes zsh, de faire des boucles zsh, de penser zsh. Bref, de coder en zsh. Bien que le langage a des inconvénients, il possède de nombreuses fonctionnalités qui recouvrent celles de certains utilitaires Unix.</p>
<p>Les gros avantage d&rsquo;utiliser zsh plutôt que les commandes Unix sont au nombre de 3:</p>
<ul>
<li>Pas de post traitement pour mettre le résultat d&rsquo;une commande dans une variable.</li>
<li>Beaucoup plus rapide que lancer une commande. La création de process prend du temps et se ressent dans une boucle.</li>
<li>Écrire en 3 lettres ce qu&rsquo;on peut faire en 32. C&rsquo;est-à-dire frimer ;).</li>
</ul>
<p>Il y a aussi des inconvénients:</p>
<ul>
<li>Moins lisible, surtout lorsque l&rsquo;on remplace une suite de pipe comme <span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">aaa <span class="p">|</span> bbb <span class="p">|</span> ccc</code></span>. Mais on peut simplifier avec des variables intermédiaires.</li>
<li>Peut être plus lent lorsqu&rsquo;il y a beaucoup de texte à manipuler. En gros, faire un grep d&rsquo;un fichier de 1000 lignes est plus lent qu&rsquo;avec zsh, mais plus rapide si le fichier fait 100000 lignes, car zsh ne travaille pas par flux.</li>
</ul>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#syntaxe-de-base"><h2 id="syntaxe-de-base">Syntaxe de base</h2></a>
<p>Le <code>man</code> de zsh fait plus de 5 fois celui de bash. Le manuel est tellement gros qu&rsquo;il est divisé en 16 parties + un <span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">man zshall</code></span> pour les afficher tous. Difficile de tout mettre en 1 article alors je me contente de certaines parties de <code>zshexpn</code> (zsh expansion and substitution). Parmi celles utilisées ici il y a les options d&rsquo;expansion de paramètres (<span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="p">(@)x</span><span class="si">}</span></code></span>) et les modificateurs (<span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="nv">x</span><span class="p">:</span><span class="nv">h</span><span class="si">}</span></code></span> ou <span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="nv">$x</span>:h</code></span>). Il existe un pdf compilant les options et syntaxe de zsh: <a href="http://www.bash2zsh.com/zsh_refcard/refcard.pdf">http://www.bash2zsh.com/zsh_refcard/refcard.pdf</a>.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#lire-un-fichier"><h3 id="lire-un-fichier">Lire un fichier</h3></a>
<p>Voici comment les scripts zsh peuvent lire un fichier et mettre chaque ligne dans un tableau grâce aux extensions de paramètres:</p>
<div class="highlight"><pre class="chroma"><code class="language-zsh" data-lang="zsh"><span class="nv">contents</span><span class="o">=</span><span class="k">$(</span>&lt;file<span class="k">)</span> <span class="c1"># lire un fichier</span>
<span class="nv">contents</span><span class="o">=</span><span class="k">$(</span>&lt;file1 &lt;file2<span class="k">)</span> <span class="c1"># lire 2 fichiers</span>
<span class="nv">contents</span><span class="o">=</span><span class="k">$(</span>&lt;file <span class="p">;</span> ls<span class="k">)</span> <span class="c1"># lire un fichier et le retour de la commande `ls`</span>

<span class="nv">lines</span><span class="o">=(</span> <span class="si">${</span><span class="p">(f)contents</span><span class="si">}</span> <span class="o">)</span> <span class="c1"># tableau sans ligne vide</span>
<span class="nv">lines</span><span class="o">=(</span> <span class="si">${</span><span class="p">(s:</span><span class="se">\n</span><span class="p">:)contents</span><span class="si">}</span> <span class="o">)</span> <span class="c1"># équivalent</span>
<span class="nv">lines</span><span class="o">=(</span> <span class="s2">&#34;</span><span class="si">${</span><span class="p">(@f)contents</span><span class="si">}</span><span class="s2">&#34;</span> <span class="o">)</span> <span class="c1"># tableau avec toutes les lignes (il faut les quotes et @)</span>

<span class="nv">lines</span><span class="o">=(</span> <span class="si">${</span><span class="p">(f)</span><span class="k">$(</span>&lt;file<span class="k">)</span><span class="si">}</span> <span class="o">)</span> <span class="c1"># forme condensée du premier cas</span>

<span class="c1"># -E permet de désactiver l&#39;interpréation des séquences d&#39;échappement (ex. \e)</span>
<span class="nb">echo</span> -E <span class="si">${</span><span class="p">(j:</span><span class="se">\n</span><span class="p">:)lines</span><span class="si">}</span> <span class="c1"># concatène les lignes avec \n</span>
<span class="c1"># ou</span>
<span class="nb">echo</span> -E <span class="si">${</span><span class="p">(F)lines</span><span class="si">}</span>

<span class="c1"># affiche chaque ligne d&#39;un fichier dans des crochets</span>
<span class="nb">echo</span> -E <span class="s2">&#34;[</span><span class="si">${</span><span class="p">(j:]</span><span class="se">\n</span><span class="p">[:)</span><span class="s2">&#34;</span><span class="si">${</span><span class="p">(@f)</span><span class="k">$(</span>&lt;file<span class="k">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="si">}</span><span class="s2">]&#34;</span>
</code></pre></div><p>Il y a encore de nombreux paramètres qui peuvent être trouvés dans le manuel ou via l&rsquo;auto-complétion de zsh. Aussi, pour simplifier les exemples qui suivront, j&rsquo;utiliserai directement les variables <code>contents</code> et <code>lines</code>.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#glob-et-glob-étendu"><h3 id="glob-et-glob-étendu">Glob et glob étendu</h3></a>
<p>L&rsquo;une des grandes forces de zsh réside dans le globbing. Il ne se restreint pas qu&rsquo;à la recherche de fichier, mais peut aussi s&rsquo;appliquer sur les éléments d&rsquo;un tableau ou des chaînes pour filtrer ou transformer. En plus de <code>*</code> et <code>?</code>, zsh comprend <code>[...]</code>, <code>[^...]</code> et <code>&lt;x-y&gt;</code> pour un nombre entre <code>x</code> et <code>y</code> inclu (<code>&lt;-&gt;</code> pour n&rsquo;importe quel digit).</p>
<p>Avec le glob étendu (<code>setopt extendedglob</code>) on possède alors un équivalent des regex:</p>
<ul>
<li><code>x#</code> 0 ou plus de <code>x</code></li>
<li><code>x##</code> 1 ou plus de <code>x</code></li>
<li><code>x~y</code> exclut <code>y</code> de <code>x</code></li>
<li><code>^x</code> tous sauf <code>x</code></li>
<li><code>(#s)</code> début (équivalent de <code>^</code> des regex)</li>
<li><code>(#e)</code> fin (équivalent de <code>$</code> des regex)</li>
</ul>
<p>Ainsi que la syntaxe ksh si activée</p>
<table>
<thead>
<tr>
<th>ksh-like</th>
<th>glob operators</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">@<span class="o">(</span>...<span class="o">)</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="o">(</span>...<span class="o">)</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">*<span class="o">(</span>...<span class="o">)</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="o">(</span>...<span class="o">)</span><span class="c1">#</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">+<span class="o">(</span>...<span class="o">)</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="o">(</span>...<span class="o">)</span><span class="c1">##</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">?<span class="o">(</span>...<span class="o">)</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="o">(</span><span class="p">|</span>...<span class="o">)</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">!<span class="o">(</span>...<span class="o">)</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="o">(</span>^<span class="o">(</span>...<span class="o">))</span></code></span></td>
</tr>
</tbody>
</table>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#équivalent-des-commandes-unix"><h2 id="équivalent-des-commandes-unix">Équivalent des commandes *Unix</h2></a>
<p>Maintenant que la petite introduction syntaxique est faite, on peut s&rsquo;attaquer au remplacement des commandes systèmes. Bien sûr, toutes les options d&rsquo;une commande ne peuvent pas être simulées facilement avec zsh, mais je présente ici l&rsquo;essentiel. Je précise que les commandes bash ont implicitement <span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="o">&lt;&lt;&lt;</span><span class="nv">$contents</span></code></span> comme flux de lecture et que le résultat des commandes zsh est fait avec un <code>echo -E</code>.</p>
<p>Je conseille aussi le petit <a href="https://github.com/zdharma/Zsh-100-Commits-Club/blob/master/Zsh-Native-Scripting-Handbook.adoc">Zsh Native Scripting Guide</a>.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#grep"><h3 id="grep">grep</h3></a>
<table>
<thead>
<tr>
<th>bash</th>
<th>zsh</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">grep <span class="s1">&#39;Alligator&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="p">(M)lines:#*Alligator*</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">grep -v <span class="s1">&#39;Alligator&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="nv">lines</span><span class="p">:#*Alligator*</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">grep <span class="s1">&#39;^Alligator .* Alligator$&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="p">(M)lines:#Alligator * Alligator</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">grep -i <span class="s1">&#39;alligator&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="p">(M)lines:#(#i)*alligator*</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">grep -m1 <span class="s1">&#39;alligator&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="nv">lines</span><span class="p">[(r)*alligator*]</span><span class="si">}</span></code></span></td>
</tr>
</tbody>
</table>
<p><code>(#i)</code> n&rsquo;est utilisable qu&rsquo;avec <code>setopt extendedglob</code> et peut s&rsquo;appliquer sur un groupe seulement de caractère (i.e. <code>((#i)a)lbator</code>). Il existe l&rsquo;option inverse: <code>#I</code>. Ainsi que <code>#l</code> qui fait une recherche insensible à la case pour les lettres minuscules du pattern, et en majuscule pour celles en majuscule dans le pattern.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#agrep"><h3 id="agrep">agrep</h3></a>
<p><code>agrep</code> pour &ldquo;approximate grep&rdquo;. C&rsquo;est un <code>grep</code> qui autorise une marge d&rsquo;erreur dans la recherche. Zsh possède une option de glob qui fait à peu près la même chose: <code>(#a3)</code> pour une recherche avec 3 erreurs.</p>
<table>
<thead>
<tr>
<th>bash</th>
<th>zsh</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">agrep -3 <span class="s1">&#39;alligator&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="p">(M)lines:#*((#a3)alligator)*</span><span class="si">}</span></code></span></td>
</tr>
</tbody>
</table>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#sed"><h3 id="sed">sed</h3></a>
<table>
<thead>
<tr>
<th>bash</th>
<th>zsh</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">sed <span class="s1">&#39;3,6!d&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="nv">$lines</span><span class="o">[</span>3,5<span class="o">]</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">sed s/alligator/crocodile/</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="nv">contents</span><span class="p">/alligator/crocodile</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">sed s/alligator/crocodile/g</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="nv">contents</span><span class="p">//alligator/crocodile</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">sed <span class="s1">&#39;s/^alligator\*$/_/&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="nv">lines</span><span class="p">:</span><span class="nv">s</span><span class="p">%alligator*%_</span><span class="si">}</span></code></span> ou <span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="nv">lines</span><span class="p">/(#s)alligator</span><span class="se">\*</span><span class="p">(#e)/_</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">sed <span class="s1">&#39;s/^\w\+$/[&amp;]/&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="nv">lines</span><span class="p">:/(#m)[[:</span><span class="nv">alnum</span><span class="p">:]]##/[</span><span class="nv">$MATCH</span><span class="p">]</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">sed -E <span class="s1">&#39;s/^(\w+) = (\w+)$/\2 = \1/&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="nv">lines</span><span class="p">:/(#b)([[:</span><span class="nv">alnum</span><span class="p">:]]##) = ([[:</span><span class="nv">alnum</span><span class="p">:]]##)/</span><span class="nv">$match</span><span class="p">[2] = </span><span class="nv">$match</span><span class="p">[1]</span><span class="si">}</span></code></span></td>
</tr>
</tbody>
</table>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#head"><h3 id="head">head</h3></a>
<table>
<thead>
<tr>
<th>bash</th>
<th>zsh</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">head -n3</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="nv">$lines</span><span class="o">[</span>1,3<span class="o">]</span></code></span></td>
</tr>
</tbody>
</table>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#awk"><h3 id="awk">awk</h3></a>
<p>Pour celui-là, l&rsquo;entrée sera le texte ci-dessous. Le programme va coloriser le préfixe.</p>
<pre><code>info: un alligator dort sur le balcon
avertissement: l'alligator se réveille
erreur: l'alligator attaque
note: penser à investir dans une porte plus solide
</code></pre><table>
<thead>
<tr>
<th>awk</th>
<th>zsh</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-awk" data-lang="awk"><span class="nb">BEGIN</span> <span class="p">{</span>
  <span class="nx">colors</span><span class="p">[</span><span class="s2">&#34;erreur:&#34;</span><span class="p">]</span><span class="o">=</span><span class="s2">&#34;31&#34;</span>
  <span class="nx">colors</span><span class="p">[</span><span class="s2">&#34;avertissement:&#34;</span><span class="p">]</span><span class="o">=</span><span class="s2">&#34;33&#34;</span>
  <span class="nx">colors</span><span class="p">[</span><span class="s2">&#34;info:&#34;</span><span class="p">]</span><span class="o">=</span><span class="s2">&#34;35&#34;</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">k</span> <span class="o">in</span> <span class="nx">colors</span><span class="p">)</span>
    <span class="nx">colorized</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span><span class="o">=</span><span class="s2">&#34;\033[&#34;</span> <span class="nx">colors</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="s2">&#34;m&#34;</span> <span class="nx">k</span> <span class="s2">&#34;\033[0m&#34;</span>
<span class="p">}</span>
<span class="p">{</span>
  <span class="nx">s</span><span class="o">=</span><span class="nx">colorized</span><span class="p">[</span><span class="o">$</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="kr">print</span> <span class="nx">s</span> <span class="kr">substr</span><span class="p">(</span><span class="o">$</span><span class="mi">0</span><span class="p">,</span> <span class="kr">length</span><span class="p">(</span><span class="o">$</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="kr">print</span> <span class="o">$</span><span class="mi">0</span>
<span class="p">}</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">setopt extendedglob

<span class="nb">declare</span> -A <span class="nv">colors</span><span class="o">=(</span>
  erreur: <span class="m">31</span>
  avertissement: <span class="m">33</span>
  info: <span class="m">35</span>
<span class="o">)</span>
<span class="nb">declare</span> -A colorized
<span class="nv">esc</span><span class="o">=</span><span class="s1">$&#39;\e&#39;</span>
<span class="k">for</span> k in <span class="si">${</span><span class="p">(k)colors</span><span class="si">}</span> <span class="p">;</span>
  <span class="nv">colorized</span><span class="o">+=(</span><span class="nv">$k</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">esc</span><span class="si">}</span><span class="s2">[</span><span class="nv">$colors</span><span class="s2">[</span><span class="nv">$k</span><span class="s2">]m</span><span class="nv">$k</span><span class="si">${</span><span class="nv">esc</span><span class="si">}</span><span class="s2">[0m&#34;</span><span class="o">)</span>

<span class="nb">echo</span> -E <span class="si">${</span><span class="p">(F)lines/(#m)(#s)[a-z]##:/</span><span class="si">${</span><span class="nv">colorized</span><span class="p">[</span><span class="nv">$MATCH</span><span class="p">]</span><span class="k">:-</span><span class="nv">$MATCH</span><span class="si">}}</span></code></span></td>
</tr>
</tbody>
</table>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#find"><h3 id="find">find</h3></a>
<table>
<thead>
<tr>
<th>bash</th>
<th>zsh</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">find -name <span class="s1">&#39;*alligator*&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">**/*alligator*</code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">find -name <span class="s1">&#39;*alligator*&#39;</span> -a -not <span class="s1">&#39;*crocodile*&#39;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">**/*alligator*~*crocodile*</code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">find -type d</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">**/*<span class="o">(</span>/<span class="o">)</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">find -not -type d</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">**/*<span class="o">(</span>^/<span class="o">)</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">find -type l</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">**/*<span class="o">(</span>@<span class="o">)</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">find -atime <span class="m">3</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">**/*<span class="o">(</span>a3<span class="o">)</span></code></span></td>
</tr>
</tbody>
</table>
<p>Bon, vous l&rsquo;aurez compris, zsh permet de nombreux filtres dans la recherche de fichier. Il peut trier la recherche par date, nom, groupe, etc ou même via une fonction personnalisée.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#sort"><h3 id="sort">sort</h3></a>
<table>
<thead>
<tr>
<th>bash</th>
<th>zsh</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">sort</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="p">(o)lines</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">sort -n</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="p">(on)lines</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">sort -rn</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="p">(On)lines</span><span class="si">}</span></code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">sort -u</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="p">(uo)lines</span><span class="si">}</span></code></span></td>
</tr>
</tbody>
</table>
<p>À noter que <span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="p">(u)lines</span><span class="si">}</span></code></span> élimine les doublons sans trier le tableau.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#manipulation-de-chemin"><h3 id="manipulation-de-chemin">Manipulation de chemin</h3></a>
<table>
<thead>
<tr>
<th>bash</th>
<th>zsh</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">dirname <span class="s2">&#34;</span><span class="nv">$0</span><span class="s2">&#34;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="nv">$0</span>:h</code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">basename <span class="s2">&#34;</span><span class="nv">$0</span><span class="s2">&#34;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="nv">$0</span>:t</code></span></td>
</tr>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">realpath <span class="s2">&#34;</span><span class="nv">$0</span><span class="s2">&#34;</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="nv">$0</span>:P</code></span></td>
</tr>
</tbody>
</table>
<p>Il y en a évidemment d&rsquo;autres.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#cut"><h3 id="cut">cut</h3></a>
<table>
<thead>
<tr>
<th>bash</th>
<th>zsh</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh">cut -d: -f2,1</code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="si">${</span><span class="nv">lines</span><span class="p">/(#m)*/</span><span class="k">$((</span><span class="o">)</span> <span class="o">{</span> <span class="nb">echo</span> <span class="o">-</span>E <span class="nv">$2</span>:<span class="nv">$1</span> <span class="o">}</span> <span class="si">${</span><span class="p">(s:</span><span class="nv">b</span><span class="p">:)MATCH</span><span class="si">}</span><span class="o">)}</span></code></span></td>
</tr>
</tbody>
</table>
<p>Mais une boucle serait mieux ici.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/#printf"><h3 id="printf">printf</h3></a>
<table>
<thead>
<tr>
<th>bash</th>
<th>zsh</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="nb">printf</span> <span class="s1">&#39;%04d&#39;</span> <span class="m">42</span></code></span></td>
<td><span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="nb">echo</span> -E <span class="si">${</span><span class="p">(l:</span><span class="nv">4</span><span class="p">::</span><span class="nv">0</span><span class="p">:)</span><span class="si">${</span><span class="k">:-</span><span class="nv">42</span><span class="si">}}</span></code></span> ou <span class="inlinecode highlight"><code class="language-zsh" data-lang="zsh"><span class="nb">echo</span> -E <span class="si">${</span><span class="p">(l:</span><span class="nv">4</span><span class="p">::</span><span class="nv">0</span><span class="p">:)</span><span class="nv">$n</span><span class="si">}</span></code></span></td>
</tr>
</tbody>
</table>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2019-01-28T22:45:03">28 janvier 2019
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/zsh" rel="category">zsh</a>, <a class="meta-categories__link" href="/categories/script-shell" rel="category">script shell</a>
 ;
  

  

  <br/><a href="https://jonathanpoelen.github.io/2019/01/grep-sed-awk-sort...-non-zsh/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="ffdfc9a9c9da44f723144c5e62cea7d4-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=grep-sed-awk-sort...-non-zsh&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f01%2fgrep-sed-awk-sort...-non-zsh%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f01%2fgrep-sed-awk-sort...-non-zsh%2f&amp;title=grep-sed-awk-sort...-non-zsh" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f01%2fgrep-sed-awk-sort...-non-zsh%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f01%2fgrep-sed-awk-sort...-non-zsh%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f01%2fgrep-sed-awk-sort...-non-zsh%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2019%2f01%2fgrep-sed-awk-sort...-non-zsh%2f&amp;name=grep-sed-awk-sort...-non-zsh" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="presque-toujours-stdmove"><span>
        <a href="#grep-sed-awk-sort...-non-zsh"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Grep, sed, awk, sort... Non ! Zsh"></i></a>
        <a href="#m%25C3%25A9ta-fonction-et-continuation"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Méta-fonction et continuation"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2018/12/presque-toujours-stdmove/">Presque toujours std::move</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#grep-sed-awk-sort...-non-zsh">Article suivant: Grep, sed, awk, sort... Non ! Zsh</a><br/>
        <a href="#m%25C3%25A9ta-fonction-et-continuation">Article précédent: Méta-fonction et continuation</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2018-12-09T13:11:29">09 décembre 2018
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>2 minutes ;
  <a href="https://jonathanpoelen.github.io/2018/12/presque-toujours-stdmove/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#f5c829c4a296c3dc8dd76923c74b4885-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
  

</p>


  </header>
  <div class="post__content">
      <p>Le principe de <code>std::move</code> est de &ldquo;déplacer<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>&rdquo; un objet qui n&rsquo;est plus utilisé dans l&rsquo;objectif de décharger la responsabilité dans une autre variable ou d&rsquo;utiliser le constructeur de déplacement à la place de celui de copie.</p>
<p>Pour avoir de meilleures performances, il est tentant de le mettre partout lorsque la variable n&rsquo;est plus utilisée. Un constructeur de déplacement sera toujours préférable au constructeur de copie, pourquoi s&rsquo;en priver ?</p>
<p><em>Rire sarcastique.</em></p>
<p>Parce qu&rsquo;il est possible de &ldquo;déplacer&rdquo; les valeurs sans passer le constructeur !</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/12/presque-toujours-stdmove/#du-déplacement-sans-stdmove"><h2 id="du-déplacement-sans-stdmove">Du &ldquo;déplacement&rdquo; sans std::move</h2></a>
<p>C&rsquo;est fort du roquefort ! Pas de constructeur, pas de <code>std::move</code>, mais un objet qui se déplace quand même. On croirait faire de la magie !</p>
<p><code>std::move</code> va forcer l&rsquo;appel à un constructeur de déplacement alors que le compilateur a les moyens &ndash; et même l&rsquo;obligation &ndash; de le faire pour nous. Ou mieux, bypasser tous les constructeurs et mettre la valeur directement là où il faut. On parle d'<a href="https://en.cppreference.com/w/cpp/language/copy_elision">élision par copie</a> ou de (N)RVO (Named Return Value Optimization). Sauf que <code>std::move</code> bloque ces optimisations.</p>
<p>Dans le cas de l&rsquo;élision de copie, le compilateur construit directement les paramètres de type T (un type sans référence) lorsqu&rsquo;on utilise un temporaire.</p>
<p>Avec <code>void foo(T)</code>, il faut faire <code>foo(T{...})</code> et non pas <code>foo(std::move(T({...})</code>. Comme on ne fait pas <code>T x = std::move(T{...})</code>, mais <code>T x = T{...}</code> (on peut faire <code>T x{}</code>, c&rsquo;est pour l&rsquo;exemple)</p>
<p>Les temporaires peuvent aussi exister depuis l&rsquo;appel à une fonction qui retourne <code>T</code>.</p>
<p>Avec <code>T bar()</code>, il faut faire <code>foo(bar())</code>, et non pas <code>foo(std::move(bar()))</code>.</p>
<p>La (N)RVO est une optimisation qui fonctionne sur le même principe au niveau de la valeur de retour.</p>
<p>On n&rsquo;écrit pas <code>T bar() { return std::move(T{...}); }</code>, mais <code>T bar() { return T{...}; }</code>.</p>
<p>Le compilateur possède aussi un comportement spécial pour la variable locale retournée: celle-ci doit être déplacée si possible. Et si possible, on optimise avec une élision.</p>
<p>On écrit</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">T</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>À la place de</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">T</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Au final, les seuls moments où <code>std::move</code> devrait être utilisé, sont</p>
<ul>
<li>Pour transférer une variable de type référence (lvalue ou rvalue) en la forçant en rvalue.</li>
<li>Pour passer une variable de type plein (sans référence) à une autre fonction.</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>std::move n&rsquo;est qu&rsquo;un <code>static_cast&lt;T&amp;&amp;&gt;</code>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2018-12-09T13:11:29">09 décembre 2018
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  

  <br/><a href="https://jonathanpoelen.github.io/2018/12/presque-toujours-stdmove/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="f5c829c4a296c3dc8dd76923c74b4885-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=presque-toujours-stdmove&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f12%2fpresque-toujours-stdmove%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f12%2fpresque-toujours-stdmove%2f&amp;title=presque-toujours-stdmove" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f12%2fpresque-toujours-stdmove%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f12%2fpresque-toujours-stdmove%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f12%2fpresque-toujours-stdmove%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f12%2fpresque-toujours-stdmove%2f&amp;name=presque-toujours-stdmove" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="m%C3%A9ta-fonction-et-continuation"><span>
        <a href="#presque-toujours-stdmove"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Presque toujours std::move"></i></a>
        <a href="#simuler-une-vtable-sans-fonction-virtuelle"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Simuler une vtable sans fonction virtuelle"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2018/11/meta-fonction-et-continuation/">Méta-fonction et continuation</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#presque-toujours-stdmove">Article suivant: Presque toujours std::move</a><br/>
        <a href="#simuler-une-vtable-sans-fonction-virtuelle">Article précédent: Simuler une vtable sans fonction virtuelle</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2018-11-08T18:56:13">08 novembre 2018
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>5 minutes ;
  <a href="https://jonathanpoelen.github.io/2018/11/meta-fonction-et-continuation/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#f973cbc536ee57ce86d89c62a7c4c20f-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
  

</p>


  </header>
  <div class="post__content">
      <p>J&rsquo;ai pas mal bossé avec des bibliothèques de méta-programmation, et une que j&rsquo;apprécie particulièrement est <a href="https://github.com/kvasir-io/mpl">Kvasir.Mpl</a>. Son originalité réside dans le support des <a href="https://fr.wikipedia.org/wiki/Continuation">continuations</a> et &ndash;parce que cela va bien de paire,&ndash; l&rsquo;évaluation paresseuse ainsi que des algorithmes pensés pour manipuler des packs (template variadique) plutôt que des listes de type (<code>list&lt;Ts...&gt;</code>).</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/11/meta-fonction-et-continuation/#continuation"><h2 id="continuation">Continuation</h2></a>
<p>Chaque algorithme dispose d&rsquo;un paramètre qui décrit l&rsquo;étape suivante du traitement, c&rsquo;est la continuation. En shell ou dans des bibliothèques comme <a href="https://github.com/ericniebler/range-v3">rangev3</a>, les continuations se font avec l&rsquo;opérateur <code>|</code>. Par exemple <code>grep x | wc -l</code> ou <code>filter(is_odd) | take(6)</code>. Il n&rsquo;est pas possible d&rsquo;utiliser <code>|</code> avec des templates, alors la continuation est un paramètre ajouté à l&rsquo;algorithme. En chaînant les continuations, on construit un nouvel algorithme qui s&rsquo;utilise avec <code>call&lt;algo, args...&gt;</code>.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// `C` pour continuation
</span><span class="c1"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">add_const</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">add_lvalue_reference</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">add_const_lvalue_reference</span> <span class="o">=</span> <span class="n">add_const</span><span class="o">&lt;</span><span class="n">add_lvalue_reference</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;&gt;</span><span class="p">;</span> <span class="c1">// un chaînage
</span></code></pre></div>

<p>Les continuations limitent drastiquement le recours aux &ldquo;lambdas&rdquo;. Dans d&rsquo;autres bibliothèques du genre, <code>add_const_lvalue_reference</code> s&rsquo;écrirait <code>lambda&lt;add_lvalue_reference, lambda&lt;add_const, _&gt;&gt;</code> ce qui est, il faut l&rsquo;avouer, beaucoup moins glamour.</p>
<p>Dans des algorithmes du type transformation, l&rsquo;impact sur la lecture du code est immédiat:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">transform</span><span class="o">&lt;</span><span class="n">lambda</span><span class="o">&lt;</span><span class="n">next</span><span class="p">,</span> <span class="n">lambda</span><span class="o">&lt;</span><span class="n">times</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="o">&gt;</span>
<span class="c1">// vs
</span><span class="c1"></span><span class="n">call</span><span class="o">&lt;</span><span class="n">transform</span><span class="o">&lt;</span><span class="n">times</span><span class="o">&lt;</span><span class="n">next</span><span class="o">&lt;&gt;</span><span class="cm">/*, C=listify*/</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="o">&gt;</span>
</code></pre></div><p>Qui se traduit par la construction d&rsquo;une nouvelle liste avec la formule <code>(x*y)+1</code>.</p>
<p>Ce code met bien en évidence un autre aspect des continuations: la lecture du code se fait de gauche à droite alors que les lambdas se lisent de droite à gauche et oblige le lecteur à faire des allers/retours pour suivre le flux de code.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">transform</span><span class="o">&lt;</span><span class="n">lambda</span><span class="o">&lt;</span><span class="n">next</span><span class="p">,</span> <span class="n">lambda</span><span class="o">&lt;</span><span class="n">times</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="o">&gt;</span>
 <span class="cm">/* 1 */</span>       <span class="cm">/* 3 */</span>       <span class="cm">/* 2 */</span>
<span class="n">call</span><span class="o">&lt;</span><span class="n">transform</span><span class="o">&lt;</span><span class="n">times</span><span class="o">&lt;</span><span class="n">next</span><span class="o">&lt;&gt;</span><span class="cm">/*, C=listify*/</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="o">&gt;</span>
      <span class="cm">/* 1 *//* 2 *//* 3 */</span>      <span class="cm">/* 4 */</span>
</code></pre></div><a class="headline-hash" href="https://jonathanpoelen.github.io/2018/11/meta-fonction-et-continuation/#méta-fonction"><h2 id="méta-fonction">Méta-fonction</h2></a>
<p>Au niveau de kvasir, une méta-fonction est un type qui possède un membre template nommé <code>f</code>. Tous les algorithmes de kvasir sont des méta-fonctions et l&rsquo;appel se fait avec <code>call&lt;metafunc, param1, param2,...&gt;</code>. Si on complète <code>add_const</code> et <code>add_lvalue_reference</code> plus haut, cela donne:</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">call</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">F</span><span class="o">::</span><span class="k">template</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">add_const</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">f</span> <span class="o">=</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">add_lvalue_reference</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">f</span> <span class="o">=</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&gt;</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>Il ne reste qu&rsquo;une dernière étape, la continuation finale lorsqu&rsquo;il n&rsquo;y a plus rien à faire. Les plus utilisés sont au nombre de 2 et servent de valeur par défaut à l&rsquo;ensemble des algorithmes, j&rsquo;ai nommé <code>identity</code> et <code>listify</code>.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">identity</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">f</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">list</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nc">listify</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">f</span> <span class="o">=</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/11/meta-fonction-et-continuation/#cest-beau-cest-propre"><h2 id="cest-beau-cest-propre">C&rsquo;est beau, c&rsquo;est propre</h2></a>
<p>Il y a quelques jours, après mon petit passage quotidien dans libstdc++ et en regardant <code>std::decay</code>, je me suis dit <del>c&rsquo;est beau, c&rsquo;est propre</del> qu&rsquo;il faudrait comparer avec une implémentation qui utilise les concepts de kvasir.</p>
<p>Voici en l&rsquo;état la version fournie avec gcc-8.2:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Decay trait for arrays and functions, used for perfect forwarding
</span><span class="c1">// in make_pair, make_tuple, etc.
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Up</span><span class="p">,</span>
     <span class="kt">bool</span> <span class="n">_IsArray</span> <span class="o">=</span> <span class="n">is_array</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
     <span class="kt">bool</span> <span class="n">_IsFunction</span> <span class="o">=</span> <span class="n">is_function</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">__decay_selector</span><span class="p">;</span>

<span class="c1">// NB: DR 705.
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Up</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">__decay_selector</span><span class="o">&lt;</span><span class="n">_Up</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
  <span class="p">{</span> <span class="k">typedef</span> <span class="k">typename</span> <span class="n">remove_cv</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">__type</span><span class="p">;</span> <span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Up</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">__decay_selector</span><span class="o">&lt;</span><span class="n">_Up</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
  <span class="p">{</span> <span class="k">typedef</span> <span class="k">typename</span> <span class="n">remove_extent</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="n">__type</span><span class="p">;</span> <span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Up</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">__decay_selector</span><span class="o">&lt;</span><span class="n">_Up</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
  <span class="p">{</span> <span class="k">typedef</span> <span class="k">typename</span> <span class="n">add_pointer</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">__type</span><span class="p">;</span> <span class="p">};</span>

<span class="c1">/// decay
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">decay</span>
  <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">__remove_type</span><span class="p">;</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">__decay_selector</span><span class="o">&lt;</span><span class="n">__remove_type</span><span class="o">&gt;::</span><span class="n">__type</span> <span class="n">type</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></div><p>En réalité, ce qui m&rsquo;a particulièrement tiqué se situe dans la déclaration de <code>__decay_selector</code>: <code>is_array</code> et <code>is_function</code> sont toujours évaluées avec <code>_Up</code> et il faut écrire plusieurs spécialisations.</p>
<p>L&rsquo;idée du sélecteur est un bon concept et se remplace facilement par une suite de conditions:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// ce que fait plus ou moins libc++ de llvm
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">__decay_selector</span> <span class="o">=</span> <span class="n">conditional</span><span class="o">&lt;</span>
  <span class="n">is_array_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">remove_extent_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">,</span>
  <span class="n">conditional_t</span><span class="o">&lt;</span>
    <span class="n">is_function_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">add_pointer_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">remove_cv_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
  <span class="o">&gt;</span>
<span class="o">&gt;</span><span class="p">;</span>
</code></pre></div><p>Qui engendre son lot de problèmes: en plus des 2 traits précédents, <code>remove_extent</code>, <code>add_pointer</code> et <code>remove_cv</code> sont toujours déclarés avec <code>T</code>. Cela ne pose pas de réel problème ici &ndash; à part le temps de compilation&ndash;, malheureusement, dans certaines situations, les branches ne doivent s&rsquo;évaluer qu&rsquo;en fonction du prédicat et les traits de la STL ne le permettent pas sans ajouter des intermédiaires.</p>
<p>Mais les continuations changent tout puisque les méta-fonctions ne sont évaluées que pour la branche qui respecte le prédicat. Ainsi, <code>remove_extent&lt;T&gt;</code> ne sera pas instancié lorsque <code>is_array_v&lt;T&gt;</code> est faux, ce qui rend les continuations très facilement composables.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">decay</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">call</span><span class="o">&lt;</span>
    <span class="n">if_</span><span class="o">&lt;</span>
      <span class="n">cfl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_array</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">cfe</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_extent</span><span class="p">,</span> <span class="n">cfe</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">add_pointer_impl</span><span class="o">&gt;&gt;</span><span class="p">,</span>
      <span class="n">if_</span><span class="o">&lt;</span>
        <span class="n">cfl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_function</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">cfe</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">add_pointer</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">cfe</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_cv</span><span class="o">&gt;</span>
      <span class="o">&gt;</span>
    <span class="o">&gt;</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
  <span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>Avec l&rsquo;implémentation de <code>if_</code>, <code>cfl</code> (continuation from a lazy metafunction) et <code>cfe</code> (continuation from a eager metafunction):</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">conditional</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">TC</span><span class="p">,</span> <span class="k">class</span> <span class="nc">FC</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">if_</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">f</span> <span class="o">=</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">call</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="n">call</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TC</span><span class="p">,</span> <span class="n">FC</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">...</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">class</span> <span class="nc">C</span> <span class="o">=</span> <span class="n">identity</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">cfl</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">f</span> <span class="o">=</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="n">F</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">...</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">class</span> <span class="nc">C</span> <span class="o">=</span> <span class="n">identity</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">cfe</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">f</span> <span class="o">=</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">F</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">conditional</span>
  <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">f</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;&gt;</span>
  <span class="k">struct</span> <span class="nc">conditional</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">f</span> <span class="o">=</span> <span class="n">U</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></div>

<p>L&rsquo;ensemble des sources se trouve sur <a href="https://github.com/jonathanpoelen/jonathanpoelen.github.io/tree/source/resources/metafunc_continuation/decay.cpp">github</a>
.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2018-11-08T18:56:13">08 novembre 2018
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  

  <br/><a href="https://jonathanpoelen.github.io/2018/11/meta-fonction-et-continuation/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="f973cbc536ee57ce86d89c62a7c4c20f-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=m%25C3%25A9ta-fonction-et-continuation&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fmeta-fonction-et-continuation%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fmeta-fonction-et-continuation%2f&amp;title=m%25C3%25A9ta-fonction-et-continuation" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fmeta-fonction-et-continuation%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fmeta-fonction-et-continuation%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fmeta-fonction-et-continuation%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fmeta-fonction-et-continuation%2f&amp;name=m%25C3%25A9ta-fonction-et-continuation" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="simuler-une-vtable-sans-fonction-virtuelle"><span>
        <a href="#m%25C3%25A9ta-fonction-et-continuation"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Méta-fonction et continuation"></i></a>
        <a href="#comparaison-de-diff%25C3%25A9rentes-impl%25C3%25A9mentations-de-mp_index_of"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Comparaison de différentes implémentations de mp_index_of"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2018/11/simuler-une-vtable-sans-fonction-virtuelle/">Simuler une vtable sans fonction virtuelle</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#m%25C3%25A9ta-fonction-et-continuation">Article suivant: Méta-fonction et continuation</a><br/>
        <a href="#comparaison-de-diff%25C3%25A9rentes-impl%25C3%25A9mentations-de-mp_index_of">Article précédent: Comparaison de différentes implémentations de mp_index_of</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2018-11-01T20:42:09">01 novembre 2018
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>5 minutes ;
  <a href="https://jonathanpoelen.github.io/2018/11/simuler-une-vtable-sans-fonction-virtuelle/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#442b3694da91a9866c991b248ee3f410-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
  

</p>


  </header>
  <div class="post__content">
      <p>La <code>vtable</code> est le mécanisme interne utilisé par C++ pour implémenter les fonctions virtuelles. Lorsqu&rsquo;une classe possède une fonction virtuelle, un pointeur sur la <code>vtable</code> (virtual table) est automatiquement réservé par le compilateur. Cette table contient des pointeurs de fonction sur l&rsquo;ensemble des fonctions virtuelles de la classe et chaque classe dérivée possède sa propre <code>vtable</code>.</p>
<p>Pour une classe de base implémentant une fonction <code>foo</code> virtuelle comme ci-dessous, l&rsquo;utilisation de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">obj</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">(</span><span class="cm">/*params...*/</span><span class="p">)</span></code></span> va être remplacé par quelque chose proche de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">cast</span><span class="o">&lt;</span><span class="n">FunctionType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">__vtable</span><span class="p">[</span><span class="mi">0</span><span class="p">])(</span><span class="n">obj</span><span class="cm">/*, params...*/</span><span class="p">)</span></code></span>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">Base</span>
<span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>Chaque classe dérivée qui ajoute des fonctions virtuelles réserve des cases supplémentaires dans son tableau. Le compilateur se basant sur les types utilisés pour garantir la validité des indices.</p>
<p>Ce fonctionnement est très économique : un pointeur pour chaque instance d&rsquo;une classe et une vtable en lecture seule par classe. C&rsquo;est également très facile d&rsquo;ajouter de nouvelles tables, y compris dynamiquement par le chargement de bibliothèque. Mais il y a aussi des inconvénients comme une fragmentation mémoire au niveau de la position des tables et un double déréférencement pour accéder au pointeur de fonction.</p>
<p>Pour la suite on se base sur une interface avec une fonction draw: <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span></code></span> et 2 objets ce qu&rsquo;il a de plus classique: <code>Rect</code> et <code>Circle</code>.</p>

<div class="highlight"><pre class="chroma"><code class="language-hpp" data-lang="hpp"><span class="k">struct</span> <span class="nc">Rect</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Rect</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Circle</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Circle</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></div>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/11/simuler-une-vtable-sans-fonction-virtuelle/#une-vtable-à-la-mano"><h2 id="une-vtable-à-la-mano">Une vtable à la mano</h2></a>
<p>Notre vtable va contenir des pointeurs de fonction. Le type commun d&rsquo;une majorité de pointeurs est <code>void*</code>. Sauf que les pointeurs de fonction sont une exception, il n&rsquo;est pas légal de les transformer en <code>void*</code> &ndash; même si en interne le compilateur peut se le permettre pour sa vtable. Par contre, on peut récupérer l&rsquo;adresse du pointeur de fonction pour avoir un pointeur de pointeur de fonction. Cela fait beaucoup de pointeurs et d&rsquo;indirections alors le tableau sera remplacé par un tuple, car finalement on connait exactement les types de fonction que contient la vtable.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="n">draw_func_type</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="kt">void</span> <span class="k">const</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">);</span>

<span class="k">using</span> <span class="n">drawable_vtable</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">draw_func_type</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">;</span></code></pre></div>

<p>Maintenant qu&rsquo;on a un type pour la vtable, il faut pouvoir la construire à partir de n&rsquo;importe quel type qui pourrait supporter cette interface.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">auto</span> <span class="n">draw_func_ptr</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">base</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">drawable_vtable</span> <span class="n">drawable_vtable_for</span><span class="p">{</span>
  <span class="n">draw_func_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">};</span></code></pre></div>

<p>Grâce à ses variables inline, on peut construire notre tableau très facilement. Il ne reste plus qu&rsquo;à faire un petit wrapper pour utiliser <code>Rect</code> et <code>Circle</code> indistinctement.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">Drawable</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">Drawable</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">obj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">vtable</span><span class="p">(</span><span class="n">drawable_vtable_for</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vtable</span><span class="p">)(</span><span class="n">obj</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">obj</span><span class="p">;</span>
  <span class="n">drawable_vtable</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">vtable</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p><code>Drawable</code> pourrait contenir directement <code>Rect</code> ou <code>Circle</code> plutôt qu&rsquo;avoir un <code>void*</code>, mais pour supporter n&rsquo;importe quel type et être optimisé, il est préférable d&rsquo;utiliser <a href="https://akrzemi1.wordpress.com/2014/04/14/common-optimizations/">SBO (Small Buffer Optimization)</a> Dans une optique de simplification, la classe n&rsquo;accepte que des références et garde un pointeur. On peut la considérer comme une vue polymorphique.</p>
<p>Une petite démonstration de la chose:</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">Drawable</span> <span class="n">drawable</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">drawable</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Rect</span> <span class="n">rect</span><span class="p">;</span>
  <span class="n">Circle</span> <span class="n">circle</span><span class="p">;</span>

  <span class="n">draw</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">);</span> <span class="c1">// affiche Rect
</span><span class="c1"></span>  <span class="n">draw</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">);</span> <span class="c1">// affiche Circle
</span><span class="c1"></span><span class="p">}</span></code></pre></div>

<p>C&rsquo;est tout :).</p>
<p>Il est possible de rendre plus simple la déclaration de la classe <code>Drawable</code> avec des macros pour supprimer 2/3 du code, mais je passe mon tour.</p>
<p>Par contre, il y a peut-être moyen d&rsquo;avoir mieux pour la vtable.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/11/simuler-une-vtable-sans-fonction-virtuelle/#une-vtable-par-type-vs-une-vtable-par-instance"><h2 id="une-vtable-par-type-vs-une-vtable-par-instance">Une vtable par type vs une vtable par instance</h2></a>
<p>Notre <code>Drawable</code> contient une référence sur la vtable qui est elle-même un tableau de 1 pointeur de fonction. Autant jeter la vtable et avoir directement le pointeur de fonction comme membre. C&rsquo;est plus direct et le code est plus court.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">Drawable</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">Drawable</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">obj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">draw_func</span><span class="p">(</span><span class="n">draw_func_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="n">draw_func</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">obj</span><span class="p">;</span>
  <span class="n">draw_func_type</span><span class="o">*</span> <span class="n">draw_func</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>Pour une classe qui ne possède qu&rsquo;une fonction polymorphique, le pointeur de fonction en membre est un peu plus efficace qu&rsquo;une vtable en évitant une indirection. <code>std::function</code> utilise le même principe en interne en plus de prendre l&rsquo;ownership de l&rsquo;objet. Prendre l&rsquo;ownership implique de mettre l&rsquo;objet en membre, si l&rsquo;objet prend trop de place, comme une lambda avec une grosse capture, alors elle déborde du tampon interne et une allocation dynamique est généralement effectuée. Pour un comportement plus proche des exemples ci-dessus qui prennent une référence sur les données, il existe <a href="https://github.com/Naios/function2#small-functor-optimization">fn2::function_view</a>.</p>
<p>Par contre, pour chaque fonction polymorphique, la classe doit contenir un pointeur de fonction ce qui augmente sa taille. Si cet objet est mis dans un vector, alors il y aura beaucoup de pointeurs similaires entre les valeurs et une vtable peut réduire drastiquement la mémoire allouée par le vecteur.</p>
<p>Il y a un dernier point qui n&rsquo;est pas visible avec les exemples du dessus : le comportement peut être dynamiquement modifié. C&rsquo;est-à-dire qu&rsquo;une instance peut décider de modifier le comportement d&rsquo;une de ses fonctions en la remplaçant (taper dans <code>draw_func</code>) sans avoir de variable d&rsquo;état. La fonction en cours d&rsquo;exécution représentant l&rsquo;état courant. C&rsquo;est un aspect de la <a href="https://fr.wikipedia.org/wiki/Programmation_orient%C3%A9e_prototype">programmation orientée prototype</a>.</p>
<p>Bien sûr, avec une vtable, modifier un des pointeurs impacte tous les objets y faisant référence.</p>
<p>Après, rien n&rsquo;empêche d&rsquo;avoir un comportement hybride, une vtable pour les fonctions communes, peu utilisées ou &ldquo;lentes&rdquo;, et un membre pour les fonctions polymorphiques qui doivent etre &ldquo;rapides&rdquo; d&rsquo;accès ou qui changent en court de route. Des projets tels <a href="https://github.com/ldionne/dyno">dyno</a> permettent cela.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/11/simuler-une-vtable-sans-fonction-virtuelle/#la-méthode-du-gros-switch"><h2 id="la-méthode-du-gros-switch">La méthode du gros switch</h2></a>
<p>C&rsquo;est une méthode très bourrin et pas très adapté au C++. Elle consiste à connaître l&rsquo;ensemble des types utilisés pour une interface et de les associer à la fonction. Plus de vtable, plus d&rsquo;indirection, mais à la place un saut à base de switch. Le compilateur pourrait plus facilement inliner le code, mais on perd la posibilité de charger dynamiquement des bibliothèques.</p>
<p>Le problème, c&rsquo;est qu&rsquo;il faut centraliser manuellement toutes les instances au même endroit pour faire notre table de saut, car il n&rsquo;existe aucun moyen de récupérer &ndash; par exemple &ndash; toutes les instances d&rsquo;un trait <code>is_drawable</code>. Si le compilateur ne nous aide pas, cette solution n&rsquo;est pas facile à maintenir. On peut néanmoins passer par un générateur de source qui sélectionnerait à la manière d&rsquo;un <code>clang-query</code> tous les types pour générer complètement le corps de la fonction <code>Drawable::draw</code>.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2018-11-01T20:42:09">01 novembre 2018
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  

  <br/><a href="https://jonathanpoelen.github.io/2018/11/simuler-une-vtable-sans-fonction-virtuelle/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="442b3694da91a9866c991b248ee3f410-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=simuler-une-vtable-sans-fonction-virtuelle&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fsimuler-une-vtable-sans-fonction-virtuelle%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fsimuler-une-vtable-sans-fonction-virtuelle%2f&amp;title=simuler-une-vtable-sans-fonction-virtuelle" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fsimuler-une-vtable-sans-fonction-virtuelle%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fsimuler-une-vtable-sans-fonction-virtuelle%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fsimuler-une-vtable-sans-fonction-virtuelle%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f11%2fsimuler-une-vtable-sans-fonction-virtuelle%2f&amp;name=simuler-une-vtable-sans-fonction-virtuelle" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="comparaison-de-diff%C3%A9rentes-impl%C3%A9mentations-de-mp_index_of"><span>
        <a href="#simuler-une-vtable-sans-fonction-virtuelle"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Simuler une vtable sans fonction virtuelle"></i></a>
        <a href="#au-c%25C5%2593ur-dun-variant"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Au cœur d&#39;un variant"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/">Comparaison de différentes implémentations de mp_index_of</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#simuler-une-vtable-sans-fonction-virtuelle">Article suivant: Simuler une vtable sans fonction virtuelle</a><br/>
        <a href="#au-c%25C5%2593ur-dun-variant">Article précédent: Au cœur d&#39;un variant</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2018-10-01T18:28:21">01 octobre 2018
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>19 minutes ;
  <a href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#acfe95c97195256c7843e5c852ec2097-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
  

</p>


  </header>
  <div class="post__content">
      <p>Dans l&rsquo;article précédent sur les variants, j&rsquo;ai fait une implémentation un peu spéciale de <code>index_of</code>. Je vais présenter une quinzaine d&rsquo;implémentations possibles et le coût de chacune sur le compilateur.</p>

<div class="InfoBox"><p><strong class="InfoBox-title">Info :</strong> L&rsquo;implémentation citée précédemment ne se retrouve pas ici car une forme récursive plus &ldquo;classique&rdquo; a les mêmes conséquences.</p></div>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/#avant-propos"><h2 id="avant-propos">Avant-propos</h2></a>
<p>Toutes les implémentations de <code>mp_index_of&lt;T, Ts...&gt;</code> retournent un <code>std::integral_constant&lt;int, i&gt;</code> correspondant à l&rsquo;indice de <code>T</code> dans <code>Ts</code> ou <code>-1</code> si <code>T</code> n&rsquo;existe pas.</p>
<p>Clang possède des outils tel que <a href="http://plc.inf.elte.hu/templight/">templight</a>, mais il n&rsquo;y a pas d&rsquo;équivalent pour Gcc. Par conséquent, les tests sont faits avec <code>/usr/bin/time --format=&quot;%E %M&quot;</code> qui ressort le temps et la mémoire maximum utilisée par un programme.</p>
<p>Au niveau des options de compilation, <code>-fsyntax-only</code> permet de vérifier la validité d&rsquo;un code sans générer de fichier de sortie. <code>-std=c++17</code> est présent pour utiliser les plies, mais tous les algorithmes n&rsquo;en ont pas besoin. <code>-ftemplate-depth=n</code> et <code>-fconstexpr-depth=n</code> appliquent une profondeur limite dans la récursivité appliquée respectivement aux templates et aux fonctions constexpr. <code>-w</code> supprime tous les avertissements (tels que des macros non utilisés) pour éviter que des sorties inopportunes influencent la mesure.</p>
<p>Il y a 2 formes de test:</p>
<ul>
<li>ceux sur des listes contenant 2 types nommés <code>x</code> et <code>_</code> et</li>
<li>ceux sur des suites <code>x</code> et <code>i&lt;n&gt;</code> avec <code>n</code> un entier.</li>
</ul>
<p>Pour chaque test, <code>T</code> représente <code>x</code> et il peut être présent ou non dans <code>Ts</code>.</p>
<p>les valeurs de <code>Ts</code> sont présentées dans les légendes sous forme abrégée:</p>
<ul>
<li><code>[x*500]</code>: une liste de 500 <code>x</code>.</li>
<li><code>[_*250, x, _*249]</code>: une liste de 250 <code>_</code>, suivit de <code>x</code> et d&rsquo;une liste de <code>249</code> <code>_</code>.</li>
<li><code>[i{0..40}*150]</code>: une suite de 150 <code>i0</code>, une autre de 150 <code>i1</code> et ainsi de suite jusqu&rsquo;à <code>i40</code>.</li>
<li><code>[i0..i{0..140}]</code>: une suite <code>[i0..i0]</code>, puis <code>[i0..i1]</code>, etc jusqu&rsquo;à <code>[i0..i140]</code>.</li>
<li><code>[i{0..n},x,i{n-(n..0)..n}];n=100</code>: les suites <code>[i{0..100},x,i{100..100}]</code>,  <code>[i{1..100},x,i{99..100}]</code>, etc</li>
</ul>
<p>Les sources se trouvent sur <a href="https://github.com/jonathanpoelen/jonathanpoelen.github.io/tree/source/resources/mp_index_of">github</a>
 dans un même fichier cpp. Chacune des implémentations possède son propre namespace et des macros activent individuellement chaque test. <!-- raw HTML omitted --></p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/#relation-temps-de-compilation-et-mémoire"><h2 id="relation-temps-de-compilation-et-mémoire">Relation temps de compilation et mémoire</h2></a>
<p>Dans du code utilisant la méta-programmation, le temps de compilation suit la même courbe que la mémoire. Plus une compilation est lente, plus la mémoire utilisée augmente allant jusqu&rsquo;à saturation.</p>
<p>Et la mémoire est fortement liée au nombre de types instanciés par le compilateur. Ici, il ne faut pas voir une instance comme une variable, mais comme la première création d&rsquo;un type. Par exemple, <code>index_of&lt;int, int&gt;</code> est une instance de type (ou d&rsquo;alias), <code>index_of&lt;int, int, int&gt;</code> une seconde instance, <code>index_of&lt;int, float&gt;</code> une troisième, etc. Chaque type construit s&rsquo;ajoute dans la mémoire du compilateur et l&rsquo;ensemble utilise de plus en plus de place. C&rsquo;est ainsi que le compilateur implémente naturellement la <a href="https://fr.wikipedia.org/wiki/M%C3%A9mo%C3%AFsation">mémoïsation</a> pour les templates.</p>
<p>Pour réduire le temps de compilation, il faut donc réduire le nombre de type instancié.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/#la-récursivité"><h2 id="la-récursivité">La récursivité</h2></a>
<p>La première chose qu&rsquo;on apprend avec les variadiques, c&rsquo;est que les boucles se font avec de la récursivité en enlevant un par un les éléments. C&rsquo;est une forme facile à écrire et à comprendre, mais qui crée beaucoup de types intermédiaires à l&rsquo;intérieur du compilateur.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">recursive_ternary</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">First</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">First</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">First</span><span class="o">&gt;</span>
    <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">_index_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span>
  <span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Ts</span><span class="p">))</span>
    <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Une implémentation avec ternaire récursive comme on peut la trouver dans le fichier variant de libstdc++. Elle souffre d&rsquo;un léger problème: il y a autant d&rsquo;instance de <code>_index_of</code> que d&rsquo;élément dans la liste, même si <code>T</code> se trouve en première position.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">recursive_indexed</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">First</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">First</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">_index_of</span><span class="o">&lt;</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">i</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>L&rsquo;indice courant se trouve en paramètre template et la récursion s&rsquo;arrête dès que <code>T</code> est trouvé. Seulement, l&rsquo;ajout de l&rsquo;indice en paramètre va dégrader la mémoïsation en créant plus de types que nécessaire.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">recursive</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">First</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">First</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span>
  <span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Ts</span><span class="p">))</span>
    <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Un mélange des 2 implémentations précédentes sans les inconvénients. En réalité, c&rsquo;est la forme la plus communément écrite.</p>
<!-- raw HTML omitted -->
<p><img src="/post/mp_index_of/rec_gcc_time.png" alt="duré de compilation avec gcc de 3 implémentations récursives"></p>
<p>Sans surprise, sur les 3 premiers tests, la version avec ternaire est à peu près stable quelle que soit la position de <code>x</code>, même s&rsquo;il semble qu&rsquo;évaluer la ternaire ralentisse un peu la compilation lorsque <code>x</code> se situe vers la fin.
Alors que les 2 autres implémentations sont beaucoup plus rapides lorsque <code>x</code> est au début pour rattraper progressivement la version ternaire. Sans que je sache l&rsquo;expliquer, la version avec index explose le compteur pour le test 3.</p>
<p>Comme la courbe de progression pour la version récursive classique n&rsquo;est pas linéaire, je déduis que le nombre d&rsquo;éléments dans un pack d&rsquo;argument influence le temps de compilation. Il y a ±600ms de différence pour parcourir les 700 premiers <code>_</code> contre seulement ±220ms pour les 700 restant. Cela peut se comprendre assez facilement, plus il y a de types dans la template, plus la création d&rsquo;un identifiant au sein du compilateur va prendre du temps.</p>
<p>Le test 5 met clairement à défaut la version avec indice, car la mémoïsation ne s&rsquo;applique pas ici. Avec la version ternaire et récursive, lorsque le compilateur calcule la position d&rsquo;une liste de la forme <code>[0,1,2,3]</code>, il l&rsquo;a aussi fait pour <code>[1,2,3]</code>, <code>[2,3]</code> et <code>[3]</code> ce qui permet d&rsquo;être très rapide lorsqu&rsquo;il tombe sur des valeurs déjà évaluées. Or, la version avec indice ajoute un élément qui empêche cela: <code>&lt;0, [0,1,2,3]&gt;</code> se déroule en <code>&lt;1, [1,2,3]&gt;</code>, <code>&lt;2, [2,3]&gt;</code> et <code>&lt;3, [3]&gt;</code> alors que <code>&lt;0, [0,1,2]&gt;</code> se déroule en <code>&lt;1, [1,2]&gt;</code> et <code>&lt;2, [2]&gt;</code>. Les suites sont différentes, le compilateur crée donc beaucoup plus de types intermédiaires ce qui ralentit la compilation.</p>
<p>Dans l&rsquo;ensemble, l&rsquo;algorithme avec index est à éviter, car il montre qu&rsquo;une mauvaise mémoïsation ralentit fortement l&rsquo;évaluation de template. Il faut également éviter la version ternaire au profil d&rsquo;une implémentation qui stoppe la récursivité pour ne pas faire de calcul inutile. Finalement, l&rsquo;algorithme de récursion classique est plus rapide dans tous les cas.</p>
<p>Ce qui est vrai pour Gcc, ne l&rsquo;est pas forcément pour Clang comme le montre le graphique ci-dessous.</p>
<!-- raw HTML omitted -->
<p><img src="/post/mp_index_of/rec_clang_time.png" alt="duré de compilation avec clang de 3 implémentations récursives"></p>
<p>Premier constat, le test 3 n&rsquo;a pas de pic inexplicable pour l&rsquo;algorithme avec indice. Et, bien que la version récursive classique soit toujours plus rapide que celle avec ternaire, il est amusant de constater que l&rsquo;implémentation avec indice supplante de peu la version classique. Sauf bien sûr lorsque la mémoïsation est mise à défaut comme dans le test 5.</p>
<p>Si on compare le temps de compilation entre Clang et Gcc, il s&rsquo;avère que Gcc est un peu plus rapide que son concurrent alors même que les premiers tests se font sur une liste de 1200 éléments contre 1400. De mon expérience, c&rsquo;est presque toujours le cas avec des templates récursives sur de &ldquo;grands&rdquo; ensembles.</p>

<div class="InfoBox"><p><strong class="InfoBox-title">Info :</strong> La limite de 1200 est dûe à une limitation de Clang qui ne peut pas dépasser 1293 niveaux de profondeur sans crasher (en tout cas chez moi probablement à cause d&rsquo;un dépassement de pile).</p></div>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/#profiter-davantage-de-mémoïsation"><h2 id="profiter-davantage-de-mémoïsation">Profiter davantage de mémoïsation</h2></a>
<p>Il est possible d&rsquo;augmenter la mémoïsation en réduisant les types dans la liste en une suite de valeur <code>true</code>/<code>false</code>. La mémoïsation est alors beaucoup plus efficace, mais la comparaison se fait sur chaque élément de la liste. Heureusement, dans un code normal, la probabilité de tomber sur la même instance de <code>std::is_same&lt;T, U&gt;</code> est très grande ce qui rend cette solution encore plus efficace.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">recursive_bool</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">recursive</span><span class="o">::</span><span class="n">mp_index_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>L&rsquo;utilisation de <code>typename std::is_same&lt;T, Ts&gt;::type</code> au lieu de simplement <code>std::is_same&lt;T, Ts&gt;</code> permet de restreindre les types à <code>std::false_type</code> et <code>std::true_type</code>.</p>
<p>On peut aussi faire la comparaison avec un <code>detail::_index_of</code> spécialement dédié à la recherche d&rsquo;un <code>std::true_type</code>.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">recursive_bool2</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">, </span><span class="nc">class</span><span class="p">...</span> <span class="n">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">Rest</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span>
  <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span>
  <span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">...,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Ts</span><span class="p">))</span>
    <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">...,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Et une autre version qui travaille sur des valeurs plutôt que des types pour vérifier si cela a une influence.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">recursive_bool3</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">...</span> <span class="n">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">Rest</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span>
  <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">...</span> <span class="n">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span>
  <span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">...,</span> <span class="nb">true</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Ts</span><span class="p">))</span>
    <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">...,</span> <span class="nb">true</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<!-- raw HTML omitted -->
<p><img src="/post/mp_index_of/rec_bool_gcc_time.png" alt="comparaison de temps de 3 implémentations qui font une transformation en booléan"></p>
<p>Là où la version récursive était rapide, la transformation en une liste de booléan l&rsquo;est tout autant. Le bénéfice devient évident sur une grande variété de listes (test 4) et des listes homogènes (test 6) où le temps de compilation est divisé par 3.</p>
<p>L&rsquo;algorithme <code>recursive_bool2</code> spécialisé dans la recherche d&rsquo;un <code>std::true_type</code> permet de grappiller encore quelques millisecondes principalement grâce à une spécialisation de template en moins.</p>
<p>À contrario, la version 3 qui manipule des booléens plutôt que des types est lente. Manipuler des types serait donc plus rapide que manipuler des valeurs dans les spécialisations. Le même comportement est présent dans Clang, même s&rsquo;il est moins prononcé.</p>
<!-- raw HTML omitted -->
<p><img src="/post/mp_index_of/rec_bool_clang_time.png" alt="comparaison de temps de 3 implémentations qui font une transformation en booléan"></p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/#récursivité-par-bloc"><h2 id="récursivité-par-bloc">Récursivité par bloc</h2></a>
<p>La récursivité possède un défaut qui n&rsquo;est pas forcément un problème dans le code de tous les jours: le niveau de récursion est limité par le compilateur. Gcc s&rsquo;arrête à une profondeur de 900, Clang à 1024 et si je ne me trompe pas, la limite est de 500 pour MSVC. Bien sûr, cela est configurable. C&rsquo;est d&rsquo;ailleurs ce qui a été fait pour générer les premiers graphiques même si comme dit précédemment, Clang crashe lorsqu&rsquo;on dépasse 1293.</p>
<p>Une technique employée pour dépasser artificiellement cette limite est de prendre plusieurs valeurs par niveau de récursivité. Cela réduit la profondeur de récursion et le nombre de types instanciés. S&rsquo;il y a moins de types instanciés, la compilation devrait également être plus rapide.</p>
<p>Le code devient malheureusement beaucoup plus verbeux et compliqué:</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">pack8</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">Ok</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span>
           <span class="k">class</span> <span class="nc">U0</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U1</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U2</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U3</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U4</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U5</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U6</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U7</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U0</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
                                 <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U1</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span>
                                 <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U2</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span>
                                 <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U3</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span>
                                 <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U4</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span>
                                 <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U5</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">5</span> <span class="o">:</span>
                                 <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U6</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">6</span> <span class="o">:</span>
                                 <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U7</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">8</span><span class="p">)</span>
    <span class="o">+</span> <span class="n">_index_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U0</span><span class="o">&gt;</span> <span class="o">||</span>
                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U1</span><span class="o">&gt;</span> <span class="o">||</span>
                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U2</span><span class="o">&gt;</span> <span class="o">||</span>
                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U3</span><span class="o">&gt;</span> <span class="o">||</span>
                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U4</span><span class="o">&gt;</span> <span class="o">||</span>
                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U5</span><span class="o">&gt;</span> <span class="o">||</span>
                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U6</span><span class="o">&gt;</span> <span class="o">||</span>
                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U7</span><span class="o">&gt;</span>
    <span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U0</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U3</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U4</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U5</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U6</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U7</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">U0</span><span class="p">,</span> <span class="n">U1</span><span class="p">,</span> <span class="n">U2</span><span class="p">,</span> <span class="n">U3</span><span class="p">,</span> <span class="n">U4</span><span class="p">,</span> <span class="n">U5</span><span class="p">,</span> <span class="n">U6</span><span class="p">,</span> <span class="n">U7</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U0</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U3</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U4</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U5</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U6</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U7</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">U0</span><span class="p">,</span> <span class="n">U1</span><span class="p">,</span> <span class="n">U2</span><span class="p">,</span> <span class="n">U3</span><span class="p">,</span> <span class="n">U4</span><span class="p">,</span> <span class="n">U5</span><span class="p">,</span> <span class="n">U6</span><span class="p">,</span> <span class="n">U7</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U0</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U1</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U2</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U3</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U4</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U5</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">5</span> <span class="o">:</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U6</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">6</span> <span class="o">:</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U7</span><span class="o">&gt;</span> <span class="o">?</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span>
  <span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Ts</span><span class="p">))</span>
    <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Et L&rsquo;équivalent qui fait une transformation en liste de booléen avant:</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">pack8_bool</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">Ok</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">;</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span>
           <span class="k">class</span> <span class="nc">U0</span> <span class="o">=</span> <span class="n">Ok</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U1</span> <span class="o">=</span> <span class="n">Ok</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U2</span> <span class="o">=</span> <span class="n">Ok</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U3</span> <span class="o">=</span> <span class="n">Ok</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U4</span> <span class="o">=</span> <span class="n">Ok</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U5</span> <span class="o">=</span> <span class="n">Ok</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U6</span> <span class="o">=</span> <span class="n">Ok</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U7</span> <span class="o">=</span> <span class="n">Ok</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="p">(</span><span class="n">U0</span><span class="o">::</span><span class="n">value</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
                                 <span class="n">U1</span><span class="o">::</span><span class="n">value</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span>
                                 <span class="n">U2</span><span class="o">::</span><span class="n">value</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span>
                                 <span class="n">U3</span><span class="o">::</span><span class="n">value</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span>
                                 <span class="n">U4</span><span class="o">::</span><span class="n">value</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span>
                                 <span class="n">U5</span><span class="o">::</span><span class="n">value</span> <span class="o">?</span> <span class="mi">5</span> <span class="o">:</span>
                                 <span class="n">U6</span><span class="o">::</span><span class="n">value</span> <span class="o">?</span> <span class="mi">6</span> <span class="o">:</span>
                                 <span class="n">U7</span><span class="o">::</span><span class="n">value</span> <span class="o">?</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">8</span><span class="p">)</span>
    <span class="o">+</span> <span class="n">_index_of</span><span class="o">&lt;</span><span class="n">U0</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
                <span class="n">U1</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
                <span class="n">U2</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
                <span class="n">U3</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
                <span class="n">U4</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
                <span class="n">U5</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
                <span class="n">U6</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
                <span class="n">U7</span><span class="o">::</span><span class="n">value</span>
    <span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">U0</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U3</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U4</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U5</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U6</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U7</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_index_of</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span> <span class="n">U0</span><span class="p">,</span> <span class="n">U1</span><span class="p">,</span> <span class="n">U2</span><span class="p">,</span> <span class="n">U3</span><span class="p">,</span> <span class="n">U4</span><span class="p">,</span> <span class="n">U5</span><span class="p">,</span> <span class="n">U6</span><span class="p">,</span> <span class="n">U7</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span>
  <span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Ts</span><span class="p">))</span>
    <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<!-- raw HTML omitted -->
<p><img src="/post/mp_index_of/pack8_gcc_time.png" alt="duré de compilation avec gcc pour un algo récursive par pack de 8"></p>
<p>Même lorsque la position de <code>x</code> est éloignée (test 2 et 3), les <code>pack8</code> sont efficaces. Si on prend la différence entre le test 1 et 2, et 2 et 3, il y a plus ou moins un facteur 8.</p>
<p>Comme c&rsquo;était le cas lorsqu&rsquo;on comparaît l&rsquo;algorithme <code>recursive</code> avec <code>recursive_bool</code>, <code>pack8_bool</code> est plus rapide que <code>pack8</code> lorsque le nombre de listes différentes augmente (test 5 et 7).</p>
<p>Le test 6 profite déjà d&rsquo;une mémoïsation optimale pour les 3 implémentations, même si <code>pack8_bool</code> est un chouia plus lent que les autres ici.</p>
<p>Toutefois, la suprématie de <code>pack8_bool</code> par rapport à <code>pack8</code> est beaucoup plus ténue avec Clang.</p>
<!-- raw HTML omitted -->
<p><img src="/post/mp_index_of/pack8_clang_time.png" alt="duré de compilation avec gcc pour un algo récursive par pack de 8"></p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/#penser-différemment"><h2 id="penser-différemment">Penser différemment</h2></a>
<p>Plutôt qu&rsquo;avoir un <code>index_of</code> le plus rapide possible, il est possible de combiner d&rsquo;autres algorithmes pour arriver au même résultat. Il y a un double avantage dans le cadre d&rsquo;une bibliothèque de méta-programmation:</p>
<ul>
<li>Implémenter un nouvel algorithme efficace est plus facile, car les optimisations telles que celles utilisées par <code>pack8</code> sont déportées sur ceux avec une réelle implémentation.</li>
<li>Un nombre restreint d&rsquo;algorithmes est plus souvent utilisé ce qui augmente la mémoïsation.</li>
</ul>
<p>Ainsi, <code>index_of</code> peut se faire en combinant <code>std::make_index_sequence</code>, <code>join</code>, <code>front</code> et éventuellement <code>tranform</code>. On peut aussi le faire avec <code>foldl</code>/<code>foldr</code>.</p>
<p>Pour le faire avec <code>join</code>, on construit une liste d&rsquo;indices de la taille de <code>Ts</code> qui est ensuite transformée en <code>list&lt;i&gt;</code> lorsque le type est identique à <code>T</code> et en <code>list&lt;&gt;</code> dans le cas contraire. Puis, on fusionne toutes les listes en une seule avec un <code>int&lt;-1&gt;</code> ajouté en fin. Le premier élément de cette liste correspond au résultat de <code>index_of</code>.</p>
<p>Il serait préférable de ne pas ajouter <code>-1</code>, mais ajouter une valeur dans la liste puis faire un post traitement. Cela augmente les collisions de type et par conséquent la mémoïsation. Mais restons simple !</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">by_indices</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">...</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">list</span><span class="p">;</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">L</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">front</span><span class="p">;</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">front</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span>
           <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span>
           <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span>
           <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span>
           <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span>
           <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span>
           <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span>
           <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="err">= </span><span class="nc">list</span><span class="o">&lt;&gt;</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">Ls</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_join</span><span class="p">;</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">_0</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_1</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_2</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_3</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_4</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_5</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_6</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_7</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_8</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_9</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_10</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_11</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_12</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_13</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_14</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_15</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_16</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_17</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_18</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_19</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_20</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_21</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_22</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_23</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_24</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_25</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_26</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_27</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_28</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_29</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_30</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_31</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_32</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_33</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_34</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_35</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_36</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_37</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_38</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_39</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_40</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_41</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_42</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_43</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_44</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_45</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_46</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_47</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_48</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_49</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_50</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_51</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_52</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_53</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_54</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_55</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_56</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_57</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_58</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_59</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_60</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_61</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_62</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_63</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_join</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="n">_0</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_1</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_2</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_3</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_4</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_5</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_6</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_7</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_8</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_9</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_10</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_11</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_12</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_13</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_14</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_15</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_16</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_17</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_18</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_19</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_20</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_21</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_22</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_23</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_24</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_25</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_26</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_27</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_28</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_29</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_30</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_31</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_32</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_33</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_34</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_35</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_36</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_37</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_38</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_39</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_40</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_41</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_42</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_43</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_44</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_45</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_46</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_47</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_48</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_49</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_50</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_51</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_52</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_53</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_54</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_55</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_56</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_57</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_58</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_59</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_60</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_61</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_62</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_63</span><span class="p">...</span><span class="o">&gt;&gt;</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_0</span><span class="p">...,</span> <span class="n">_1</span><span class="p">...,</span> <span class="n">_2</span><span class="p">...,</span> <span class="n">_3</span><span class="p">...,</span> <span class="n">_4</span><span class="p">...,</span> <span class="n">_5</span><span class="p">...,</span> <span class="n">_6</span><span class="p">...,</span> <span class="n">_7</span><span class="p">...,</span>
                      <span class="n">_8</span><span class="p">...,</span> <span class="n">_9</span><span class="p">...,</span> <span class="n">_10</span><span class="p">...,</span> <span class="n">_11</span><span class="p">...,</span> <span class="n">_12</span><span class="p">...,</span> <span class="n">_13</span><span class="p">...,</span> <span class="n">_14</span><span class="p">...,</span> <span class="n">_15</span><span class="p">...,</span>
                      <span class="n">_16</span><span class="p">...,</span> <span class="n">_17</span><span class="p">...,</span> <span class="n">_18</span><span class="p">...,</span> <span class="n">_19</span><span class="p">...,</span> <span class="n">_20</span><span class="p">...,</span> <span class="n">_21</span><span class="p">...,</span> <span class="n">_22</span><span class="p">...,</span> <span class="n">_23</span><span class="p">...,</span>
                      <span class="n">_24</span><span class="p">...,</span> <span class="n">_25</span><span class="p">...,</span> <span class="n">_26</span><span class="p">...,</span> <span class="n">_27</span><span class="p">...,</span> <span class="n">_28</span><span class="p">...,</span> <span class="n">_29</span><span class="p">...,</span> <span class="n">_30</span><span class="p">...,</span> <span class="n">_31</span><span class="p">...,</span>
                      <span class="n">_32</span><span class="p">...,</span> <span class="n">_33</span><span class="p">...,</span> <span class="n">_34</span><span class="p">...,</span> <span class="n">_35</span><span class="p">...,</span> <span class="n">_36</span><span class="p">...,</span> <span class="n">_37</span><span class="p">...,</span> <span class="n">_38</span><span class="p">...,</span> <span class="n">_39</span><span class="p">...,</span>
                      <span class="n">_40</span><span class="p">...,</span> <span class="n">_41</span><span class="p">...,</span> <span class="n">_42</span><span class="p">...,</span> <span class="n">_43</span><span class="p">...,</span> <span class="n">_44</span><span class="p">...,</span> <span class="n">_45</span><span class="p">...,</span> <span class="n">_46</span><span class="p">...,</span> <span class="n">_47</span><span class="p">...,</span>
                      <span class="n">_48</span><span class="p">...,</span> <span class="n">_49</span><span class="p">...,</span> <span class="n">_50</span><span class="p">...,</span> <span class="n">_51</span><span class="p">...,</span> <span class="n">_52</span><span class="p">...,</span> <span class="n">_53</span><span class="p">...,</span> <span class="n">_54</span><span class="p">...,</span> <span class="n">_55</span><span class="p">...,</span>
                      <span class="n">_56</span><span class="p">...,</span> <span class="n">_57</span><span class="p">...,</span> <span class="n">_58</span><span class="p">...,</span> <span class="n">_59</span><span class="p">...,</span> <span class="n">_60</span><span class="p">...,</span> <span class="n">_61</span><span class="p">...,</span> <span class="n">_62</span><span class="p">...,</span> <span class="n">_63</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">_0</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_1</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_2</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_3</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_4</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_5</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_6</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_7</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_8</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_9</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_10</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_11</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_12</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_13</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_14</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_15</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_16</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_17</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_18</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_19</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_20</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_21</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_22</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_23</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_24</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_25</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_26</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_27</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_28</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_29</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_30</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_31</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_32</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_33</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_34</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_35</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_36</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_37</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_38</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_39</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_40</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_41</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_42</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_43</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_44</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_45</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_46</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_47</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_48</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_49</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_50</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_51</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_52</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_53</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_54</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_55</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">_56</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_57</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_58</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_59</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_60</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_61</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_62</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_63</span><span class="p">,</span>
           <span class="k">class</span><span class="err">... </span><span class="nc">Ls</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_join</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="n">_0</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_1</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_2</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_3</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_4</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_5</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_6</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_7</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_8</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_9</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_10</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_11</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_12</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_13</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_14</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_15</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_16</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_17</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_18</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_19</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_20</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_21</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_22</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_23</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_24</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_25</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_26</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_27</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_28</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_29</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_30</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_31</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_32</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_33</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_34</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_35</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_36</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_37</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_38</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_39</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_40</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_41</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_42</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_43</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_44</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_45</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_46</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_47</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_48</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_49</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_50</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_51</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_52</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_53</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_54</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_55</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">list</span><span class="o">&lt;</span><span class="n">_56</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_57</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_58</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_59</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_60</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_61</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_62</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">_63</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">Ls</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">_join</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="n">_0</span><span class="p">...,</span> <span class="n">_1</span><span class="p">...,</span> <span class="n">_2</span><span class="p">...,</span> <span class="n">_3</span><span class="p">...,</span> <span class="n">_4</span><span class="p">...,</span> <span class="n">_5</span><span class="p">...,</span> <span class="n">_6</span><span class="p">...,</span> <span class="n">_7</span><span class="p">...,</span>
               <span class="n">_8</span><span class="p">...,</span> <span class="n">_9</span><span class="p">...,</span> <span class="n">_10</span><span class="p">...,</span> <span class="n">_11</span><span class="p">...,</span> <span class="n">_12</span><span class="p">...,</span> <span class="n">_13</span><span class="p">...,</span> <span class="n">_14</span><span class="p">...,</span> <span class="n">_15</span><span class="p">...,</span>
               <span class="n">_16</span><span class="p">...,</span> <span class="n">_17</span><span class="p">...,</span> <span class="n">_18</span><span class="p">...,</span> <span class="n">_19</span><span class="p">...,</span> <span class="n">_20</span><span class="p">...,</span> <span class="n">_21</span><span class="p">...,</span> <span class="n">_22</span><span class="p">...,</span> <span class="n">_23</span><span class="p">...,</span>
               <span class="n">_24</span><span class="p">...,</span> <span class="n">_25</span><span class="p">...,</span> <span class="n">_26</span><span class="p">...,</span> <span class="n">_27</span><span class="p">...,</span> <span class="n">_28</span><span class="p">...,</span> <span class="n">_29</span><span class="p">...,</span> <span class="n">_30</span><span class="p">...,</span> <span class="n">_31</span><span class="p">...,</span>
               <span class="n">_32</span><span class="p">...,</span> <span class="n">_33</span><span class="p">...,</span> <span class="n">_34</span><span class="p">...,</span> <span class="n">_35</span><span class="p">...,</span> <span class="n">_36</span><span class="p">...,</span> <span class="n">_37</span><span class="p">...,</span> <span class="n">_38</span><span class="p">...,</span> <span class="n">_39</span><span class="p">...,</span>
               <span class="n">_40</span><span class="p">...,</span> <span class="n">_41</span><span class="p">...,</span> <span class="n">_42</span><span class="p">...,</span> <span class="n">_43</span><span class="p">...,</span> <span class="n">_44</span><span class="p">...,</span> <span class="n">_45</span><span class="p">...,</span> <span class="n">_46</span><span class="p">...,</span> <span class="n">_47</span><span class="p">...,</span>
               <span class="n">_48</span><span class="p">...,</span> <span class="n">_49</span><span class="p">...,</span> <span class="n">_50</span><span class="p">...,</span> <span class="n">_51</span><span class="p">...,</span> <span class="n">_52</span><span class="p">...,</span> <span class="n">_53</span><span class="p">...,</span> <span class="n">_54</span><span class="p">...,</span> <span class="n">_55</span><span class="p">...,</span>
               <span class="n">_56</span><span class="p">...,</span> <span class="n">_57</span><span class="p">...,</span> <span class="n">_58</span><span class="p">...,</span> <span class="n">_59</span><span class="p">...,</span> <span class="n">_60</span><span class="p">...,</span> <span class="n">_61</span><span class="p">...,</span> <span class="n">_62</span><span class="p">...,</span> <span class="n">_63</span><span class="p">...</span>
          <span class="o">&gt;</span><span class="p">,</span> <span class="n">Ls</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ints</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_find_index</span><span class="p">;</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">if_</span>
  <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">U</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;&gt;</span>
  <span class="k">struct</span> <span class="nc">if_</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">...</span> <span class="n">Ints</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Is</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">_find_index</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">integer_sequence</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span> <span class="n">Ints</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Is</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">front</span><span class="o">&lt;</span>
      <span class="k">typename</span> <span class="n">_join</span><span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">if_</span><span class="o">&lt;</span><span class="n">Is</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">type</span><span class="o">&lt;</span>
          <span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">Ints</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
          <span class="n">list</span><span class="o">&lt;&gt;</span>
        <span class="o">&gt;</span><span class="p">...,</span>
        <span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">&gt;&gt;</span>
      <span class="o">&gt;::</span><span class="n">type</span>
    <span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">_find_index</span><span class="o">&lt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Ts</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Wooa, cette monstruosité. Il faut être complètement barge pour écrire cette horreur. C&rsquo;est pourtant une chose que l&rsquo;on trouve dans <a href="https://github.com/brunocodutra/metal/blob/master/include/metal/list/join.hpp#L51">Metal</a>, <a href="https://github.com/edouarda/brigand/blob/master/include/brigand/sequences/append.hpp#L29">Brigand</a>, <a href="https://github.com/boostorg/mp11/blob/develop/include/boost/mp11/detail/mp_append.hpp#L48">Cpp11</a> ou <a href="https://github.com/boostorg/hana/blob/master/include/boost/hana/detail/variadic/foldl1.hpp#L23">Boost.Hana</a>. La palme d&rsquo;or revient à <a href="https://github.com/kvasir-io/mpl/blob/development/src/kvasir/mpl/sequence/join.hpp#L14">Kvasir.Mpl</a> avec une template de 1025 éléments variadiques.</p>
<!-- raw HTML omitted -->
<p><img src="/post/mp_index_of/by_indices_time.png" alt="comparaison de temps avec gcc de pack8 et une qui utilise d&rsquo;autres algorithmes"></p>
<p>C&rsquo;est étonnamment efficace. Pas autant que <code>pack8_bool</code>, mais globalement plus qu&rsquo;une récursion classique. Dans un projet, <code>join</code> et <code>front</code> seront utilisés ailleurs et à travers d&rsquo;autres algorithmes ce qui, toujours grâce à la mémoïsation, réduit le coût total.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/#fonction-constexpr"><h2 id="fonction-constexpr">Fonction constexpr</h2></a>
<p>Depuis C++14, il est possible d&rsquo;avoir des conditions et des boucles dans les fonctions. On peut alors écrire <code>index_of</code> presque comme on écrirait n&rsquo;importe quelle fonction impérative.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">loop</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">...</span> <span class="n">xs</span><span class="o">&gt;</span>
  <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">_index_of</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">matches</span><span class="p">[]{</span><span class="n">xs</span><span class="p">...,</span> <span class="nb">false</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">xs</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Les booléens sont en paramètre template. C&rsquo;est dommage, parce que cela limite les transferts de paramètre depuis une autre fonction. Il vaut mieux mettre les valeurs en paramètre de fonction comme on le fait d&rsquo;habitude.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">loop2</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">_index_of</span><span class="p">(</span><span class="n">T</span><span class="p">...</span> <span class="n">xs</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">matches</span><span class="p">[]{</span><span class="n">xs</span><span class="p">...,</span> <span class="nb">false</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">xs</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;</span><span class="p">...)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>C&rsquo;est beau, c&rsquo;est simple, c&rsquo;est élégant.</p>
<!-- raw HTML omitted -->
<p><img src="/post/mp_index_of/func_time.png" alt="comparaison de temps de pack8_bool et une fonction constexpr"></p>
<p>C&rsquo;est fou, mais dans l&rsquo;ensemble on y gagne encore. Néanmoins, la version qui prend les valeurs en paramètre est légèrement plus lente.</p>
<p>J&rsquo;ai aussi essayé avec des fonctions récursives, mais c&rsquo;est une vraie catastrophe. Premièrement, c&rsquo;est extrêmement lent. Deuxièmement, la profondeur de récursion est encore plus basse qu&rsquo;avec les templates: 512 pour Gcc (900 avec templates) et 800 pour Clang (1024 avec template). Mais surtout, une profondeur trop grande fait rapidement planter Clang.</p>
<p>En réalité, le coût d&rsquo;appel de fonction est supérieur à celui d&rsquo;une instanciation de classe. Mais si la fonction n&rsquo;est pas récursive, alors le coût peut être amorti par rapport à une implémentation récursive, comme ici.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/#fold-expression"><h2 id="fold-expression">Fold expression</h2></a>
<p>En C++17 arrive les fold expressions. Plus besoin de boucle explicite ou de fonction récursive pour dérouler des valeurs. Seulement, avec <code>index_of</code>, il faut jouer d&rsquo;ingéniosité pour stopper le fold tout en ayant un compteur qui s&rsquo;incrémente. La manière la plus simple est de mettre plusieurs instructions séparées par des <code>,</code>. La dernière valeur de cette &ldquo;liste&rdquo; sera celle utilisée pour vérifier si <code>T</code> égale <code>Ts</code>.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">fold</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">...</span> <span class="n">xs</span><span class="o">&gt;</span>
  <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">_index_of</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)((((</span><span class="kt">void</span><span class="p">)</span><span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">!</span><span class="n">xs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">...)</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">i</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="kt">int</span><span class="p">(</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">xs</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">detail</span><span class="o">::</span><span class="n">_index_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&gt;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Le code est beaucoup plus concis, mais aussi beaucoup plus obscur. Il faut dire que <code>index_of</code> n&rsquo;est pas le meilleur algorithme pour représenter la beauté des folds ;).</p>
<!-- raw HTML omitted -->
<p><img src="/post/mp_index_of/fold_gcc_time.png" alt="comparaison de temps avec gcc d&rsquo;une fonction constexpr et un fold"></p>
<p>Le résultat est très similaire à une boucle manuelle. Clang donne la même chose, mais les versions précédentes de Gcc sont extrêmement lentes avec les fold.</p>
<!-- raw HTML omitted -->
<p><img src="/post/mp_index_of/fold_gcc_7_time.png" alt="comparaison de temps avec clang d&rsquo;une fonction constexpr et un fold"></p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/#pour-terminer"><h2 id="pour-terminer">Pour terminer</h2></a>
<p>On peut retenir de ces différents tests que</p>
<ul>
<li>le nombre de spécialisations a un coût,</li>
<li>le temps de compilation est quadratique au nombre de paramètre variadique,</li>
<li>il faut limiter la récursion et le nombre de types instanciés,</li>
<li>les algorithmes doivent profiter de la mémoïsation,</li>
<li>spécialiser des valeurs est plus lent que spécialiser des types,</li>
<li>les fold expressions sont très efficaces,</li>
<li>une fonction constexpr est lente à instancier, mais l&rsquo;utilisation de boucle peut compenser ce défaut.</li>
</ul>
<p>Il n&rsquo;y a pas eu de test sur l&rsquo;affirmation qui va suivre, mais d&rsquo;expérience, je sais que les alias sont plus rapides qu&rsquo;une instanciation de classe, mais aussi plus cryptique au niveau des erreurs.</p>
<p>Si vous voulez des graphiques qui comparent 2 compilateurs, le générateur de graphe et les résultats de compilation se trouvent dans <a href="https://github.com/jonathanpoelen/jonathanpoelen.github.io/tree/source/resources/mp_index_of">le dépôt</a>
.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2018-10-01T18:28:21">01 octobre 2018
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  

  <br/><a href="https://jonathanpoelen.github.io/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="acfe95c97195256c7843e5c852ec2097-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=comparaison-de-diff%25C3%25A9rentes-impl%25C3%25A9mentations-de-mp_index_of&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f10%2fcomparaison-de-differentes-implementations-de-mp_index_of%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f10%2fcomparaison-de-differentes-implementations-de-mp_index_of%2f&amp;title=comparaison-de-diff%25C3%25A9rentes-impl%25C3%25A9mentations-de-mp_index_of" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f10%2fcomparaison-de-differentes-implementations-de-mp_index_of%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f10%2fcomparaison-de-differentes-implementations-de-mp_index_of%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f10%2fcomparaison-de-differentes-implementations-de-mp_index_of%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f10%2fcomparaison-de-differentes-implementations-de-mp_index_of%2f&amp;name=comparaison-de-diff%25C3%25A9rentes-impl%25C3%25A9mentations-de-mp_index_of" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="au-c%C5%93ur-dun-variant"><span>
        <a href="#comparaison-de-diff%25C3%25A9rentes-impl%25C3%25A9mentations-de-mp_index_of"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Comparaison de différentes implémentations de mp_index_of"></i></a>
        <a href="#faites-parler-votre-compilateur"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Faites parler votre compilateur"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2018/09/au-coeur-dun-variant/">Au cœur d&#39;un variant</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#comparaison-de-diff%25C3%25A9rentes-impl%25C3%25A9mentations-de-mp_index_of">Article suivant: Comparaison de différentes implémentations de mp_index_of</a><br/>
        <a href="#faites-parler-votre-compilateur">Article précédent: Faites parler votre compilateur</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2018-09-02T14:45:55">02 septembre 2018
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>9 minutes ;
  <a href="https://jonathanpoelen.github.io/2018/09/au-coeur-dun-variant/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#dc9b2e982ad7fe0bb2aca98f8a852275-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
  

</p>


  </header>
  <div class="post__content">
      <p>Cet article va être consacré à la réalisation d&rsquo;une classe variant comme on peut la trouver dans la <a href="http://en.cppreference.com/w/cpp/utility/variant">STL</a>, <a href="http://en.cppreference.com/w/cpp/utility/variant">boost</a> et <a href="https://github.com/mapbox/variant">autres</a>. Il existe de nombreuses techniques plus ou moins simples à réaliser et plus ou moins coûteuses à l&rsquo;exécution. Je vais faire un petit tour de ce que j&rsquo;ai pu voir et comment les implémenter.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/09/au-coeur-dun-variant/#rappel-sur-ce-quest-un-variant"><h2 id="rappel-sur-ce-quest-un-variant">Rappel sur ce qu&rsquo;est un variant</h2></a>
<p>Un variant est une <strong>union sécurisée</strong> comme on peut le trouver dans les langages fonctionnels.
Contrairement aux <a href="http://en.cppreference.com/w/cpp/language/union">union</a> classique du C++, le variant garde l&rsquo;information du type manipulé.
C&rsquo;est en cela qu&rsquo;il est sécurisé, on ne sélectionne pas une valeur d&rsquo;un certain type,
mais on fournit une fonction que le variant appelle avec le type enregistré.</p>
<p>Même si le variant peut aisément remplacer l&rsquo;héritage lorsque le nombre de classe dérivée est connue,
il est beaucoup plus adapté lorsque les valeurs priment sur les comportements.
Par exemple, une valeur d&rsquo;une structure JSON représente un nombre, un tableau, une chaîne de caractères ou un objet.
Il n&rsquo;y a pas de comportement commun, les traitements se feront en fonction du type de la valeur.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/09/au-coeur-dun-variant/#un-premier-variant"><h2 id="un-premier-variant">Un premier variant</h2></a>
<p>Notre version minimale de variant va contenir:</p>
<ul>
<li>Les constructeurs par défaut, de copie et de déplacement.</li>
<li>Un constructeur pour initialiser avec un type de la liste.</li>
<li>Les opérateurs d&rsquo;affectation correspondant aux constructeurs.</li>
<li>Une fonction <code>visit</code> (en membre, pour des raisons de simplification).</li>
</ul>

<div class="InfoBox"><p><strong class="InfoBox-title">Info :</strong> <p>L&rsquo;implémentation qui va suivre se veut simple et surtout naïve. De ce fait, elle est totalement inefficace et montre l&rsquo;exemple à ne pas suivre.
Elle servira néanmoins de base de travail et sera peaufinée tout au long des chapitres pour atteindre l'<em>idéal</em> du variant.</p>
</p></div>

<p>Comme le type change en cours de route, nous allons utiliser en interne une classe de base qui pour chaque dérivée va contenir le type réel.
Grâce à cela, le type stocké pourra être supprimé et un nouveau type pourra y être enregistré.
Cette classe de base pourra aussi servir à implémenter l&rsquo;opérateur de copie via une fonction <code>clone</code>.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">VariantBase</span>
  <span class="p">{</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">VariantBase</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">VariantBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Variant</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Variant</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">Variant</span><span class="p">(</span><span class="n">Variant</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">Variant</span><span class="p">(</span><span class="n">Variant</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">Variant</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>

  <span class="n">Variant</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Variant</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">Variant</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Variant</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">Variant</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="o">&gt;</span>
  <span class="k">auto</span> <span class="n">visit</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">VariantBase</span><span class="o">&gt;</span> <span class="n">impl_</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>Pour ne pas parasiter les codes, je n&rsquo;ajoute pas les noexcept. De toute façon, avec les allocations dynamiques, cela ne va pas être évident.</p>
<p>Toute la difficulté va se trouver dans les implémentations de <code>VariantBase</code> et la fonction <code>visit</code>. Pour en faire une dérivée, un pattern assez commun va être utilisé, celui d&rsquo;avoir une classe <code>VariantImpl</code> template sur le type à stocker.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">VariantImpl</span> <span class="o">:</span> <span class="n">VariantBase</span>
  <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
    <span class="n">VariantImpl</span><span class="p">(</span><span class="n">U</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">{}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">VariantBase</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">VariantImpl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">value_</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">auto</span> <span class="n">make_variant_impl</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">VariantImpl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Variant</span><span class="p">(</span><span class="n">Variant</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="o">:</span> <span class="n">impl_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">impl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">())</span>
<span class="p">{}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Variant</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="o">:</span> <span class="n">impl_</span><span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">make_variant_impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="p">{}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Variant</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">impl_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">impl_</span> <span class="o">?</span> <span class="n">other</span><span class="p">.</span><span class="n">impl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">()</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">impl_</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">make_variant_impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>En réalité ce qu&rsquo;on vient de faire ici n&rsquo;est ni plus ni moins qu&rsquo;un <code>std::any</code>. Si on réfléchit bien, nous ne sommes pas limités dans les types à stocker et il n&rsquo;y a aucune vérification au niveau de l&rsquo;initialisation d&rsquo;une valeur. C&rsquo;est mal, mais on va rester comme cela pour le moment.</p>
<p>Reste ensuite la fonction <code>visit</code>. À ce stade, je dirais que la solution la plus naturelle est d&rsquo;utiliser <code>dynamic_cast</code> pour déterminer le type réel et appeler la bonne surcharge de fonction.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">visit</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">impl_</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">visit_impl</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">rec</span><span class="p">,</span> <span class="k">auto</span><span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="k">auto</span><span class="o">*</span><span class="p">...</span> <span class="n">ts</span><span class="p">){</span>
    <span class="k">using</span> <span class="n">Impl</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">VariantImpl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">;</span>
    <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">ts</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">auto</span><span class="o">*</span> <span class="n">impl</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">impl_</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
      <span class="k">return</span> <span class="n">impl</span> <span class="o">?</span> <span class="n">f</span><span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">value_</span><span class="p">)</span> <span class="o">:</span> <span class="n">rec</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">ts</span><span class="p">...);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">rec</span><span class="p">;</span>
      <span class="k">return</span> <span class="nf">f</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">impl_</span><span class="p">.</span><span class="n">get</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">value_</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="nf">visit_impl</span><span class="p">(</span><span class="n">visit_impl</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)...);</span>
<span class="p">}</span></code></pre></div>

<p>Cette implémentation parcourt récursivement les types du variant pour trouver celui qui correspond à la valeur de <code>impl_</code>, appel <code>f</code> avec le bon type puis propage son retour en remontant la pile d&rsquo;appel.
Le dernier élément est un cas spécial traité dans le <code>else</code> car, quand on le compare avec <code>dynamic_cast</code>, le résultat est toujours vrai.
Comme notre variant ne contient &ndash;normalement&ndash; qu&rsquo;un nombre restreint de types, si la valeur de <code>impl_</code> ne correspond pas aux types qui précèdent le dernier, alors <code>impl_</code> est forcément du type du dernier élément.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/09/au-coeur-dun-variant/#moi-jaime-pas-dynamic_cast"><h2 id="moi-jaime-pas-dynamic_cast">Moi j&rsquo;aime pas dynamic_cast</h2></a>
<p><code>dynamic_cast</code> est souvent un signe révélateur d&rsquo;un problème de conception. Si on abstrait les valeurs, c&rsquo;est dans le but de ne pas se soucier du type de l&rsquo;implémentation. Or, un variant met le focus sur le type et rend caduque cette abstraction. Seulement, <code>dynamic_cast</code> a un coût d&rsquo;exécution exorbitant par rapport à la tâche qu&rsquo;il effectue ici.</p>
<p>De ce fait, <code>dynamic_cast</code> n&rsquo;est pas une bonne solution, il est plus judicieux de conserver une information pour différencier les types. Comme un variant contient une liste d&rsquo;éléments, l&rsquo;indice du type utilisé suffit amplement.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Variant</span>
<span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">VariantBase</span><span class="o">&gt;</span> <span class="n">impl_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">type_index_</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Maintenant, il faut convertir un type en indice, c&rsquo;est à ce moment que la méta-programmation arrive à la rescousse.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">count_items_to_right_of</span><span class="p">;</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Us</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">count_items_to_right_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Us</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">count_items_to_right_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Us</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Us</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">count_items_to_right_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Us</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Us</span><span class="p">)</span><span class="o">&gt;</span>
  <span class="p">{};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">mp_index_of</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span>
  <span class="k">sizeof</span><span class="p">...(</span><span class="n">Ts</span><span class="p">)</span> <span class="o">-</span> <span class="n">detail</span><span class="o">::</span><span class="n">count_items_to_right_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span>
<span class="o">&gt;</span><span class="p">;</span></code></pre></div>

<p><code>mp_index_of</code> est un alias sur <code>std::integral_constant</code>. L&rsquo;implémentation déroule récursivement les éléments de <code>Ts</code> jusqu&rsquo;à trouver <code>T</code> et retourne le nombre d&rsquo;éléments qu&rsquo;il reste dans la liste. Soustraire ce résultat à <code>sizeof...(Ts) - 1</code> permet d&rsquo;avoir la position de <code>T</code>.</p>
<p>On met à jour l&rsquo;implémentation pour initialiser le nouveau membre.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Variant</span><span class="p">(</span><span class="n">Variant</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="o">:</span> <span class="n">impl_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">impl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">())</span>
<span class="p">,</span> <span class="n">type_index_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">type_index_</span><span class="p">)</span> <span class="c1">// ici
</span><span class="c1"></span><span class="p">{}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Variant</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="o">:</span> <span class="n">impl_</span><span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">make_variant_impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="p">,</span> <span class="n">type_index_</span><span class="p">(</span><span class="n">mp_index_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="c1">// là
</span><span class="c1"></span><span class="p">{}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Variant</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">impl_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">impl_</span> <span class="o">?</span> <span class="n">other</span><span class="p">.</span><span class="n">impl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">()</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="n">type_index_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">type_index_</span><span class="p">;</span> <span class="c1">// ici aussi
</span><span class="c1"></span>  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">impl_</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">make_variant_impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
  <span class="n">type_index_</span> <span class="o">=</span> <span class="n">mp_index_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span> <span class="c1">// et là
</span><span class="c1"></span>  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Puis on supprime <code>dynamic_cast</code> de la fonction <code>visit</code>, le remplaçant par une comparaison d&rsquo;index.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">Variant</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">visit</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">impl_</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">visit_impl</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">rec</span><span class="p">,</span> <span class="k">auto</span><span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="k">auto</span><span class="o">*</span><span class="p">...</span> <span class="n">ts</span><span class="p">){</span>
    <span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Impl</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">VariantImpl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
    <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">ts</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// plus de dynamic_cast, mais une comparaison d&#39;entier + static_cast
</span><span class="c1"></span>      <span class="k">return</span> <span class="n">type_index_</span> <span class="o">==</span> <span class="n">mp_index_of</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span>
        <span class="o">?</span> <span class="n">f</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">impl_</span><span class="p">.</span><span class="n">get</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">value_</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">rec</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">ts</span><span class="p">...);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">rec</span><span class="p">;</span>
      <span class="k">return</span> <span class="nf">f</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">impl_</span><span class="p">.</span><span class="n">get</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">value_</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="nf">visit_impl</span><span class="p">(</span><span class="n">visit_impl</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)...);</span>
<span class="p">}</span></code></pre></div>

<p>Peu de changement finalement, mais maintenant <code>variant</code> peut fonctionner sans support de <a href="https://fr.wikipedia.org/wiki/Run-time_type_information">RTTI</a> !</p>
<p>On notera aussi que puisque nous possédons l&rsquo;indice lié au type, on peut aussi remplacer les fonctions virtuelles par un appel à <code>visit</code> pour supprimer la vtable et enlever l&rsquo;indirection pour accéder aux fonctions virtuelles dans celle-ci.</p>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/09/au-coeur-dun-variant/#lallocation-dynamique-nest-pas-gratuite"><h2 id="lallocation-dynamique-nest-pas-gratuite">L&rsquo;allocation dynamique n&rsquo;est pas gratuite</h2></a>
<p>Il est vrai que l&rsquo;allocation dynamique a un coût non négligeable sur les performances. Personne n&rsquo;a idée de faire <code>new int</code> alors qu&rsquo;en regardant de plus près, c&rsquo;est exactement ce que fait notre implémentation. Vient ensuite les déréférencements de pointeur qui font sauter des optimisations. Effet amplifié lorsque les fonctions sont <code>virtual</code>. Décidément, l&rsquo;allocation dynamique pour un variant n&rsquo;est pas une bonne idée.</p>
<p>Le mieux serait de stocker nos types de la même manière qu&rsquo;une union: un seul bloc mémoire de la taille du type le plus grand. À ma connaissance il existe 2 possibilités:</p>
<ul>
<li>une union récursive</li>
<li><a href="http://en.cppreference.com/w/cpp/types/aligned_union">std::aligned_union</a></li>
</ul>
<p>Pour choisir le procédé le plus efficace, nous implémentons les 2 dans une classe qui ne possède que les fonctions d&rsquo;accès et les constructeurs.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">AlignedStorage</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">aligned_union_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>Sans les constructeurs, la version avec <code>std::aligned_union</code> est vraiment simple. Mais l&rsquo;utilisation de <code>reinterpret_cast</code> empêche de mettre la fonction <code>get()</code> en <code>constexpr</code> (gcc l&rsquo;accepte néanmoins).</p>
<p>À contrario, la version avec une union récursive est extrêmement verbeuse (toujours sans constructeur d&rsquo;initialisation de valeur):</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">detail</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="k">union</span> <span class="nc">RecursiveUnion</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">RecursiveUnion</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">others</span><span class="p">;</span>

    <span class="n">RecursiveUnion</span><span class="p">()</span> <span class="o">:</span> <span class="n">dummy</span><span class="p">()</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">RecursiveUnion</span><span class="p">(){}</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">union</span> <span class="nc">RecursiveUnion</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">;</span>

    <span class="n">RecursiveUnion</span><span class="p">()</span> <span class="o">:</span> <span class="n">dummy</span><span class="p">()</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">RecursiveUnion</span><span class="p">(){}</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">(</span><span class="n">RecursiveUnion</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">u</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">(</span><span class="n">U</span><span class="o">&amp;</span> <span class="n">u</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">others</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">UnionStorage</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">detail</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>

  <span class="n">detail</span><span class="o">::</span><span class="n">RecursiveUnion</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>Si on regarde <a href="https://godbolt.org/g/xu9fwh">l&rsquo;assembleur</a>, il s&rsquo;avère que les 2 versions sont exactement les mêmes.</p>
<p>Pour initialiser l&rsquo;objet avec une valeur, la version avec <code>std::aligned_union</code> doit utiliser un <a href="http://en.cppreference.com/w/cpp/language/new">placement new</a> qui empêche de rendre le constructeur <code>constexpr</code>. Ce qui par la même occasion s&rsquo;applique aussi au variant. Sans compter le problème du <code>reinterpret_cast</code> dans la fonction <code>get()</code>. Du coup, bien que cette version soit plus simple et que je ne mette pas <code>constexpr</code>, l&rsquo;union récursive est préférable.</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// std::in_place_index_t
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">in_place_index_t</span>
<span class="p">{</span>
  <span class="k">explicit</span> <span class="nf">in_place_index_t</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>(<code>RecursiveUnion</code> devient <code>VariadicUnion</code>)</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
    <span class="n">VariadicUnion</span><span class="p">(</span><span class="n">in_place_index_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">U</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">{}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">I</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
    <span class="n">VariadicUnion</span><span class="p">(</span><span class="n">in_place_index_t</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">U</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">others</span><span class="p">(</span><span class="n">in_place_index_t</span><span class="o">&lt;</span><span class="n">I</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">{},</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">{}</span></code></pre></div>

<p>Puis on adapte les fonctions de <code>Variant</code>.
Le code final est plutôt gros alors je ne mets <a href="https://github.com/jonathanpoelen/jonathanpoelen.github.io/tree/source/resources/cpp_variant/variant3.cpp#l157">que le lien</a>
.</p>
<p>Pour éviter une condition particulière dans le code, l&rsquo;union possède un membre supplémentaire: <code>Uninit</code>, utilisé par <code>init</code>, <code>copy</code> et <code>destroy</code> pour représenter un variant sans valeur.</p>
<p>Il y a aussi une condition dans <code>operator=</code> pour choisir entre la fonction <code>copy</code> si les 2 éléments sont du même type ou les fonctions <code>destroy</code>+<code>init</code> dans le cas contraire. Cette condition peut être supprimée si:</p>
<ul>
<li>Tous les éléments ont un destructeur trivial: il n&rsquo;y a pas besoin de faire <code>destroy</code>+<code>init</code>.</li>
<li>La fonction <code>visit</code> peut prendre plusieurs variants en paramètre pour faire un switch allant de 0 à <code>(sizeof...(Ts) + 1) * (sizeof...(Ts) + 1)</code>.</li>
</ul>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2018/09/au-coeur-dun-variant/#mot-de-la-fin"><h2 id="mot-de-la-fin">Mot de la fin</h2></a>
<p>Bien que le variant actuel soit incomplet, il est utilisable et proche des implémentations actuelles. Mais il y a plusieurs petits détails qui ne sont pas approfondis ici:</p>
<ul>
<li>l&rsquo;optimisation sur la taille de <code>type_index</code>,</li>
<li>les différents moyens de remplacer une vtable (ici je n&rsquo;utilise que le if/else récursif),</li>
<li>le coût d&rsquo;utilisation d&rsquo;un objet en fonction de sa nature (par exemple: le compilateur dévirtualise-t-il les fonctions virtuelles venant d&rsquo;un membre de variant ?)</li>
<li>les variants récursives</li>
<li>et bien d&rsquo;autres</li>
</ul>
<p>Les prochains articles seront davantage axés sur la méta-programmation et indirectement reliés avec certains aspects du variant présentés ici.</p>
<p>Les sources sont disponibles sur <a href="https://github.com/jonathanpoelen/jonathanpoelen.github.io/tree/source/resources/cpp_variant">github</a>
.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2018-09-02T14:45:55">02 septembre 2018
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  

  <br/><a href="https://jonathanpoelen.github.io/2018/09/au-coeur-dun-variant/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="dc9b2e982ad7fe0bb2aca98f8a852275-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=au-c%25C5%2593ur-dun-variant&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f09%2fau-coeur-dun-variant%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f09%2fau-coeur-dun-variant%2f&amp;title=au-c%25C5%2593ur-dun-variant" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f09%2fau-coeur-dun-variant%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f09%2fau-coeur-dun-variant%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f09%2fau-coeur-dun-variant%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2018%2f09%2fau-coeur-dun-variant%2f&amp;name=au-c%25C5%2593ur-dun-variant" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>


    
      
<div class="pagination clearfix">
  <span class="pagination__item pagination__item--current">1/4</span>
  <a class="pagination__item" href="/page/2/">2</a>
  <a class="pagination__item" href="/page/3/">3</a>
  <a class="pagination__item" href="/page/4/">4</a>
  <a class="pagination__item pagination__item--next" href="/page/2/">▶</a>
</div>


  </main>

</div>
  <footer class="footer" itemscope="itemscope" itemtype="http://schema.org/WPFooter">
    <p class="footer-archive"><a href="/archives" title="Archives">Archives</a></p>
    <p class="footer__copyright">
       Le blog de Jonathan Poelen. <span class="footer__copyright-credits">
      Généré avec <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> et basé sur le thème <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a>.
      Utilise <a href="http://fontawesome.io" rel="nofollow noopener" target="_blank">Font Awesome</a> de Dave Gandy pour les icônes.
      </span>
    </p>
  </footer>
</div>
<a id="backtop" href="#avoidance-link"><i class="fas fa-arrow-circle-up fa-3x" aria-hidden="true"></i><span class="sr-only">Revenir en haut</span></a>

</body>
</html>


