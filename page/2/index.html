<!DOCTYPE html>
<html lang="fr-FR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jonathan Poelen&#39;s Blog</title>
<meta name="generator" content="Hugo 0.52" />

<link rel="alternate" type="application/rss+xml" title="Jonathan Poelen&#39;s Blog Feed" href="https://jonathanpoelen.github.io/index.xml" />

<link rel="stylesheet" type="text/css" media="all" href="https://fonts.googleapis.com/css?family=Droid+Serif" crossorigin="anonymous" />
<link rel="stylesheet" type="text/css" media="all" href="https://fonts.googleapis.com/css?family=Noto+Sans" crossorigin="anonymous" />

<link rel="stylesheet" type="text/css" media="all" href="https://jonathanpoelen.github.io/css/style.min.78d675238305d53afafcf4dcc8fcae057b79e7ac460f84fe54c59332646dff9c.css">
<link rel="stylesheet" type="text/css" media="all" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous" />
<link rel="shortcut icon" href="/favicon.jpg"/>
<link rel="icon" sizes="32x32" href="/favicon-32.jpg" type="image/jpeg">
<link rel="icon" sizes="64x64" href="/favicon-64.jpg" type="image/jpeg">
<link rel="icon" sizes="96x96" href="/favicon-96.jpg" type="image/jpeg"> 
<link rel="icon" sizes="128x128" href="/favicon-128.jpg" type="image/jpeg">
<meta property="og:site_name" content="Jonathan Poelen&#39;s Blog">
<meta property="og:title" content="Jonathan Poelen&#39;s Blog">
<meta property="og:url" content="https://jonathanpoelen.github.io/">
<meta property="og:language" content="fr-FR">
<meta property="twitter:domain" content="https://jonathanpoelen.github.io/">
<meta property="twitter:card" content="summary">
<meta property="twitter:url" content="https://jonathanpoelen.github.io/">
<meta property="twitter:title" content="Jonathan Poelen&#39;s Blog">
<meta name="description" content="Le blog de Jonathan Poelen.Mon petit mémo sur tout ce qui touche à la programmation =)">
<meta property="twitter:description" content="Le blog de Jonathan Poelen.Mon petit mémo sur tout ce qui touche à la programmation =)">

</head>
<body class="body body-right-sidebar mobile" itemscope="itemscope" itemtype="http://schema.org/WebPage">
  <div id="avoidance-link">
    <a class="evitement" href="#main-content" title="Aller au contenu">Aller au contenu</a>
    <a class="evitement" href="#main-menu" title="Aller au menu">Aller au menu</a>
  </div>
  <div class="container container-outer">
    <header class="header" itemscope="itemscope" itemtype="http://schema.org/WPHeader">
      <div class="container-inner">
        <div class="logo" role="banner" itemscope="itemscope" itemtype="http://schema.org/Brand">
          <a class="logo__link" href="/" title="Jonathan Poelen&#39;s Blog" rel="home">
            <h1 class="logo__title">Le blog de Jonathan Poelen</h1>
            <h2 class="logo__tagline">Mon petit mémo sur tout ce qui touche à la programmation =)</h2>
          </a>
        </div>
        <nav class="menu" itemscope="itemscope" itemtype="http://schema.org/SiteNavigationElement">
  <ul class="menu__list">
    <li class="menu__item"><a class="menu__link" title="GitHub" rel="noopener noreferrer" href="https://github.com/jonathanpoelen">
      <i class="fab fa-github" aria-hidden="true"></i> Github
    </a></li>
    <li class="menu__item "><a class="menu__link" title="Archives" href="/archives">
      <i class="fas fa-archive" aria-hidden="true"></i> Archives</a>
    </li>
    <li class="menu__item"><a class="menu__link" title="Flux RSS" href="/index.xml">
      <i class="fas fa-rss" aria-hidden="true"></i> RSS</a>
    </li>
  </ul>
</nav>


      </div>
    </header>
    <div class="wrapper clearfix">


<aside class="sidebar" itemscope="itemscope" itemtype="http://schema.org/WPSideBar">
	
<div class="widget-search widget">
  <form class="widget-search__form" role="search" method="get" action="https://duckduckgo.com">
    <label>
      <span class="screen-reader-text">Search for:</span>
      <input class="widget-search__field" type="search" placeholder="SEARCH..." value="" name="q">
    </label>
    <input class="widget-search__submit" type="submit" value="Search">
    <input type="hidden" name="sites" value="https://jonathanpoelen.github.io/" />
  </form>
</div>

	
<div class="widget-recent widget" id="main-menu">
  <h4 class="widget__title"><i class="fas fa-file-text-o" aria-hidden="true"></i> Articles récents</h4>
  <div class="widget__content">
    <ul class="widget__list">
      <li class="widget__item"><a class="widget__link" href="/2018/12/presque-toujours-stdmove/">Presque toujours std::move</a></li>
      <li class="widget__item"><a class="widget__link" href="/2018/11/meta-function-et-continuation/">Méta-function et continuation</a></li>
      <li class="widget__item"><a class="widget__link" href="/2018/11/simuler-une-vtable-sans-fonction-virtuelle/">Simuler une vtable sans fonction virtuelle</a></li>
      <li class="widget__item"><a class="widget__link" href="/2018/10/comparaison-de-differentes-implementations-de-mp_index_of/">Comparaison de différentes implémentations de mp_index_of</a></li>
      
      <li class="widget__item"><a class="widget__link widget__link__other" href="/archives">31 autres…</a></li>
    </ul>
  </div>
</div>
<div class="widget-recent widget">
  <h4 class="widget__title"><i class="fas fa-clock-o" aria-hidden="true"></i> Articles récemment mis à jour</h4>
  <div class="widget__content">
    <ul class="widget__list">

    </ul>
  </div>
</div>

	
<div class="widget-categories widget">
  <h4 class="widget__title"><i class="fas fa-folder-o" aria-hidden="true"></i> Catégories</h4>
  <div class="widget__content">
    <ul class="widget__list">
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour C&#43;&#43;">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/c&#43;&#43;">C&#43;&#43; (23)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Script-Shell">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/script-shell">Script-Shell (6)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Accessibilite-Web">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/accessibilite-web">Accessibilite-Web (2)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Javascript">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/javascript">Javascript (2)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Make">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/make">Make (1)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Sqlite">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/sqlite">Sqlite (1)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Zsh">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/zsh">Zsh (1)</a>
      </li>
    </ul>
  </div>
</div>

	
	

</aside>

  <main class="main-content list content" role="main" id="main-content">
        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="if-constexpr-avant-c&#43;&#43;17"><span>
        <a href="#comment-se-passer-de-stdforward"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Comment se passer de std::forward"></i></a>
        <a href="#param%25C3%25A8tres-de-fonction-nomm%25C3%25A9s-en-c%2b%2b"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Paramètres de fonction nommés en C&#43;&#43;"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2015/09/if-constexpr-avant-cpp17/">if constexpr avant C&#43;&#43;17</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#comment-se-passer-de-stdforward">Article suivant: Comment se passer de std::forward</a><br/>
        <a href="#param%25C3%25A8tres-de-fonction-nomm%25C3%25A9s-en-c%2b%2b">Article précédent: Paramètres de fonction nommés en C&#43;&#43;</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2015-09-21T00:33:38">21 septembre 2015
</time>
    
    (Dernière Modification le <time class="post__meta-lastmod" datetime="2018-03-04T23:14:38">04 mars 2018
)</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>2 minutes ;
  <a href="https://jonathanpoelen.github.io/2015/09/if-constexpr-avant-cpp17/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#175a62cf1a99f97cb9cb3cff7e36971f-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
      

<p>Le but de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="k">constexpr</span>
</code></span> est d&rsquo;interpréter le code uniquement si celui-ci respecte la condition. Il doit être syntaxiquement valide, mais n&rsquo;a pas l&rsquo;obligation de pouvoir être compilé.</p>

<p>Plutôt étrange, n&rsquo;est-ce pas ? Cette propriété se révèle pourtant fort pratique dans les fonctions templates.</p>

<p>Prenons comme exemple une fonction <code>invoke</code> qui s&rsquo;utilise de 3 manières:</p>

<ul>
<li>foncteur + paramètres</li>
<li>fonction membre + objet + paramètres</li>
<li>fonction membre + pointeur d&rsquo;objet + paramètres</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// x et y sont des std::string
</span><span class="c1"></span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;&gt;</span><span class="p">{},</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// foncteur
</span><span class="c1"></span><span class="n">invoke</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// fonction membre et référence
</span><span class="c1"></span><span class="n">invoke</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// fonction membre et pointeur
</span><span class="c1"></span></code></pre></div>
<p>En C++17, tout peut se faire en une seule fonction, alors qu&rsquo;avant C++17, il fallait faire plusieurs surcharges pour les différentes situations et jouer avec <code>std::enable_if</code>.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2015/09/if-constexpr-avant-cpp17/#implémentation-avec-if-constexpr"><h2 id="implémentation-avec-if-constexpr">Implémentation avec if constexpr</h2></a>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">F</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">invoke</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_member_function_pointer</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-&gt;*</span><span class="n">f</span><span class="p">)(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">F</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">invoke</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">)();</span>
<span class="p">}</span>
</code></pre></div>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2015/09/if-constexpr-avant-cpp17/#simulation-de-if-constexpr-en-pre-c-17"><h2 id="simulation-de-if-constexpr-en-pre-c-17">Simulation de if constexpr en pre-C++17</h2></a>

<p>L&rsquo;atout principal de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="k">constexpr</span>
</code></span> ici est de n&rsquo;évaluer le code qu&rsquo;au besoin. Il faut donc un moyen de court-circuiter le flux de code. Le plus simple consiste à faire 2 fonctions, une avec un paramètre de type <code>std::true_type</code>, l&rsquo;autre avec un <code>std::false_type</code> qui représente le résultat de la condition et 2 paramètres: <code>If</code> et <code>Else</code>.</p>

<p>Aussi, pour que les foncteurs <code>If</code> et <code>Else</code> soient évalués au dernier moment, ils devront prendre et utiliser un paramètre générique (<span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span>
</code></span>). Sinon le compilateur va vérifier le code au moment de l&rsquo;instanciation de la lambda plutôt qu&rsquo;au moment de son utilisation.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Identity</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span>
  <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">If</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">Else</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">if_constexpr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="n">cond</span><span class="p">,</span> <span class="n">If</span> <span class="n">f</span><span class="p">,</span> <span class="n">Else</span> <span class="o">=</span> <span class="p">{})</span>
<span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">Identity</span><span class="p">{});</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">If</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">Else</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">if_constexpr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="n">cond</span><span class="p">,</span> <span class="n">If</span><span class="p">,</span> <span class="n">Else</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">Identity</span><span class="p">{});</span> <span class="p">}</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">F</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">invoke</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">if_constexpr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_member_function_pointer</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span><span class="p">{},</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">if_constexpr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">{},</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">_</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">-&gt;*</span><span class="n">f</span><span class="p">)(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">},</span> <span class="cm">/* else */</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">_</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)).</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">},</span> <span class="cm">/* else */</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">))(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2015/09/if-constexpr-avant-cpp17/#limitation"><h2 id="limitation">Limitation</h2></a>

<p>Cette version ne supporte pas <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="k">else</span>
</code></span>, demande d&rsquo;utiliser <code>_</code> &laquo;&nbsp;là où il faut&nbsp;&raquo; et est syntaxiquement plus lourde.
Mais la véritable limitation réside dans l&rsquo;appel même d&rsquo;une fonction qui ne propage pas l&rsquo;usage de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">break</span>
</code></span>, <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">continue</span>
</code></span> et <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">return</span>
</code></span>.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2015-09-21T00:33:38">21 septembre 2015
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  
<br />(Dernière Modification le <time class="post__meta-lastmod" datetime="2018-03-04T23:14:38">04 mars 2018
)</time>
  <br/><a href="https://jonathanpoelen.github.io/2015/09/if-constexpr-avant-cpp17/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="175a62cf1a99f97cb9cb3cff7e36971f-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=if-constexpr-avant-c%2b%2b17&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f09%2fif-constexpr-avant-cpp17%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f09%2fif-constexpr-avant-cpp17%2f&amp;title=if-constexpr-avant-c%2b%2b17" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f09%2fif-constexpr-avant-cpp17%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f09%2fif-constexpr-avant-cpp17%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f09%2fif-constexpr-avant-cpp17%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f09%2fif-constexpr-avant-cpp17%2f&amp;name=if-constexpr-avant-c%2b%2b17" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="param%C3%A8tres-de-fonction-nomm%C3%A9s-en-c&#43;&#43;"><span>
        <a href="#if-constexpr-avant-c%2b%2b17"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: if constexpr avant C&#43;&#43;17"></i></a>
        <a href="#impl%25C3%25A9mentation-dun-magasin-de-type"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Implémentation d&#39;un magasin de type"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2015/07/parametres-de-fonction-nommes-en-cpp/">Paramètres de fonction nommés en C&#43;&#43;</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#if-constexpr-avant-c%2b%2b17">Article suivant: if constexpr avant C&#43;&#43;17</a><br/>
        <a href="#impl%25C3%25A9mentation-dun-magasin-de-type">Article précédent: Implémentation d&#39;un magasin de type</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2015-07-28T00:43:22">28 juillet 2015
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>3 minutes ;
  <a href="https://jonathanpoelen.github.io/2015/07/parametres-de-fonction-nommes-en-cpp/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#8df7f8d0192d9f86d50bcccdaace39c9-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
      

<p>Cet article est la démonstration de l&rsquo;article précédent. La problématique présentée est la suivante: &laquo;&nbsp;Comment, dans une fonction avec plusieurs paramètres optionnels, initialiser un paramètre précis sans indiquer les valeurs optionnelles qui précèdent ?&nbsp;&raquo;</p>

<p>La fonction de référence sera la suivante:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">draw_rect</span><span class="p">(</span>
  <span class="kt">unsigned</span> <span class="n">w</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">h</span>
<span class="p">,</span> <span class="kt">char</span> <span class="n">border_top</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">,</span> <span class="kt">char</span> <span class="n">border_bottom</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span>
<span class="p">,</span> <span class="kt">char</span> <span class="n">border_left</span> <span class="o">=</span> <span class="sc">&#39;&lt;&#39;</span><span class="p">,</span> <span class="kt">char</span> <span class="n">border_right</span> <span class="o">=</span> <span class="sc">&#39;&gt;&#39;</span>
<span class="p">,</span> <span class="kt">char</span> <span class="n">fill</span> <span class="o">=</span> <span class="sc">&#39;#&#39;</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setfill</span><span class="p">(</span><span class="n">border_top</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">w</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">h</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">border_left</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setfill</span><span class="p">(</span><span class="n">fill</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">border_right</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setfill</span><span class="p">(</span><span class="n">border_bottom</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">w</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Comment faire un appel proche de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">draw_rect</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="sc">&#39;@&#39;</span><span class="p">)</span>
</code></span> ?</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2015/07/parametres-de-fonction-nommes-en-cpp/#création-d-un-paramètre-nommé"><h2 id="création-d-un-paramètre-nommé">Création d&rsquo;un paramètre nommé</h2></a>

<p>La première étape consiste à créer un type par paramètre optionnel. Comme je n&rsquo;ai pas envie de me compliquer la vie, la syntaxe <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">fill</span><span class="o">=</span><span class="sc">&#39;@&#39;</span>
</code></span> qui demande plus de code à cause d&rsquo;une surcharge de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">operator</span><span class="o">=</span>
</code></span> sera remplacée par un simple appel de constructeur <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">fill</span><span class="p">{</span><span class="sc">&#39;@&#39;</span><span class="p">}</span>
</code></span>.</p>

<p>La définition des types devient alors véritablement simpliste:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">border_top</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">border_bottom</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">border_left</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">border_right</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">fill</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2015/07/parametres-de-fonction-nommes-en-cpp/#adapter-draw-rect"><h2 id="adapter-draw-rect">Adapter draw_rect</h2></a>

<p>Au lieu d&rsquo;adapter <code>draw_rect</code>, je vais passer par une surcharge, ceci n&rsquo;impactera pas le résultat.</p>

<p>La nouvelle fonction doit pouvoir prendre les nouveaux types, mais pas forcément tous et de préférence dans un ordre indéfini.</p>

<p>On pourrait faire toutes les surcharges possibles, il n&rsquo;y a &laquo;&nbsp;que&nbsp;&raquo; plus d&rsquo;une centaine de possibilités après tout&hellip; Solution rejetée, évidemment ;).</p>

<p>Une template variadique fera l&rsquo;affaire.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">draw_rect</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">w</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">h</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>
<p>Il reste maintenant à associer chaque type de <code>params</code> avec le paramètre de notre premier prototype de draw_rect.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2015/07/parametres-de-fonction-nommes-en-cpp/#distribution-des-paramètres"><h2 id="distribution-des-paramètres">Distribution des paramètres</h2></a>

<p>C&rsquo;est là qu&rsquo;intervient le magasin de type de l&rsquo;article précédant (toujours pas trouvé de meilleur nom).</p>

<p>Le principe est simple, toutes les valeurs de params sont regroupées sous une même enseigne appelé ici &laquo;&nbsp;pack&nbsp;&raquo;. On vérifie si le pack est convertible en un type voulu et dans le cas contraire, on utilise une valeur par défaut.</p>

<p>Notre pack ressemble à ça:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nl">Pack</span> <span class="p">:</span> <span class="n">Ts</span><span class="p">...</span> <span class="p">{</span>
  <span class="n">Pack</span><span class="p">(</span><span class="n">Ts</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">Ts</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span> <span class="p">{}</span>
<span class="p">}</span> <span class="n">pack</span><span class="p">{</span><span class="n">params</span><span class="p">...};</span>
</code></pre></div>
<p>Et la distribution des paramètres se fait ainsi:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">draw_rect</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span>
<span class="p">,</span> <span class="n">getval</span><span class="o">&lt;</span><span class="n">border_top</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pack</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span>
<span class="p">,</span> <span class="n">getval</span><span class="o">&lt;</span><span class="n">border_bottom</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pack</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span>
<span class="p">,</span> <span class="n">getval</span><span class="o">&lt;</span><span class="n">border_left</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pack</span><span class="p">,</span> <span class="sc">&#39;&lt;&#39;</span><span class="p">)</span>
<span class="p">,</span> <span class="n">getval</span><span class="o">&lt;</span><span class="n">border_right</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pack</span><span class="p">,</span> <span class="sc">&#39;&gt;&#39;</span><span class="p">)</span>
<span class="p">,</span> <span class="n">getval</span><span class="o">&lt;</span><span class="n">fill</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pack</span><span class="p">,</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>
<p>Pour les plus attentifs (il m&rsquo;a fallu 2 jours pour le réaliser…), rien n&rsquo;empêche d&rsquo;envoyer des paramètres inutiles. On peut l&rsquo;empêcher grâce à un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">static_assert</span>
</code></span> avec une condition qui ressemble à</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span><span class="p">...(</span><span class="n">Ts</span><span class="p">)</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">is_convertible_t</span><span class="o">&lt;</span><span class="n">border_top</span><span class="o">&gt;</span><span class="p">()</span>
               <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">border_bottom</span><span class="o">&gt;</span><span class="p">()</span>
               <span class="o">+</span> <span class="cm">/*etc*/</span>
</code></pre></div>
<p>Dans l&rsquo;histoire, bien que largement surmontable, getval est la fonction la plus compliquée. Si Pack est convertible en <code>T</code> alors <code>Get::get()</code> est utilisé, sinon <code>Default::get()</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">Pack</span><span class="o">&gt;</span>
<span class="kt">char</span> <span class="n">getval</span><span class="p">(</span><span class="n">Pack</span><span class="o">&amp;</span> <span class="n">pack</span><span class="p">,</span> <span class="kt">char</span> <span class="n">default_</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Get</span>     <span class="p">{</span> <span class="k">static</span> <span class="kt">char</span> <span class="n">get</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">,</span> <span class="kt">char</span>        <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">item</span><span class="p">.</span><span class="n">value</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
  <span class="k">struct</span> <span class="n">Default</span> <span class="p">{</span> <span class="k">static</span> <span class="kt">char</span> <span class="n">get</span><span class="p">(</span><span class="n">Pack</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">char</span> <span class="n">default_</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">default_</span><span class="p">;</span>   <span class="p">}</span> <span class="p">};</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">Pack</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">Get</span><span class="p">,</span> <span class="n">Default</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">pack</span><span class="p">,</span> <span class="n">default_</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2015/07/parametres-de-fonction-nommes-en-cpp/#aller-plus-loin"><h2 id="aller-plus-loin">Aller plus loin</h2></a>

<p>Les choses se compliquent quand on veut récupérer un type partiel. Un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">basic_fill</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</code></span> par exemple. Actuellement, rien n&rsquo;existe dans le standard et il faudra jouer avec les paramètres template template et un <a href="https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validite-dune-expression/">appel conditionnel de fonction selon la validité d&rsquo;une expression</a>.</p>

<p>Pour compléter la solution, il faudrait aussi prendre en compte les références et ajouter des contraintes sur le paramètre.</p>

<p>Pour continuer dans la voie des paramètres nommés, il existe <code>Boost.Parameters</code> et des variantes plus modernes telles que <a href="https://github.com/odinthenerd/parameter2">parameter2</a>.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2015-07-28T00:43:22">28 juillet 2015
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  <br/><a href="https://jonathanpoelen.github.io/2015/07/parametres-de-fonction-nommes-en-cpp/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="8df7f8d0192d9f86d50bcccdaace39c9-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=param%25C3%25A8tres-de-fonction-nomm%25C3%25A9s-en-c%2b%2b&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fparametres-de-fonction-nommes-en-cpp%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fparametres-de-fonction-nommes-en-cpp%2f&amp;title=param%25C3%25A8tres-de-fonction-nomm%25C3%25A9s-en-c%2b%2b" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fparametres-de-fonction-nommes-en-cpp%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fparametres-de-fonction-nommes-en-cpp%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fparametres-de-fonction-nommes-en-cpp%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fparametres-de-fonction-nommes-en-cpp%2f&amp;name=param%25C3%25A8tres-de-fonction-nomm%25C3%25A9s-en-c%2b%2b" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="impl%C3%A9mentation-dun-magasin-de-type"><span>
        <a href="#param%25C3%25A8tres-de-fonction-nomm%25C3%25A9s-en-c%2b%2b"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Paramètres de fonction nommés en C&#43;&#43;"></i></a>
        <a href="#appel-conditionnel-de-fonction-selon-la-validit%25C3%25A9-dune-expression"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Appel conditionnel de fonction selon la validité d&#39;une expression"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2015/07/implementation-dun-magasin-de-type/">Implémentation d&#39;un magasin de type</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#param%25C3%25A8tres-de-fonction-nomm%25C3%25A9s-en-c%2b%2b">Article suivant: Paramètres de fonction nommés en C&#43;&#43;</a><br/>
        <a href="#appel-conditionnel-de-fonction-selon-la-validit%25C3%25A9-dune-expression">Article précédent: Appel conditionnel de fonction selon la validité d&#39;une expression</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2015-07-02T01:49:41">02 juillet 2015
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>2 minutes ;
  <a href="https://jonathanpoelen.github.io/2015/07/implementation-dun-magasin-de-type/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#5a75c359eb88565795e71f25aa06a13b-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
      

<p>Ce que j&rsquo;appelle ici un magasin de type n&rsquo;est autre qu&rsquo;un <code>std::tuple</code> où les types ne sont présents qu&rsquo;une seule fois. Une espèce de set version tuple en somme.</p>

<p>Je me suis servi de ce type de structure à 2 reprises.</p>

<p>Une fois pour manipuler de façon similaire des types hétérogènes sans la lourdeur de <code>std::tuple</code>. Il faut dire aussi que j&rsquo;étais en C++11 et que dans cette norme <code>std::get&lt;Type&gt;()</code> n&rsquo;existe pas.</p>

<p>L&rsquo;autre fois dans une fonction variadique qui distribue les valeurs vers différentes fonctions. Le but étant de ne pas se soucier de l&rsquo;ordre des paramètres, certains étant optionnels.</p>

<p><code>std::tuple</code> fait plutôt bien le boulot, mais possède un énorme inconvénient pour ce cas de figure: aucune erreur de compilation si un type est présent 2 fois (et c&rsquo;est normal pour un tuple).</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2015/07/implementation-dun-magasin-de-type/#planter-la-compilation-quand-un-type-est-en-doublon"><h2 id="planter-la-compilation-quand-un-type-est-en-doublon">Planter la compilation quand un type est en doublon</h2></a>

<p>Le C++ dispose déjà d&rsquo;un mécanisme interne qui vérifie et hurle au scandale si un type doublon existe. J&rsquo;ai nommé l&rsquo;<strong>héritage</strong>.</p>

<p>Seulement, un héritage direct n&rsquo;est pas possible avec les types scalaires, il faut un intermédiaire.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">item</span> <span class="p">{</span> <span class="n">T</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nl">typeset</span> <span class="p">:</span> <span class="n">item</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">...</span> <span class="p">{};</span>
</code></pre></div>
<p>Avec cette implémentation, des petits malins pourraient faire de la pseudo-duplication de type en y ajoutant des qualificeurs, <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">typeset</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span><span class="o">&gt;</span>
</code></span> par exemple.</p>

<p>On peut être tolérant ou devenir un tyran sans pitié en empêchant cela.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">tyrannical_typeset_impl</span> <span class="p">:</span> <span class="n">typeset</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_cv_t</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">typeset</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">tyrannical_typeset</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">tyrannical_typeset_impl</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</code></pre></div>
<p>Le typeset tyrannique est construit en 2 étapes, car un alias direct sur un typeset épuré ne permet pas de garder les qualificatifs.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2015/07/implementation-dun-magasin-de-type/#piocher-dans-le-magasin"><h2 id="piocher-dans-le-magasin">Piocher dans le magasin</h2></a>

<p>Piquer un élément du typeset est une affaire de cast. Un simple <code>static_cast</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">typeset</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">my_typeset</span><span class="p">;</span>

<span class="k">static_cast</span><span class="o">&lt;</span><span class="n">item</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;&gt;</span><span class="p">(</span><span class="n">my_typeset</span><span class="p">).</span><span class="n">x</span><span class="p">;</span>
</code></pre></div>
<p>En mettant des opérateurs de cast dans la classe item, plus besoin de préciser cette dernière avec le <code>static_cast</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">item</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="k">operator</span> <span class="n">T</span><span class="o">&amp;</span> <span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">explicit</span> <span class="k">operator</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">T</span> <span class="n">x_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">typeset</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">my_typeset</span><span class="p">;</span>
<span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">my_typeset</span><span class="p">);</span>
</code></pre></div>
<p>Petit bémol toutefois, cela ne permet pas d&rsquo;enlever l&rsquo;ambiguïté pour un type qui diffère uniquement par son qualificatif.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">typeset</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="k">volatile</span><span class="o">&gt;</span> <span class="n">my_typeset</span><span class="p">;</span>

<span class="c1">// ‘typeset&lt;int, volatile int&gt;’ to ‘volatile int&amp;’ is ambiguous
</span><span class="c1"></span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">volatile</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">my_typeset</span><span class="p">);</span>
</code></pre></div>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2015/07/implementation-dun-magasin-de-type/#ce-qu-il-manque"><h2 id="ce-qu-il-manque">Ce qu&rsquo;il manque</h2></a>

<ul>
<li>Les constructeurs, évidemment.</li>
<li>Une fonction <code>get&lt;Type&gt;()</code> pour un parallèle avec la STL.</li>
<li>Une fonction pour boucler sur chaque item (<code>for_each</code> ?).</li>
<li>Et sûrement d&rsquo;autres.</li>
</ul>

<p>J&rsquo;ai mis tout ça dans un repo au nom provisoire <a href="https://github.com/jonathanpoelen/falcon.store">falcon.store</a>.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2015-07-02T01:49:41">02 juillet 2015
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  <br/><a href="https://jonathanpoelen.github.io/2015/07/implementation-dun-magasin-de-type/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="5a75c359eb88565795e71f25aa06a13b-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=impl%25C3%25A9mentation-dun-magasin-de-type&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fimplementation-dun-magasin-de-type%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fimplementation-dun-magasin-de-type%2f&amp;title=impl%25C3%25A9mentation-dun-magasin-de-type" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fimplementation-dun-magasin-de-type%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fimplementation-dun-magasin-de-type%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fimplementation-dun-magasin-de-type%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2015%2f07%2fimplementation-dun-magasin-de-type%2f&amp;name=impl%25C3%25A9mentation-dun-magasin-de-type" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="appel-conditionnel-de-fonction-selon-la-validit%C3%A9-dune-expression"><span>
        <a href="#impl%25C3%25A9mentation-dun-magasin-de-type"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Implémentation d&#39;un magasin de type"></i></a>
        <a href="#r%25C3%25A9duire-lempreinte-m%25C3%25A9moire-dune-agglom%25C3%25A9ration-de-types"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Réduire l&#39;empreinte mémoire d&#39;une agglomération de types"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validite-dune-expression/">Appel conditionnel de fonction selon la validité d&#39;une expression</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#impl%25C3%25A9mentation-dun-magasin-de-type">Article suivant: Implémentation d&#39;un magasin de type</a><br/>
        <a href="#r%25C3%25A9duire-lempreinte-m%25C3%25A9moire-dune-agglom%25C3%25A9ration-de-types">Article précédent: Réduire l&#39;empreinte mémoire d&#39;une agglomération de types</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2014-11-30T19:17:52">30 novembre 2014
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>3 minutes ;
  <a href="https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validite-dune-expression/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#57e6f719147f05d5387e0f69ae01609e-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
      

<p>L&rsquo;approche suivante consiste à vérifier qu&rsquo;une fonction (membre ou statique) est appelable dans le but de l&rsquo;utiliser, ou, à défaut, fournir implémentation générique. De manière plus générale, la méthode présentée ici s&rsquo;applique à toutes expressions.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validite-dune-expression/#appeler-t-sort-si-possible-sinon-std-sort-begin-t-end-t"><h2 id="appeler-t-sort-si-possible-sinon-std-sort-begin-t-end-t">Appeler T::sort si possible, sinon std::sort(begin(T), end(T))</h2></a>

<p>L&rsquo;exemple va se faire sur la classe <code>std::list</code> qui n&rsquo;est pas triable avec <code>std::sort</code>, mais possède une fonction membre <code>sort()</code>. Ainsi que sur <code>std::vector</code> qui, inversement, n&rsquo;a pas de fonction membre <code>sort()</code>, mais fonctionne avec <code>std::sort</code>.</p>

<p>La méthode est simple et consiste à créer 2 fonctions: une pour vérifier si une expression est valide (ici <code>x.sort()</code>) et une autre en cas d&rsquo;échec.</p>

<p>Seulement, qui dit 2 fonctions dit 2 prototypes. Leur prototype doit être légèrement différent mais compatible avec les mêmes valeurs d&rsquo;entrée pour appeler la seconde si la première échoue (principe du <a href="http://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a>).</p>

<p>Pour vérifier l&rsquo;expression, seuls 2 mots clef existent: <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span>
</code></span> et <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">decltype</span>
</code></span>. Cette procédure est donc possible avant C++11, même si <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span>
</code></span> requière un peu d&rsquo;enrobage.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">//avec decltype
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">Container</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">dispatch_sort</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
<span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">sort</span><span class="p">()))</span> <span class="c1">// force decltype au type void
</span><span class="c1"></span><span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">Container</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">dispatch_sort</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">Cont</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span> <span class="n">dispatch_sort</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div>
<p>La fonction <code>sort</code> appel <code>dispatch_sort</code> avec un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span>
</code></span> (la valeur n&rsquo;importe pas, seul le type compte). Comme la seule différence des 2 fonctions <code>dispatch_sort</code> est le premier paramètre, le prototype avec un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span>
</code></span> correspond parfaitement.</p>

<p>Si une fonction membre <code>sort</code> existe, alors l&rsquo;expression dans <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">decltype</span>
</code></span> est valide et la fonction appelé. Dans le cas contraire, le compilateur cherche une fonction avec des paramètres pouvant être compatibles. Le <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span>
</code></span> pouvant être converti en <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span>
</code></span>, le compilateur se rabat sur le second prototype qui fait appel à <code>std::sort</code>.</p>

<p>Le point clef étant de mettre toutes les informations dans le prototype. J&rsquo;aurais par exemple pu mettre <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">decltype</span>
</code></span> dans un paramètre initialisé avec une valeur par défaut (<span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></span>, mais il faudra probablement ajouter <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span>
</code></span> car un pointeur sur une référence n&rsquo;est pas permis).</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validite-dune-expression/#programme-de-test"><h2 id="programme-de-test">Programme de test</h2></a>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">});</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>   <span class="n">l</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">});</span>

  <span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">l</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Résultats:</p>

<div class="highlight"><pre class="chroma"><code>2 4 6
2 4 6
</code></pre></div>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validite-dune-expression/#implémentation-avec-sizeof-pre-c-11"><h2 id="implémentation-avec-sizeof-pre-c-11">implémentation avec sizeof (pre-C++11)</h2></a>

<p>J&rsquo;ai indiqué qu&rsquo;il été possible d&rsquo;utiliser <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span>
</code></span> à la place de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">decltype</span>
</code></span>. Voici comment:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">dispatch_result_type</span>
<span class="p">{</span> <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span> <span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">declval</span><span class="p">();</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">Container</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">dispatch_result_type</span><span class="o">&lt;</span>
  <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&amp;&gt;</span><span class="p">().</span><span class="n">sort</span><span class="p">()),</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;::</span><span class="n">type</span>
<span class="n">dispatch_sort</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span> <span class="p">}</span>
</code></pre></div>
<p>Le <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="p">,</span><span class="mi">1</span>
</code></span> de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span><span class="p">(</span><span class="n">xxx</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</code></span> peut dérouter mais est requis si l&rsquo;expression <code>xxx</code> retourne <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span>
</code></span>. Comme <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span>
</code></span> n&rsquo;est pas vraiment un type, il ne fonctionne pas avec <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span>
</code></span> et il faut donc lui fournir autre chose. Il faut bien comprendre qu&rsquo;ici <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">xxx</span><span class="p">,</span><span class="mi">1</span>
</code></span> est <strong>une seule</strong> expression et non pas 2 paramètres.</p>

<p>Bien que très peu probable, si j&rsquo;ai mis <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span><span class="p">(</span><span class="n">yyy</span><span class="p">)</span>
</code></span>, c&rsquo;est pour prévenir la surcharge de l&rsquo;opérator &lsquo;<code>,</code>&rsquo; sur le type de retour retourné par <code>yyy</code> (car cet opérateur peut lui-même retourner un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span>
</code></span>).</p>

<p><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span>
</code></span> ne donne pas l&rsquo;information sur le type de retour mais une valeur, il est couplé à <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">dispatch_result_type</span>
</code></span> qui prend en second paramètre template le type de retour (<span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span>
</code></span> par défaut). Quant à <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">declval</span>
</code></span>, c&rsquo;est le même principe que <a href="http://en.cppreference.com/w/cpp/utility/declval">celui de la SL</a>.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2014-11-30T19:17:52">30 novembre 2014
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  <br/><a href="https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validite-dune-expression/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="57e6f719147f05d5387e0f69ae01609e-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=appel-conditionnel-de-fonction-selon-la-validit%25C3%25A9-dune-expression&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f11%2fappel-conditionnel-de-fonction-selon-la-validite-dune-expression%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f11%2fappel-conditionnel-de-fonction-selon-la-validite-dune-expression%2f&amp;title=appel-conditionnel-de-fonction-selon-la-validit%25C3%25A9-dune-expression" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f11%2fappel-conditionnel-de-fonction-selon-la-validite-dune-expression%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f11%2fappel-conditionnel-de-fonction-selon-la-validite-dune-expression%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f11%2fappel-conditionnel-de-fonction-selon-la-validite-dune-expression%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f11%2fappel-conditionnel-de-fonction-selon-la-validite-dune-expression%2f&amp;name=appel-conditionnel-de-fonction-selon-la-validit%25C3%25A9-dune-expression" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="r%C3%A9duire-lempreinte-m%C3%A9moire-dune-agglom%C3%A9ration-de-types"><span>
        <a href="#appel-conditionnel-de-fonction-selon-la-validit%25C3%25A9-dune-expression"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Appel conditionnel de fonction selon la validité d&#39;une expression"></i></a>
        <a href="#256-couleurs-et-plus-dans-la-console"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: 256 couleurs et plus dans la console"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2014/06/reduire-lempreinte-memoire-dune-agglomeration-de-types/">Réduire l&#39;empreinte mémoire d&#39;une agglomération de types</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#appel-conditionnel-de-fonction-selon-la-validit%25C3%25A9-dune-expression">Article suivant: Appel conditionnel de fonction selon la validité d&#39;une expression</a><br/>
        <a href="#256-couleurs-et-plus-dans-la-console">Article précédent: 256 couleurs et plus dans la console</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2014-06-28T14:10:11">28 juin 2014
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>2 minutes ;
  <a href="https://jonathanpoelen.github.io/2014/06/reduire-lempreinte-memoire-dune-agglomeration-de-types/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#07d9fb6ce945d12ea3809b5709e32be9-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
      

<p>Un petit article pour parler d&rsquo;optimisation mémoire (si on peut appeler ça comme ça) avec comme exemple la structure de donnée utilisée par <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/06/reduire-lempreinte-memoire-dune-agglomeration-de-types/#implémentation-naïve-de-std-unique-ptr"><h2 id="implémentation-naïve-de-std-unique-ptr">Implémentation naïve de std::unique_ptr</h2></a>

<p>Pour rappel, <code>std::unique_ptr</code> prend 2 paramètres template: <code>T</code> et <code>Deleter</code> (qui par défaut égal <code>std::default_delete&lt;T&gt;</code>).</p>

<p>Naïvement, l&rsquo;implémentation serait:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Deleter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">default_delete</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">my_unique_ptr</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">m_pointer</span><span class="p">;</span>
  <span class="n">Deleter</span> <span class="n">m_deleter</span><span class="p">;</span>
  <span class="c1">// …
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>
<p>Rien d&rsquo;extraordinaire.</p>

<p>Cependant, même si <code>Deleter</code> est une classe sans attribut, sa taille est de 1 octet.</p>

<p>À partir d&rsquo;ici je considère que <code>Deleter</code> est toujours la valeur par défaut, ce qui donne:</p>

<ul>
<li><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span>
</code></span> == 8</li>
<li><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span><span class="p">(</span><span class="n">Deleter</span><span class="p">)</span>
</code></span> == 1</li>
<li><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span><span class="p">(</span><span class="n">my_unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
</code></span> == 16</li>
<li><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
</code></span> == 8</li>
</ul>

<p>Ouille, méchant padding, alors que seuls 8 octets sont vraiment utilisés.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/06/reduire-lempreinte-memoire-dune-agglomeration-de-types/#comment-fait-la-stl-pour-supprimer-8-octets"><h2 id="comment-fait-la-stl-pour-supprimer-8-octets">Comment fait la stl pour &laquo;&nbsp;supprimer&nbsp;&raquo; 8 octets ?</h2></a>

<p>La bibliohèque standard utilise une optimisation surnommée <a href="http://en.cppreference.com/w/cpp/language/ebo">Empty Base Class Optimization (EBCO)</a>.
Concrètement, cela se traduit par une classe interne qui contient le pointeur et hérite de <code>Deleter</code>. Les attributs de la classe dérivée vont se mettre après ceux de <code>Deleter</code>, et s&rsquo;il n&rsquo;en a pas, ils se positionnent au début de la classe. Grâce à cette astuce, l&rsquo;adresse du premier membre de la classe (ici, le pointeur) se confond avec celle de la classe englobante et parente, éliminant ainsi l&rsquo;espace occupé par <code>Deleter</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Deleter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">default_delete</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">my_unique_ptr</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nl">internal</span> <span class="p">:</span> <span class="n">Deleter</span> <span class="p">{</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">pointeur</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">m_data</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>
<ul>
<li><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">sizeof</span><span class="p">(</span><span class="n">my_unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
</code></span> == 8</li>
</ul>

<p>Mieux, non ?</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/06/reduire-lempreinte-memoire-dune-agglomeration-de-types/#et-si-l-héritage-n-est-pas-possible"><h2 id="et-si-l-héritage-n-est-pas-possible">Et si l&rsquo;héritage n&rsquo;est pas possible ?</h2></a>

<p>Si le Deleter est une référence ou une classe <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">final</span>
</code></span>, l&rsquo;héritage ne fonctionne pas. Il faut se rabattre sur la première forme (celle naïve).
Avec des traits et un code plus ou moins volumineux, cela est &laquo;&nbsp;facile&nbsp;&raquo;.
Il faut cependant noter que <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">is_final</span>
</code></span> n&rsquo;apparaît qu&rsquo;à partir de C++14 et son implémentation n&rsquo;est pas possible en pure C++.
Il faut à la place utiliser <code>__is_final</code> qui n&rsquo;est pas standard.</p>

<p>Toutefois, la stl possède un conteneur générique qui utilise l&rsquo;EBO si possible: <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span>
</code></span>. Ce qui permet de s&rsquo;affranchir de ces difficultés tout en optimisant l&rsquo;espace mémoire à condition de mettre les types dans l&rsquo;ordre croissant d&rsquo;alignement pour réduire le padding entre les membres lorsqu&rsquo;il y en a plus de 2.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2014-06-28T14:10:11">28 juin 2014
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  <br/><a href="https://jonathanpoelen.github.io/2014/06/reduire-lempreinte-memoire-dune-agglomeration-de-types/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="07d9fb6ce945d12ea3809b5709e32be9-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=r%25C3%25A9duire-lempreinte-m%25C3%25A9moire-dune-agglom%25C3%25A9ration-de-types&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2freduire-lempreinte-memoire-dune-agglomeration-de-types%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2freduire-lempreinte-memoire-dune-agglomeration-de-types%2f&amp;title=r%25C3%25A9duire-lempreinte-m%25C3%25A9moire-dune-agglom%25C3%25A9ration-de-types" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2freduire-lempreinte-memoire-dune-agglomeration-de-types%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2freduire-lempreinte-memoire-dune-agglomeration-de-types%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2freduire-lempreinte-memoire-dune-agglomeration-de-types%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2freduire-lempreinte-memoire-dune-agglomeration-de-types%2f&amp;name=r%25C3%25A9duire-lempreinte-m%25C3%25A9moire-dune-agglom%25C3%25A9ration-de-types" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="256-couleurs-et-plus-dans-la-console"><span>
        <a href="#r%25C3%25A9duire-lempreinte-m%25C3%25A9moire-dune-agglom%25C3%25A9ration-de-types"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Réduire l&#39;empreinte mémoire d&#39;une agglomération de types"></i></a>
        <a href="#valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-2%2f2"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Valeur, référence ou pointeur ? (2/2)"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/">256 couleurs et plus dans la console</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#r%25C3%25A9duire-lempreinte-m%25C3%25A9moire-dune-agglom%25C3%25A9ration-de-types">Article suivant: Réduire l&#39;empreinte mémoire d&#39;une agglomération de types</a><br/>
        <a href="#valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-2%2f2">Article précédent: Valeur, référence ou pointeur ? (2/2)</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2014-06-09T00:35:19">09 juin 2014
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/script-shell" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>script-shell</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>3 minutes ;
  <a href="https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#e9e58638f018ab82631069e0fc453885-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
      

<p>À chaque fois que je cherche des infos sur les couleurs je tombe toujours sur les trucs basiques. Mais j&rsquo;ai récemment appris l&rsquo;existence de 256 couleurs dans la console en tombant sur <a href="http://dotshare.it/dots/100/">un screen</a> un peu trop coloré. Ce qui m&rsquo;a dirigé sur un <a href="https://github.com/trapd00r/LS_COLORS">dépôt contenant un $LS_COLORS</a> particulièrement fourni.</p>

<p>En fait, il s&rsquo;avère qu&rsquo;en rajoutant extended dans la recherche &laquo;&nbsp;color shell&nbsp;&raquo; on puisse trouver <a href="http://misc.flogisoft.com/bash/tip_colors_and_formatting">quelque(s) ressource(s)</a>. J&rsquo;aurais bien voulu y penser la semaine dernière, ça m&rsquo;aurait évité de comprendre par tâtonnement&hellip;</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/#utilisation"><h2 id="utilisation">Utilisation</h2></a>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="s2">&#34;\e[</span><span class="si">${</span><span class="nv">FormatColor</span><span class="si">}</span><span class="s2">m&#34;</span></code></pre></div>
<p>Le caractère <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="se">\e</span></code></span> correspond à la touche Esc (échap). On peut aussi l&rsquo;écrire en hexadécimal <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="se">\x</span>1B</code></span> ou en octal <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="se">\0</span><span class="m">33</span></code></span>.</p>

<p>Pour bash et <code>echo</code>, il faut utiliser l&rsquo;option <code>-e</code> pour interpréter les séquences backslashés.</p>

<p><span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="si">${</span><span class="nv">FormatColor</span><span class="si">}</span></code></span> correspond à un nombre représentant une couleur de texte, de fond ou un effet. Plusieurs formats peuvent être mis en les séparant par des <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="p">;</span></code></span> (point virgule). L&rsquo;ordre n&rsquo;a pas d&rsquo;importance.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/#8-couleurs"><h2 id="8-couleurs">8 couleurs</h2></a>

<p>C&rsquo;est le mode de couleur supporté par la majorité des terminaux. La valeur des couleurs peut également être configurée.</p>

<table>
<thead>
<tr>
<th>Couleur</th>
<th>Texte</th>
<th>Fond</th>
</tr>
</thead>

<tbody>
<tr>
<td>Noir</td>
<td>30</td>
<td>40</td>
</tr>

<tr>
<td>Rouge</td>
<td>31</td>
<td>41</td>
</tr>

<tr>
<td>Vert</td>
<td>32</td>
<td>42</td>
</tr>

<tr>
<td>Jaune</td>
<td>33</td>
<td>43</td>
</tr>

<tr>
<td>Bleu</td>
<td>34</td>
<td>44</td>
</tr>

<tr>
<td>Magenta</td>
<td>35</td>
<td>45</td>
</tr>

<tr>
<td>Cyan</td>
<td>36</td>
<td>46</td>
</tr>

<tr>
<td>Gris clair</td>
<td>37</td>
<td>47</td>
</tr>
</tbody>
</table>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/#style-effet-de-texte"><h2 id="style-effet-de-texte">Style/effet de texte</h2></a>

<p>L&rsquo;italique (3) n&rsquo;est pas répertorié dans le lien précédemment cité. Aussi, l&rsquo;effet sombre (ou dim) et mode caché ne fonctionnent pas partout. Il n&rsquo;existe pas de code 6.</p>

<table>
<thead>
<tr>
<th>Effet</th>
<th>Code</th>
<th>Code annulation</th>
</tr>
</thead>

<tbody>
<tr>
<td>normal</td>
<td>0</td>
<td></td>
</tr>

<tr>
<td>gras</td>
<td>1</td>
<td>21</td>
</tr>

<tr>
<td>sombre</td>
<td>2</td>
<td>22</td>
</tr>

<tr>
<td>italique</td>
<td>3</td>
<td>23</td>
</tr>

<tr>
<td>souligné</td>
<td>4</td>
<td>24</td>
</tr>

<tr>
<td>clignotant</td>
<td>5</td>
<td>25</td>
</tr>

<tr>
<td>inversé</td>
<td>7</td>
<td>27</td>
</tr>

<tr>
<td>caché</td>
<td>8</td>
<td>28</td>
</tr>
</tbody>
</table>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/#16-couleurs"><h2 id="16-couleurs">16 couleurs</h2></a>

<p>Ce sont 8 couleurs supplémentaires accessibles pour certains terminaux.</p>

<table>
<thead>
<tr>
<th>Couleur</th>
<th>Texte</th>
<th>Fond</th>
</tr>
</thead>

<tbody>
<tr>
<td>Gris foncé</td>
<td>90</td>
<td>100</td>
</tr>

<tr>
<td>Rouge clair</td>
<td>91</td>
<td>101</td>
</tr>

<tr>
<td>Vert clair</td>
<td>92</td>
<td>102</td>
</tr>

<tr>
<td>Jaune clair</td>
<td>93</td>
<td>103</td>
</tr>

<tr>
<td>Bleu clair</td>
<td>94</td>
<td>104</td>
</tr>

<tr>
<td>Magenta clair</td>
<td>95</td>
<td>105</td>
</tr>

<tr>
<td>Cyan clair</td>
<td>96</td>
<td>106</td>
</tr>

<tr>
<td>Blanc</td>
<td>97</td>
<td>107</td>
</tr>
</tbody>
</table>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/#88-et-256-couleurs"><h2 id="88-et-256-couleurs">88 et 256 couleurs</h2></a>

<p>C&rsquo;est un mode étendue, certains vieux terminaux limitent à 88 couleurs, mais la plupart en supportent 256. Il s&rsquo;utilise avec le triplet suivant:</p>

<ul>
<li>Texte: <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="m">38</span><span class="p">;</span><span class="m">5</span><span class="p">;</span><span class="si">${</span><span class="nv">x</span><span class="si">}</span></code></span></li>
<li>Fond: <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="m">48</span><span class="p">;</span><span class="m">5</span><span class="p">;</span><span class="si">${</span><span class="nv">x</span><span class="si">}</span></code></span></li>
</ul>

<p>Dont <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="si">${</span><span class="nv">x</span><span class="si">}</span></code></span> est à remplacer par un nombre allant de 0 à 255 inclus.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/#truecolor"><h2 id="truecolor">TrueColor</h2></a>

<p>Il est possible d&rsquo;utiliser le classique RGB quand le terminal le permet. Beaucoup d&rsquo;interfaces consoles ne le prennent pas bien en charge ou ne le détectent pas. Pour la seconde catégorie, il faut généralement activer une option.</p>

<ul>
<li>Texte: <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="m">38</span><span class="p">;</span><span class="m">2</span><span class="p">;</span><span class="si">${</span><span class="nv">r</span><span class="si">}</span><span class="p">;</span><span class="si">${</span><span class="nv">g</span><span class="si">}</span><span class="p">;</span><span class="si">${</span><span class="nv">b</span><span class="si">}</span></code></span></li>
<li>Fond: <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="m">48</span><span class="p">;</span><span class="m">2</span><span class="p">;</span><span class="si">${</span><span class="nv">r</span><span class="si">}</span><span class="p">;</span><span class="si">${</span><span class="nv">g</span><span class="si">}</span><span class="p">;</span><span class="si">${</span><span class="nv">b</span><span class="si">}</span></code></span></li>
</ul>

<p>Dont <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="si">${</span><span class="nv">r</span><span class="si">}</span></code></span>, <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="si">${</span><span class="nv">g</span><span class="si">}</span></code></span> et <span class="inlinecode highlight"><code class="language-sh" data-lang="sh"><span class="si">${</span><span class="nv">b</span><span class="si">}</span></code></span> sont à remplacer par un nombre allant de 0 à 255 inclus.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/#notes-de-fin"><h2 id="notes-de-fin">Notes de fin</h2></a>

<p>Outre le fait que TrueColor et les couleurs étendues ne fonctionnent pas partout, elles peuvent allègrement pourrir le rendu. Pour retrouver un rendu normal utiser <code>tput reset</code>.</p>

<p>Le bout de code ci-dessous permet de visualiser une palette de 256 couleurs.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="k">for</span> m in <span class="m">38</span> <span class="m">48</span> <span class="p">;</span> <span class="k">do</span>
  <span class="nv">n</span><span class="o">=</span><span class="m">0</span>
  <span class="k">for</span> l in <span class="o">{</span><span class="m">0</span>..31<span class="o">}</span> <span class="p">;</span> <span class="k">do</span>
    <span class="k">for</span> c in <span class="o">{</span><span class="m">0</span>..7<span class="o">}</span> <span class="p">;</span> <span class="k">do</span>
      <span class="nb">echo</span> -ne <span class="s2">&#34;\033[</span><span class="nv">$m</span><span class="s2">;5;</span><span class="nv">$n</span><span class="s2">;1m</span><span class="nv">$n</span><span class="s2">\e[0m\t&#34;</span>
      <span class="o">((</span>++n<span class="o">))</span>
    <span class="k">done</span>
    <span class="nb">echo</span>
  <span class="k">done</span>
<span class="k">done</span></code></pre></div>
  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2014-06-09T00:35:19">09 juin 2014
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/script-shell" rel="category">script-shell</a>
 ;
  

  <br/><a href="https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="e9e58638f018ab82631069e0fc453885-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=256-couleurs-et-plus-dans-la-console&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2f256-couleurs-et-plus-dans-la-console%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2f256-couleurs-et-plus-dans-la-console%2f&amp;title=256-couleurs-et-plus-dans-la-console" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2f256-couleurs-et-plus-dans-la-console%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2f256-couleurs-et-plus-dans-la-console%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2f256-couleurs-et-plus-dans-la-console%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f06%2f256-couleurs-et-plus-dans-la-console%2f&amp;name=256-couleurs-et-plus-dans-la-console" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="valeur-r%C3%A9f%C3%A9rence-ou-pointeur-2/2"><span>
        <a href="#256-couleurs-et-plus-dans-la-console"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: 256 couleurs et plus dans la console"></i></a>
        <a href="#valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-1%2f2"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Valeur, référence ou pointeur ? (1/2)"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-2-sur-2/">Valeur, référence ou pointeur ? (2/2)</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#256-couleurs-et-plus-dans-la-console">Article suivant: 256 couleurs et plus dans la console</a><br/>
        <a href="#valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-1%2f2">Article précédent: Valeur, référence ou pointeur ? (1/2)</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2014-05-31T21:18:10">31 mai 2014
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>3 minutes ;
  <a href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-2-sur-2/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#10ed39526a7913e7e5ec22dcf3e6f161-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
      

<p>Dans le <a href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/">précédent billet</a>, j&rsquo;opposai les paramètres par références constantes à ceux par valeurs.</p>

<p>Sans plus attendre entamons la seconde question.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-2-sur-2/#référence-ou-pointeur"><h2 id="référence-ou-pointeur">Référence ou pointeur ?</h2></a>

<p>Si je dois faire court je dirai: pointeur jamais ; référence quand possible. Sans autre forme de procès :D</p>

<p>Mais on me dit dans l&rsquo;oreillette qu&rsquo;il faut argumenter&hellip; Alors c&rsquo;est parti.</p>

<p>Les références possèdent un contrat beaucoup plus fort que les pointeurs: elles ne peuvent être nulles et référencent toujours la même variable.</p>

<p>À contrario, les pointeurs peuvent changer la variable référencée ou ne pointer sur aucune variable (<a href="http://en.cppreference.com/w/cpp/types/nullptr_t">nullptr</a>).</p>

<p>Une référence est l&rsquo;équivalent d&rsquo;un pointeur constant non-nul (avec une syntaxe d&rsquo;utilisation plus simple: pas besoin de déréférencer).
De leurs restrictions, celles-ci ne peuvent pas toujours correspondre au besoin ; les pointeurs sont alors envisageables.</p>

<p>De plus, les pointeurs sont beaucoup utilisés dans les constructions dynamiques (allocation dynamique) quand les classes sont à <a href="http://blog.emmanueldeloget.com/index.php?post/2011/11/18/Standard-C11-%3A-la-s%C3%A9mantique-de-d%C3%A9placement">sémantique d&rsquo;entités</a>. Principalement car ces dernières ne sont pas copiables et que l&rsquo;allocation dynamique permet de s&rsquo;affranchir de la portée (le scope) en se détachant de la pile.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-2-sur-2/#le-pointeur-parle-trop"><h2 id="le-pointeur-parle-trop">Le pointeur parle trop</h2></a>

<p>L&rsquo;usage de pointeur (pointeur nu) est cependant à prendre avec des pincettes, voici 3 questions que soulève l&rsquo;usage d&rsquo;un pointeur:</p>

<ul>
<li>Dois-je contrôler la durée de vie du pointeur (le détruire) ? [oui, non]</li>
<li>Est-ce un élément ou une séquence d&rsquo;élément ? [séquence, simple valeur, ça dépend]</li>
<li>Le pointeur peut-il être nul ? [oui, non]</li>
</ul>

<p>Après un petit calcul combinatoire (2*3*2), il y a 12 réponses possibles. Le pire est de répondre: &laquo;&nbsp;ça dépend&nbsp;&raquo;. Si on l&rsquo;enlève, il reste quand même 8 possibilités.</p>

<p>La sémantique du pointeur est, au final, très faible. Lui en ajouter devient alors capital.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-2-sur-2/#plus-de-sémantique-pour-un-pointeur"><h2 id="plus-de-sémantique-pour-un-pointeur">Plus de sémantique pour un pointeur</h2></a>

<p>Hélas, il n&rsquo;y a pas de réponse universelle, tout dépend des cas d&rsquo;usages. De plus certaines combinaisons son conceptuellement douteuses.
Pour exemple, un pointeur non-nul mais qu&rsquo;on détruira. Le non-nul amène aux références mais idéologiquement une référence n&rsquo;est pas faite pour être détruite.</p>

<p>On peut néanmoins sortir quelques règles:</p>

<ul>
<li>Si le pointeur n&rsquo;est pas nul et que l&rsquo;appelé ne gère pas la durée de vie: <code>std::reference_wrapper</code> qui permet de changer la référence utilisée.</li>
<li>Si l&rsquo;appelé contrôle la durée de vie: pointeurs intelligents (<code>std::unique_ptr</code> en priorité, <code>std::shared_ptr</code>, &hellip;).</li>
<li>Si le pointeur peut être nul et que l&rsquo;appelé ne gère pas la durée de vie alors un pointeur est &laquo;&nbsp;justifié&nbsp;&raquo;. En interne du moins, pour l&rsquo;extérieur un <code>non_owner_ptr</code> ou un <code>observer_ptr</code> sera plus parlant. Si le pointeur peut être invalidé pendant l&rsquo;exécution alors <code>std::weak_ptr</code> ou autres est à envisager.</li>
<li>Tout ce qui est tableau est indiqué dans les signatures des objets wrapper (<code>unique_ptr&lt;T[]&gt;</code>) ou/et grâce à un attribut de taille. De plus, s&rsquo;il faut soit des tableaux, soit une valeur alors toujours préférer le type commun: tableau (les valeurs deviennent des tableaux de taille 1). Les tableaux dynamiques sont, quant à eux, plus faciles à utiliser avec <code>std::vector</code>.</li>
</ul>

<p>Au final, l&rsquo;usage de pointeur nu est très peu utilisé, voire pas du tout. De plus, leur mauvais usage avec l&rsquo;allocation dynamique amène des fuites mémoires principalement dues aux libérations manuelles. Dans un langage comme le C++, un code non exception safe <strong>va</strong> faire des fuites mémoires. De manière générale, la libération s&rsquo;applique sur toute forme de ressource: lock, fichier, etc.</p>

<p>Pour éviter cela, les ressources doivent être attachées à la pile et la puissance du déterminisme de destruction permettra de les libérer convenablement. On parle aussi de <a href="http://fr.wikipedia.org/wiki/RAII">RAII</a>. Pour rappel, tout ce qui est sur la pile est détruit à la sortie du scope. La sémantique de déplacement permettra de changer de portée.</p>

<p>Le wiki de Guillaume Belz en parle très bien: <a href="http://guillaume.belz.free.fr/doku.php?id=pourquoi_le_raii_est_fondamental_en_c">pourquoi le RAII est fondamental en C++ ?</a></p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2014-05-31T21:18:10">31 mai 2014
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  <br/><a href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-2-sur-2/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="10ed39526a7913e7e5ec22dcf3e6f161-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-2%2f2&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-2-sur-2%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-2-sur-2%2f&amp;title=valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-2%2f2" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-2-sur-2%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-2-sur-2%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-2-sur-2%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-2-sur-2%2f&amp;name=valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-2%2f2" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="valeur-r%C3%A9f%C3%A9rence-ou-pointeur-1/2"><span>
        <a href="#valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-2%2f2"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Valeur, référence ou pointeur ? (2/2)"></i></a>
        <a href="#parcourir-les-arguments-dune-fonction-variadique"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Parcourir les arguments d&#39;une fonction variadique"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/">Valeur, référence ou pointeur ? (1/2)</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-2%2f2">Article suivant: Valeur, référence ou pointeur ? (2/2)</a><br/>
        <a href="#parcourir-les-arguments-dune-fonction-variadique">Article précédent: Parcourir les arguments d&#39;une fonction variadique</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2014-05-22T09:51:53">22 mai 2014
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>8 minutes ;
  <a href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#cb482643e61989560b2b661ad7a5d670-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
      

<blockquote>
<p>Quand utiliser une variable par valeur, référence ou pointeur ?</p>
</blockquote>

<p>Telle fut la question qui m&rsquo;a été posée :p.</p>

<p>Comme je ne suis pas entièrement satisfait de la réponse que j&rsquo;ai donné, je fais un article. Pour tout dire, la réponse n&rsquo;est pas aussi triviale que l&rsquo;on pourrait le croire depuis l&rsquo;arrivée du C++11 et la sémantique de déplacement.</p>

<p>Tout d&rsquo;abord, décomposons cette question en 2 parties:</p>

<ul>
<li>Valeur ou référence constante ?</li>
<li>Référence ou pointeur ?</li>
</ul>

<p>Je réponds ici à la première, la seconde fera l&rsquo;objet d&rsquo;un autre article.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/#valeur-ou-référence-constante"><h2 id="valeur-ou-référence-constante">Valeur ou référence constante ?</h2></a>

<p>Le choix se justifie en majorité par un besoin d&rsquo;optimisation. Une prise par valeur induit forcément une copie, cette dernière pouvant être extrêmement coûteuse. Par exemple, la copie d&rsquo;un <code>std::vector</code> ne se fait pas en un claquement de doigt, il y a tout un attirail derrière: allouer un espace mémoire et copier tous les éléments du vecteur précédent qui peuvent eux-mêmes faire des opérations complexes.</p>

<p>À contrario, la référence constante est un alias vers une variable. Il n&rsquo;y a jamais de copie.</p>

<p>J&rsquo;insiste bien sur référence <strong>constante</strong> car, pour être au plus proche de l&rsquo;effet d&rsquo;une copie, l&rsquo;objet d&rsquo;origine ne doit pas bouger. De plus, une instance constante ne peut appeler que des fonction membre constantes, ce qui assure une invariance (cf: const-correctness).</p>

<p>Donc, référence constante pour les valeurs qui ne sont pas modifiés dans la fonction. Une règle dit: &laquo;&nbsp;tout ce qui est plus grand qu&rsquo;un pointeur pourrait être passé par référence constante&nbsp;&raquo;. Je préfère dire tous les types en référence constante sauf les <a href="http://en.cppreference.com/w/cpp/language/types">fondamentaux</a> (int, float, etc). Même si mettre une référence constante sur un <code>int</code> n&rsquo;est pas une erreur, je n&rsquo;adhère pas vraiment.</p>

<p>Une seule exception cependant, quand le paramètre va de toute façon être copié localement dans la fonction pour être modifié. On pourrait croire que le résultat sera le même, mais c&rsquo;est être naïf.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">BigInt</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>
<span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">BigInt</span> <span class="n">ret</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Supposons que BigInt fasse de l&rsquo;allocation dynamique pour représenter les nombres. Avec ce code:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">BigInt</span> <span class="nf">n1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">BigInt</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">BigInt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">n1</span><span class="p">;</span>
</code></pre></div>
<p>Il y a 3 allocations:</p>

<ul>
<li>n1</li>
<li>BigInt(2)</li>
<li>ret</li>
</ul>

<p>Alors que cette implémentation de <code>operator+</code> n&rsquo;en produit que 2.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">BigInt</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Car il y a <a href="http://en.cppreference.com/w/cpp/language/copy_elision">copy elision</a> (c&rsquo;est le même principe que la RVO mais pour les paramètres). (Voir aussi <a href="http://cpp.developpez.com/actu/53711/Operateur-d-affectation-copie-implicite-ou-explicite/">ici et la réponse de Flob90</a>.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/#mais-ça-c-était-avant"><h2 id="mais-ça-c-était-avant">Mais ça c&rsquo;était avant&hellip;</h2></a>

<p>Maintenant qu&rsquo;il y a la <a href="http://h-deb.clg.qc.ca/Sujets/Divers--cplusplus/Mouvement.html">sémantique de déplacement</a>, les copies sont préférées quand une fonction recevant le paramètre va, quoi qu&rsquo;il arrive, le copier dans une variable membre. Premièrement parce que l&rsquo;utilisateur pourra faire un <code>std::move</code> de sa variable pour s&rsquo;en &laquo;&nbsp;débarrasser&nbsp;&raquo; car il n&rsquo;en a plus besoin. Deuxièmement parce que la fonction a besoin d&rsquo;une copie et le compilateur le fera pour nous.</p>

<p>En comparaison avec une copie sur le <code>std::vector</code>, le move-constructor et le move-assignment sont extrêmement rapide: 3 affections de pointeur pour chaque vecteur.</p>

<p>Par exemple avec cette base:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="n">vector_int_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">A</span> <span class="p">{</span>
  <span class="n">vector_int_t</span> <span class="n">c</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">A</span><span class="p">(</span><span class="n">vector_int_t</span> <span class="n">cont</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">cont</span><span class="p">))</span>
  <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div>
<p>Le code suivant fait 2 allocations (comme avec les références constantes)</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector_int_t</span> <span class="n">c</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="n">A</span> <span class="nf">a</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</code></pre></div>
<p>Alors que celui-ci qu&rsquo;une seule</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector_int_t</span> <span class="n">c</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="n">A</span> <span class="nf">a</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
<span class="c1">// c.size() == 0;
</span><span class="c1"></span></code></pre></div>
<p>Et ce dernier aussi</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">A</span><span class="p">(</span><span class="n">vector_int_t</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">});</span>
<span class="c1">// ou A({1 ,2});
</span><span class="c1"></span></code></pre></div>
<p>Mais si le type ne possède pas de constructeur de déplacement, celui de copie sera utilisé et alors une référence constante est probablement mieux.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/#quand-la-copie-se-fait-sous-condition"><h2 id="quand-la-copie-se-fait-sous-condition">Quand la copie se fait sous condition</h2></a>

<p>Il existe des paramètres pouvant être copiés, mais pas toujours. Dans ce cas, bien que la référence constante reste une bonne solution, une version prenant aussi une temporaire (rvalue ici) est probablement mieux. Mais si les types ne sont pas abstraits (comprendre full template) alors il faudra faire 2 versions: une avec rvalue et une avec constref. Ce qui se traduit, quand le code est un peu long, par l&rsquo;ajout d&rsquo;une fonction de prédicat ou une version template privée appelé par les 2 autres.</p>

<p>Les <code>&amp;&amp;</code> sur les types full templates ont 2 états possibles: rvalue ou lvalue (<a href="http://en.cppreference.com/w/cpp/language/value_category">catégorie de valeurs</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">privfoo</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">privfoo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">));</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">String</span><span class="o">&gt;</span>
  <span class="c1">// ici &amp;&amp; représente soit rvalue, soit une référence (constante)
</span><span class="c1"></span>  <span class="kt">void</span> <span class="n">privfoo</span><span class="p">(</span><span class="n">String</span><span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// …
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">xyz</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// soit un move-assignment soit un copy-assignment
</span><span class="c1"></span>      <span class="n">str</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>Ou</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Bar</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="n">str</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">check</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// …
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">xyz</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/#prise-d-objet-non-copiable-sous-condition"><h2 id="prise-d-objet-non-copiable-sous-condition">Prise d&rsquo;objet non-copiable sous condition</h2></a>

<p>Par exemple, donner la propriété d&rsquo;un <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> à une classe selon certains prérequis décidés par une fonction. Contrainte supplémentaire, l&rsquo;objet n&rsquo;est pas copiable.</p>

<ul>
<li>Une référence constante n&rsquo;est pas envisageable, l&rsquo;objet ne pouvant pas être déplacé car constant.</li>
<li>Une prise par valeur non plus (grâce à std::move), car la ressource serait systématiquement transmise à la fonction même si cette dernière ne la garde pas. L&rsquo;appelant est dans l&rsquo;incapacité de le savoir et perd la ressource.</li>
<li>Une référence non-constante est possible, mais il ne sera alors pas possible d&rsquo;envoyer un temporaire. Il faudra obligatoirement passer par une variable intermédiaire ce qui est désagréable quand on ne va rien en faire.</li>
<li>Reste la rvalue avec laquelle une temporaire fonctionne, mais il faudra automatiquement faire un std::move quand la variable est une référence. Cela a l&rsquo;avantage d&rsquo;informer l&rsquo;utilisateur sur l&rsquo;éventuel déplacement de ressource.</li>
</ul>

<p>Au final, bien qu&rsquo;une référence fonctionne, seule une rvalue est pratique à l&rsquo;usage. Seulement, aucunes de ces méthodes n&rsquo;indiquent une prise partielle, seule la documentation nous le dira. Ceci pourrait par contre être une convention d&rsquo;écriture: si une ressource non copiable est prise par rvalue, alors la fonction est libre de se l&rsquo;approprier quand certaines conditions internes sont remplies.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/#quand-les-opérations-ne-sont-pas-connues"><h2 id="quand-les-opérations-ne-sont-pas-connues">Quand les opérations ne sont pas connues</h2></a>

<p>Reste la dernière situation: les templates. Les règles sont les mêmes qu&rsquo;avant mais si le rôle du paramètre n&rsquo;est pas défini (comprendre la fonction ne fait rien d&rsquo;autre qu&rsquo;envoyer le paramètre à une autre fonction ou que le qualifier importe peu) les paramètres sont à prendre par référence universelle (<code>T&amp;&amp;</code> pour les template). À ce moment, toutes les utilisations de cette variable devraient se faire par l&rsquo;intermédiaire de <a href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a>, même lorsqu&rsquo;une fonction membre est utilisées (la faute au <a href="http://en.cppreference.com/w/cpp/language/member_functions#const-.2C_volatile-.2C_and_ref-qualified_member_functions">qualificateur de référence sur fonction membre</a>.</p>

<p>Toutefois, attention de ne pas déléguer plusieurs fois la responsabilité et de ne faire std::forward (et std::move) que sur la dernière utilisation de la variable.</p>

<p>Cependant, certains objets de par leur concept seront pris par valeur. Comme les itérateurs pour la bonne raison que leurs états changent dans l&rsquo;execution de la fonction. On peut toutefois prendre l&rsquo;itérateur de fin par référence constante s&rsquo;il n&rsquo;est pas modifié.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/#pas-de-référence-constante-pour-les-observers"><h2 id="pas-de-référence-constante-pour-les-observers">Pas de référence constante pour les observers</h2></a>

<p>Bien que cela sorte du cadre de la question d&rsquo;origine, il ne faut pas prendre par référence constante une valeur à observer.</p>

<p>J&rsquo;entends par observer les variables qui sont gardées en lecture dans le but de vérifier leur état à un instant t.</p>

<p>Les références constantes peuvent être des temporaires à leur construction (Jusque-là c&rsquo;est défini par la norme: prolongement de la durée de vie d&rsquo;une temporaire). Le problème vient du déplacement vers un scope parent. La valeur temporaire est détruite, mais la référence est gardée ; référence sur une valeur qui n&rsquo;existe plus. Cela débouche sur un comportement indéfini et, dans le meilleurs des cas, un segfault.</p>

<p><a href="http://blog.developpez.com/gpu/?p=309">Un article qui présente une situation similaire avec une lambda retournant T à travers std::function&lt;const T&amp;&gt;.</a></p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">Validate</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">display</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">Validate</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span> <span class="k">return</span> <span class="p">{</span><span class="s">&#34;plop&#34;</span><span class="p">};</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Validate</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>
  <span class="n">x</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>(Moi j&rsquo;ai un segfault)</p>

<p>Pour limiter ce bug, il faut empêcher de prendre une rvalue. Soit avec les constucteurs suivants:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Validate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">delete</span><span class="p">;</span>
<span class="n">Validate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span><span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">){}</span>
</code></pre></div>
<p>Soit en utilisant <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper">std::reference_wrapper</a> (et <a href="http://en.cppreference.com/w/cpp/utility/functional/ref">std::cref</a>).</p>

<p>Ou, peut-être mieux, faire un objet <code>observable</code> tout pareil que <code>std::reference_wrapper</code>, mais avec constructeur explicite. L&rsquo;intérêt d&rsquo;utiliser l&rsquo;un des 2 objets cités et de focaliser l&rsquo;utilisateur sur l&rsquo;aspect &laquo;&nbsp;j&rsquo;ai besoin que cette variable vive au moins aussi longtemps que moi&nbsp;&raquo;.</p>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/#résumé"><h2 id="résumé">Résumé</h2></a>

<ul>
<li>Valeur pour les types fondamentaux (int, double, etc), ceux modifiés sans que l&rsquo;utilisateur n&rsquo;ai besoin de le savoir (ex: itérateurs ou premier paramètre de l&rsquo;opérateur &lsquo;+&rsquo;) ou les foncteur sans états (prédicats, comparateurs, &hellip;).</li>
<li>Valeur + std::move quand l&rsquo;objet peut être déplacé (possède un move-ctor ou/et move-assign non trivial (ex: std::string, std::vector, &hellip;).</li>
<li>Valeur pour les ressources non copiables à transférer (std::unique_ptr, &hellip;).</li>
<li>Référence constante pour les paramètres en lecture seule ou ne disposant pas de move-ctor ou/et move-assign non trivial.</li>
<li>Référence constante et rvalue quand le paramètre <em>peut être</em> copié et possède un move-ctor/move-assign non trivial.</li>
<li>Rvalue pour les ressources non copiables avec déplacement conditionnel (std::unique_ptr, &hellip;).</li>
<li>Référence constante pour les types inconnus (template) qui n&rsquo;ont pas d&rsquo;intérêt à être pris par valeur (ou au pire, stratégie variable selon le résultat de std::is<em>trivially</em><em>/std::is<em>copy</em></em>/std::is<em>move</em>*).</li>
<li>Rvalue pour les types inconnus (template) quand le paramètre n&rsquo;a pas de rôle direct dans la fonction ou que le qualificateur n&rsquo;importe pas (ne pas oublier std::forward pour le transmettre à une autre fonction (seulement s&rsquo;il n&rsquo;est plus utilisé ensuite)).</li>
</ul>

<p><a href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-2-sur-2/">Partie 2</a></p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2014-05-22T09:51:53">22 mai 2014
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  <br/><a href="https://jonathanpoelen.github.io/2014/05/valeur-reference-ou-pointeur-1-sur-2/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="cb482643e61989560b2b661ad7a5d670-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-1%2f2&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-1-sur-2%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-1-sur-2%2f&amp;title=valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-1%2f2" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-1-sur-2%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-1-sur-2%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-1-sur-2%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2014%2f05%2fvaleur-reference-ou-pointeur-1-sur-2%2f&amp;name=valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-1%2f2" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="parcourir-les-arguments-dune-fonction-variadique"><span>
        <a href="#valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-1%2f2"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Valeur, référence ou pointeur ? (1/2)"></i></a>
        <a href="#tableau-dans-un-stdvector"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Tableau dans un std::vector"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2013/12/parcourir-les-arguments-dune-fonction-variadique/">Parcourir les arguments d&#39;une fonction variadique</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#valeur-r%25C3%25A9f%25C3%25A9rence-ou-pointeur-1%2f2">Article suivant: Valeur, référence ou pointeur ? (1/2)</a><br/>
        <a href="#tableau-dans-un-stdvector">Article précédent: Tableau dans un std::vector</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2013-12-22T10:03:06">22 décembre 2013
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>2 minutes ;
  <a href="https://jonathanpoelen.github.io/2013/12/parcourir-les-arguments-dune-fonction-variadique/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#0881f74fb66a84dee026002282b8e65d-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
      

<p>À l&rsquo;approche de Noël et du déballage de cadeaux, faisons un tour sur le déballage des paramètres variadiques.</p>

<div class="InfoBox"><p><strong class="InfoBox-title">Info :</strong> Ce qui suit n&rsquo;est plus d&rsquo;actualité depuis C++17 et les <a href="https://en.cppreference.com/w/cpp/language/fold">expressions fold</a>.</p></div>


<a class="headline-hash" href="https://jonathanpoelen.github.io/2013/12/parcourir-les-arguments-dune-fonction-variadique/#fonction-récursive"><h2 id="fonction-récursive">Fonction récursive</h2></a>

<p>La méthode habituelle pour utiliser chaque paramètre est la récursion jusqu&rsquo;à plus d&rsquo;argument ou jusqu&rsquo;à un nombre défini, généralement 1.</p>

<p>Quelque chose dans ce goût-là:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">f1</span><span class="p">()</span>
<span class="p">{}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">others</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
  <span class="n">f1</span><span class="p">(</span><span class="n">others</span><span class="p">...);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">others</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>
  <span class="n">f2</span><span class="p">(</span><span class="n">others</span><span class="p">...);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">f1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">,</span> <span class="s">&#34;plop&#34;</span><span class="p">);</span>
  <span class="n">f2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">,</span> <span class="s">&#34;plop&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Ce qui affiche:</p>

<div class="highlight"><pre class="chroma"><code>2.4
plop
1, 2.4, plop
</code></pre></div>

<a class="headline-hash" href="https://jonathanpoelen.github.io/2013/12/parcourir-les-arguments-dune-fonction-variadique/#sans-récursivité"><h2 id="sans-récursivité">Sans récursivité</h2></a>

<p>Il existe cependant une autre façon de faire qui n&rsquo;utilise pas la récursivité. J&rsquo;ai découvert cette méthode sur le forum de openclassroms (<a href="http://fr.openclassrooms.com/forum/sujet/atelier-quiz-question-pour-un-champion-c?page=4">ce sujet, 10ème message</a>), elle est très astucieuse.</p>

<p>Implémentée sous la forme d&rsquo;une macro cela donne:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define UNPACK(...)                   \
</span><span class="cp"></span>  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span> \
    <span class="p">(</span><span class="kt">void</span><span class="p">((</span><span class="n">__VA_ARGS__</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)...</span>       \
  <span class="p">}</span>
</code></pre></div>
<ul>
<li>Le premier <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span>
</code></span> permet d&rsquo;ignorer l&rsquo;<code>initializer_list</code> créé.</li>
<li><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="p">(</span><span class="kt">void</span><span class="p">((</span><span class="n">__VA_ARGS__</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)...</span>
</code></span> évalue l&rsquo;ensemble de l&rsquo;expression, ignore le résulat (grâce au <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span>
</code></span>) et retourne un caractère dans l&rsquo;<code>initalizer_list</code>.</li>
<li>Au final, l&rsquo;expression est dépaquetée et l&rsquo;<code>initializer_list</code> est rempli de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="mi">0</span>
</code></span>.</li>
</ul>

<p>Avec cette macro les 2 fonctions précédentes deviennent:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;initializer_list&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define UNPACK(...)                   \
</span><span class="cp"></span>  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span> \
    <span class="p">(</span><span class="kt">void</span><span class="p">((</span><span class="n">__VA_ARGS__</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)...</span>       \
  <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">UNPACK</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">args</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">others</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">first</span><span class="p">;</span>
  <span class="n">UNPACK</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">others</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Ce qui simplifie considérablement l&rsquo;écriture :).</p>

<p>Évidemment, cette macro se trouve depuis dans falcon: <a href="https://github.com/jonathanpoelen/falcon/blob/master/falcon/c%2B%2B1x/unpack.hpp">CPP1X_UNPACK</a>.</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2013-12-22T10:03:06">22 décembre 2013
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  <br/><a href="https://jonathanpoelen.github.io/2013/12/parcourir-les-arguments-dune-fonction-variadique/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="0881f74fb66a84dee026002282b8e65d-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=parcourir-les-arguments-dune-fonction-variadique&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f12%2fparcourir-les-arguments-dune-fonction-variadique%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f12%2fparcourir-les-arguments-dune-fonction-variadique%2f&amp;title=parcourir-les-arguments-dune-fonction-variadique" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f12%2fparcourir-les-arguments-dune-fonction-variadique%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f12%2fparcourir-les-arguments-dune-fonction-variadique%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f12%2fparcourir-les-arguments-dune-fonction-variadique%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f12%2fparcourir-les-arguments-dune-fonction-variadique%2f&amp;name=parcourir-les-arguments-dune-fonction-variadique" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

        
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="tableau-dans-un-stdvector"><span>
        <a href="#parcourir-les-arguments-dune-fonction-variadique"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: Parcourir les arguments d&#39;une fonction variadique"></i></a>
        <a href="#utilisation-de-swap-et-des-fonctions-utilitaires-en-g%25C3%25A9n%25C3%25A9ral"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Utilisation de swap et des fonctions utilitaires en général"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2013/09/tableau-dans-un-stdvector/">Tableau dans un std::vector</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="#parcourir-les-arguments-dune-fonction-variadique">Article suivant: Parcourir les arguments d&#39;une fonction variadique</a><br/>
        <a href="#utilisation-de-swap-et-des-fonctions-utilitaires-en-g%25C3%25A9n%25C3%25A9ral">Article précédent: Utilisation de swap et des fonctions utilitaires en général</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2013-09-18T20:09:51">18 septembre 2013
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>3 minutes ;
  <a href="https://jonathanpoelen.github.io/2013/09/tableau-dans-un-stdvector/#gh-comments" onclick="DoGithubComments( 0 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#e10801262ecfe2aed9405f7d36c4d734-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
      <p>Prenons le type suivant: <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span>
</code></span>. Qui peut se justifier. À priori, cela ne cause aucun problème ; et c&rsquo;est vrai !</p>

<p>Ajoutons maintenant un élément à notre vector avec <code>push_back</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]{};</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre></div>
<p>Patatras, rien ne va plus, il y a 2 erreurs. La première concerne la construction du tableau et la seconde sa destruction car un tableau n&rsquo;a ni constructeur ni destructeur.</p>

<p>La manière la plus facile pour éliminer ces erreurs de compilation est de mettre un wrapper sur le tableau. Écrire ce wrapper n&rsquo;est pas très compliqué et Oh joie, Oh bonheur, il existe <a href="http://en.cppreference.com/w/cpp/container/array">std::array</a>.</p>

<p>Mais si l&rsquo;on tient vraiment à notre tableau (pour d&rsquo;obscures raisons sataniques :D) il est toujours possible de modifier le comportement du vector pour qu&rsquo;il comprenne les tableaux. Ceci à travers l&rsquo;allocateur, le second paramètre template d&rsquo;un vector ; celui jamais utilisé, toujours oublié <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">là_ici</span><span class="o">&gt;</span>
</code></span>.</p>

<p>La technique consiste à remplacer l&rsquo;allocateur par une version spécialisée pour les tableaux. Le plus simple est d&rsquo;hériter d&rsquo;un <a href="http://en.cppreference.com/w/cpp/memory/allocator">std::allocator</a> et de redéfinir les 2 méthodes problématiques: <a href="http://en.cppreference.com/w/cpp/memory/allocator/construct">construct</a> et <a href="http://en.cppreference.com/w/cpp/memory/allocator/destroy">destroy</a>. On peut aussi utiliser une spécialisation de template.</p>

<p>Et ne surtout pas oublier <code>rebind</code> qui permet de recréer l&rsquo;allocateur avec un type interne différent. C&rsquo;est utilisé par les conteneurs :).</p>

<p>(Un <a href="https://jonathanpoelen.github.io/2013/04/placement-new-allocateur-et-conteneur/">précédent article</a> permet de comprendre les mécanismes utilisés par un allocateur.)</p>

<p>L&rsquo;implémentation de <code>construct</code> et <code>destroy</code> est vraiment bateau, il suffit d&rsquo;appeler le constructeur ou le destructeur pour chaque élément du tableau.</p>

<p>Mais pour faire au minimum bien les choses et supporter l&rsquo;allocation de tableau de tableau (<span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
</code></span>) on utilise <code>array_allocator::construct/destroy</code> si les cellules sont des tableaux (appel récursif) ou <code>std::allocator::construct/destroy</code> dans le cas contraire.</p>

<p>À noter que la récursivité peut être éliminée en utilisant les propriétés d&rsquo;alignement des tableaux (<span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
</code></span> -&gt; <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>
</code></span>).</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">array_allocator</span><span class="p">;</span>

<span class="c1">//c&#39;est juste pour les tableaux
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">array_allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span>
<span class="o">:</span> <span class="k">public</span>  <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">value_allocator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">is_array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
    <span class="n">array_allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
  <span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">rebind</span>
  <span class="p">{</span> <span class="k">typedef</span> <span class="n">array_allocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">;</span> <span class="p">};</span>

  <span class="kt">void</span> <span class="nf">construct</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="o">*</span><span class="n">arr_ptr</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="n">T</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span>
  <span class="p">{</span>
    <span class="n">value_allocator</span> <span class="n">alloc</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">arr_ptr</span><span class="p">)[</span><span class="n">n</span><span class="p">],</span> <span class="n">val</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="o">*</span><span class="n">arr_ptr</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span>
  <span class="p">{</span>
    <span class="n">value_allocator</span> <span class="n">alloc</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">alloc</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">arr_ptr</span><span class="p">)[</span><span class="n">n</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>Dans l&rsquo;idéal, il faudrait un <code>construct</code> avec un nombre variable d&rsquo;arguments ce qui permet d&rsquo;utiliser <code>emplace_back</code>.
Toutefois, cette version est fonctionnelle avec <code>push_back</code> :).</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">array_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">});</span>
</code></pre></div>
<p>(La bibliothèque <a href="https://github.com/jonathanpoelen/falcon">falcon</a> (dont je suis le seul développeur actuellement :p) dispose d&rsquo;un allocateur de ce style: <a href="https://github.com/jonathanpoelen/falcon/blob/master/falcon/memory/generic_allocator.hpp">generic_allocator</a>. Comme son nom l&rsquo;indique, l&rsquo;allocateur couvre un spectre un peu plus large et gère en plus des types POD.)</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2013-09-18T20:09:51">18 septembre 2013
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  <br/><a href="https://jonathanpoelen.github.io/2013/09/tableau-dans-un-stdvector/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="e10801262ecfe2aed9405f7d36c4d734-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=tableau-dans-un-stdvector&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f09%2ftableau-dans-un-stdvector%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f09%2ftableau-dans-un-stdvector%2f&amp;title=tableau-dans-un-stdvector" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f09%2ftableau-dans-un-stdvector%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f09%2ftableau-dans-un-stdvector%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f09%2ftableau-dans-un-stdvector%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2013%2f09%2ftableau-dans-un-stdvector%2f&amp;name=tableau-dans-un-stdvector" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>


    
      
<div class="pagination clearfix">
  <a class="pagination__item pagination__item--prev" href="/">◀</a>
  <a class="pagination__item" href="/">1</a>
  <span class="pagination__item pagination__item--current">2/4</span>
  <a class="pagination__item" href="/page/3/">3</a>
  <a class="pagination__item" href="/page/4/">4</a>
  <a class="pagination__item pagination__item--next" href="/page/3/">▶</a>
</div>


  </main>

</div>
  <footer class="footer" itemscope="itemscope" itemtype="http://schema.org/WPFooter">
    <p class="footer-archive"><a href="/archives" title="Archives">Archives</a></p>
    <p class="footer__copyright">
       Jonathan Poelen&#39;s Blog. <span class="footer__copyright-credits">
      Généré avec <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a>
      et <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad theme</a>.
      Utilise <a href="http://fontawesome.io" rel="nofollow noopener" target="_blank">Font Awesome</a> de Dave Gandy pour les icônes.
      </span>
    </p>
  </footer>
</div>
<a id="backtop" href="#avoidance-link"><i class="fas fa-arrow-circle-up fa-3x" aria-hidden="true"></i><span class="sr-only">Revenir en haut</span></a>

</body>
</html>


