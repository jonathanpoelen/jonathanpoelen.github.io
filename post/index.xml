<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jonathan Poelen&#39;s Blog</title>
    <link>https://jonathanpoelen.github.io/post/</link>
    <description>Recent content in Posts on Jonathan Poelen&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-FR</language>
    <managingEditor>jonathan.poelen@gmail.com (Jonathan Poelen)</managingEditor>
    <webMaster>jonathan.poelen@gmail.com (Jonathan Poelen)</webMaster>
    <lastBuildDate>Sun, 02 Sep 2018 14:45:55 +0200</lastBuildDate>
    
	<atom:link href="https://jonathanpoelen.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Au cœur d&#39;un variant</title>
      <link>https://jonathanpoelen.github.io/2018/09/au-c%C5%93ur-dun-variant/</link>
      <pubDate>Sun, 02 Sep 2018 14:45:55 +0200</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2018/09/au-c%C5%93ur-dun-variant/</guid>
      <description>Cet article va être consacré à la réalisation d&amp;rsquo;une classe variant comme on peut la trouver dans la stl, boost et autres. Il existe de nombreuses techniques plus ou moins simples à réaliser et plus ou moins coûteuses à l&amp;rsquo;exécution. Je vais faire un petit tour de ce que j&amp;rsquo;ai pu voir et comment les implémenter.
Rappel sur ce qu&amp;rsquo;est un variant Un variant est une union sécurisée comme on peut le trouver dans les langages fonctionnels.</description>
    </item>
    
    <item>
      <title>Faites parler votre compilateur</title>
      <link>https://jonathanpoelen.github.io/2018/02/faites-parler-votre-compilateur/</link>
      <pubDate>Tue, 13 Feb 2018 03:00:28 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2018/02/faites-parler-votre-compilateur/</guid>
      <description>En C++, notre meilleur ami est le compilateur. Encore faut-il bien le configurer pour qu&amp;rsquo;il nous crache un maximum d&amp;rsquo;avertissements en pleine poire. Hélas, il s&amp;rsquo;avère que les options dépendent grandement du compilateur et de la version.
Du côté de Clang, il y a un -Weverything qui active absolument tous les warnings &amp;ndash; dont certains que je qualifie de douteux &amp;ndash;, alors que pour Gcc, -Wall et -Wextra n&amp;rsquo;activent pas tout.</description>
    </item>
    
    <item>
      <title>Ma vision de l&#39;accessibilité appliquée pour ce blog</title>
      <link>https://jonathanpoelen.github.io/2018/01/ma-vision-de-laccessibilit%C3%A9-appliqu%C3%A9e-pour-ce-blog/</link>
      <pubDate>Tue, 02 Jan 2018 14:18:22 +0200</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2018/01/ma-vision-de-laccessibilit%C3%A9-appliqu%C3%A9e-pour-ce-blog/</guid>
      <description>Pour changer de la programmation logicielle, je vais parler de l&amp;rsquo;accessibilité d&amp;rsquo;un site et des petits détails exaspérants que je rencontre sur la toile. Je pense qu&amp;rsquo;une bonne partie parle à chacun, généralement on fait avec, simplement parce qu&amp;rsquo;il n&amp;rsquo;y a pas d&amp;rsquo;autre choix, mais c&amp;rsquo;est toujours frustrant de tomber dessus.
Pour le blog, j&amp;rsquo;ai passé pas mal de temps sur un template déjà existant en touchant finalement un peu à toutes les parties CSS et HTML.</description>
    </item>
    
    <item>
      <title>De Blogspot à Hugo, il a changé de peau</title>
      <link>https://jonathanpoelen.github.io/2017/07/de-blogspot-%C3%A0-hugo-il-a-chang%C3%A9-de-peau/</link>
      <pubDate>Sat, 29 Jul 2017 16:03:53 +0200</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2017/07/de-blogspot-%C3%A0-hugo-il-a-chang%C3%A9-de-peau/</guid>
      <description>Il y a 2 ans je me suis dit :
 Au prochain article, j&amp;rsquo;essaye un autre système de blog !
 Et depuis 2 ans, plus rien&amp;hellip; Je n&amp;rsquo;ai pas parcouru le web à la recherche de la solution idéale, loin de là, je n&amp;rsquo;avais juste pas d&amp;rsquo;idée d&amp;rsquo;article.
Il y a 3 mois, en regardant une classe de matrice en C++, une idée m&amp;rsquo;est venue. J&amp;rsquo;ai écrit mon article puis cherché un système de site statique.</description>
    </item>
    
    <item>
      <title>Minimiser les copies dans operator&#43;</title>
      <link>https://jonathanpoelen.github.io/2017/07/minimiser-les-copies-dans-operator-/</link>
      <pubDate>Wed, 05 Jul 2017 22:02:11 +0200</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2017/07/minimiser-les-copies-dans-operator-/</guid>
      <description>Je vais me baser sur un classique: une classe de matrice contenant un std::vector&amp;lt;int&amp;gt; . Cette classe va implémenter 2 opérateurs mathématiques: +  et += . Le premier en fonction libre, le second en fonction membre.
Pour rigoler un peu, on ajoute une petite contrainte qui est &amp;laquo;&amp;nbsp;l&amp;rsquo;efficacité&amp;nbsp;&amp;raquo;. Petit mot qui englobe un peu tout et n&amp;rsquo;importe quoi tel que la performance en mémoire et en temps.
À vrai dire, il y a énormément de choses possibles rien que sur la structure du code: instruction vectorisée, alignement mémoire, expression template, etc.</description>
    </item>
    
    <item>
      <title>Comment se passer de std::forward</title>
      <link>https://jonathanpoelen.github.io/2016/04/comment-se-passer-de-stdforward/</link>
      <pubDate>Mon, 04 Apr 2016 23:09:41 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2016/04/comment-se-passer-de-stdforward/</guid>
      <description>Actuellement en pleine écriture d&amp;rsquo;une fonction match (petit projet de 200 lignes actuellement), je me retrouve, pour respecter le perfect forwarding, avec une armée de std::forward utilisée à chaque appel de fonction. J&amp;rsquo;en compte 21 pour un total de 6 niveaux d&amp;rsquo;imbrications. Autant dire qu&amp;rsquo;oublier de le mettre est plutôt facile.
C&amp;rsquo;est d&amp;rsquo;ailleurs la raison de ce billet, puisque bien sûr, j&amp;rsquo;en ai oubliés.
Pour réduire leur nombre et alléger le code, je me suis fait un petit wrapper qui sauvegarde le type de référence.</description>
    </item>
    
    <item>
      <title>if constexpr avant C&#43;&#43;17</title>
      <link>https://jonathanpoelen.github.io/2015/09/if-constexpr-avant-c--17/</link>
      <pubDate>Mon, 21 Sep 2015 00:33:38 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2015/09/if-constexpr-avant-c--17/</guid>
      <description>Le but de if constexpr  est d&amp;rsquo;interpréter le code uniquement si celui-ci respecte la condition. Il doit être syntaxiquement valide, mais n&amp;rsquo;a pas l&amp;rsquo;obligation de pouvoir être compilé.
Plutôt étrange, n&amp;rsquo;est-ce pas ? Cette propriété se révèle pourtant fort pratique dans les fonctions templates.
Prenons comme exemple une fonction invoke qui s&amp;rsquo;utilise de 3 manières:
 foncteur + paramètres fonction membre + objet + paramètres fonction membre + pointeur d&amp;rsquo;objet + paramètres  // x et y sont des std::string invoke(std::equal_to&amp;lt;&amp;gt;{}, x, y); // foncteur invoke(&amp;amp;std::string::size, x, y); // fonction membre et référence invoke(&amp;amp;std::string::size, &amp;amp;x, y); // fonction membre et pointeur  En C++17, tout peut se faire en une seule fonction, alors qu&amp;rsquo;avant C++17, il fallait faire plusieurs surcharges pour les différentes situations et jouer avec std::enable_if.</description>
    </item>
    
    <item>
      <title>Paramètres de fonction nommés en C&#43;&#43;</title>
      <link>https://jonathanpoelen.github.io/2015/07/param%C3%A8tres-de-fonction-nomm%C3%A9s-en-c--/</link>
      <pubDate>Tue, 28 Jul 2015 00:43:22 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2015/07/param%C3%A8tres-de-fonction-nomm%C3%A9s-en-c--/</guid>
      <description>Cet article est la démonstration de l&amp;rsquo;article précédent. La problématique présentée est la suivante: &amp;laquo;&amp;nbsp;Comment, dans une fonction avec plusieurs paramètres optionnels, initialiser un paramètre précis sans indiquer les valeurs optionnelles qui précèdent ?&amp;nbsp;&amp;raquo;
La fonction de référence sera la suivante:
void draw_rect( unsigned w, unsigned h , char border_top = &amp;#39;-&amp;#39;, char border_bottom = &amp;#39;-&amp;#39; , char border_left = &amp;#39;&amp;lt;&amp;#39;, char border_right = &amp;#39;&amp;gt;&amp;#39; , char fill = &amp;#39;#&amp;#39; ) { std::cout &amp;lt;&amp;lt; std::setfill(border_top) &amp;lt;&amp;lt; std::setw(w+2) &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; while (h--) { std::cout &amp;lt;&amp;lt; border_left &amp;lt;&amp;lt; std::setfill(fill) &amp;lt;&amp;lt; std::setw(w) &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; border_right &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } std::cout &amp;lt;&amp;lt; std::setfill(border_bottom) &amp;lt;&amp;lt; std::setw(w+2) &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; }  Comment faire un appel proche de draw_rect(4,3, fill=&amp;#39;@&amp;#39;)  ?</description>
    </item>
    
    <item>
      <title>Implémentation d&#39;un magasin de type</title>
      <link>https://jonathanpoelen.github.io/2015/07/impl%C3%A9mentation-dun-magasin-de-type/</link>
      <pubDate>Thu, 02 Jul 2015 01:49:41 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2015/07/impl%C3%A9mentation-dun-magasin-de-type/</guid>
      <description>Ce que j&amp;rsquo;appelle ici un magasin de type n&amp;rsquo;est autre qu&amp;rsquo;un std::tuple où les types ne sont présents qu&amp;rsquo;une seule fois. Une espèce de set version tuple en somme.
Je me suis servi de ce type de structure à 2 reprises.
Une fois pour manipuler de façon similaire des types hétérogènes sans la lourdeur de std::tuple. Il faut dire aussi que j&amp;rsquo;étais en C++11 et que dans cette norme std::get&amp;lt;Type&amp;gt;() n&amp;rsquo;existe pas.</description>
    </item>
    
    <item>
      <title>Appel conditionnel de fonction selon la validité d&#39;une expression</title>
      <link>https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validit%C3%A9-dune-expression/</link>
      <pubDate>Sun, 30 Nov 2014 19:17:52 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validit%C3%A9-dune-expression/</guid>
      <description>L&amp;rsquo;approche suivante consiste à vérifier qu&amp;rsquo;une fonction (membre ou statique) est appelable dans le but de l&amp;rsquo;utiliser, ou, à défaut, fournir implémentation générique. De manière plus générale, la méthode présentée ici s&amp;rsquo;applique à toutes expressions.
Appeler T::sort si possible, sinon std::sort(begin(T), end(T)) L&amp;rsquo;exemple va se faire sur la classe std::list qui n&amp;rsquo;est pas triable avec std::sort, mais possède une fonction membre sort(). Ainsi que sur std::vector qui, inversement, n&amp;rsquo;a pas de fonction membre sort(), mais fonctionne avec std::sort.</description>
    </item>
    
    <item>
      <title>Réduire l&#39;empreinte mémoire d&#39;une agglomération de types</title>
      <link>https://jonathanpoelen.github.io/2014/06/r%C3%A9duire-lempreinte-m%C3%A9moire-dune-agglom%C3%A9ration-de-types/</link>
      <pubDate>Sat, 28 Jun 2014 14:10:11 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2014/06/r%C3%A9duire-lempreinte-m%C3%A9moire-dune-agglom%C3%A9ration-de-types/</guid>
      <description>Un petit article pour parler d&amp;rsquo;optimisation mémoire (si on peut appeler ça comme ça) avec comme exemple la structure de donnée utilisée par std::unique_ptr.
Implémentation naïve de std::unique_ptr Pour rappel, std::unique_ptr prend 2 paramètres template: T et Deleter (qui par défaut égal std::default_delete&amp;lt;T&amp;gt;).
Naïvement, l&amp;rsquo;implémentation serait:
template&amp;lt;T, Deleter = std::default_delete&amp;lt;T&amp;gt;&amp;gt; classmy_unique_ptr { T* m_pointer; Deleter m_deleter; // … };  Rien d&amp;rsquo;extraordinaire.
Cependant, même si Deleter est une classe sans attribut, sa taille est de 1 octet.</description>
    </item>
    
    <item>
      <title>256 couleurs et plus dans la console</title>
      <link>https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/</link>
      <pubDate>Mon, 09 Jun 2014 00:35:19 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2014/06/256-couleurs-et-plus-dans-la-console/</guid>
      <description>À chaque fois que je cherche des infos sur les couleurs je tombe toujours sur les trucs basiques. Mais j&amp;rsquo;ai récemment appris l&amp;rsquo;existence de 256 couleurs dans la console en tombant sur un screen un peu trop coloré. Ce qui m&amp;rsquo;a dirigé sur un dépôt contenant un $LS_COLORS particulièrement fourni.
En fait, il s&amp;rsquo;avère qu&amp;rsquo;en rajoutant extended dans la recherche &amp;laquo;&amp;nbsp;color shell&amp;nbsp;&amp;raquo; on puisse trouver quelque(s) ressource(s). J&amp;rsquo;aurais bien voulu y penser la semaine dernière, ça m&amp;rsquo;aurait évité de comprendre par tâtonnement&amp;hellip;</description>
    </item>
    
    <item>
      <title>Valeur, référence ou pointeur ? (2/2)</title>
      <link>https://jonathanpoelen.github.io/2014/05/valeur-r%C3%A9f%C3%A9rence-ou-pointeur--2/2/</link>
      <pubDate>Sat, 31 May 2014 21:18:10 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2014/05/valeur-r%C3%A9f%C3%A9rence-ou-pointeur--2/2/</guid>
      <description>Dans le précédent billet, j&amp;rsquo;opposai les paramètres par références constantes à ceux par valeurs.
Sans plus attendre entamons la seconde question.
Référence ou pointeur ? Si je dois faire court je dirai: pointeur jamais ; référence quand possible. Sans autre forme de procès :D
Mais on me dit dans l&amp;rsquo;oreillette qu&amp;rsquo;il faut argumenter&amp;hellip; Alors c&amp;rsquo;est parti.
Les références possèdent un contrat beaucoup plus fort que les pointeurs: elles ne peuvent être nulles et référencent toujours la même variable.</description>
    </item>
    
    <item>
      <title>Valeur, référence ou pointeur ? (1/2)</title>
      <link>https://jonathanpoelen.github.io/2014/05/valeur-r%C3%A9f%C3%A9rence-ou-pointeur--1/2/</link>
      <pubDate>Thu, 22 May 2014 09:51:53 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2014/05/valeur-r%C3%A9f%C3%A9rence-ou-pointeur--1/2/</guid>
      <description>Quand utiliser une variable par valeur, référence ou pointeur ?
 Telle fut la question qui m&amp;rsquo;a été posée :p.
Comme je ne suis pas entièrement satisfait de la réponse que j&amp;rsquo;ai donné, je fais un article. Pour tout dire, la réponse n&amp;rsquo;est pas aussi triviale que l&amp;rsquo;on pourrait le croire depuis l&amp;rsquo;arrivée du C++11 et la sémantique de déplacement.
Tout d&amp;rsquo;abord, décomposons cette question en 2 parties:</description>
    </item>
    
    <item>
      <title>Parcourir les arguments d&#39;une fonction variadique</title>
      <link>https://jonathanpoelen.github.io/2013/12/parcourir-les-arguments-dune-fonction-variadique/</link>
      <pubDate>Sun, 22 Dec 2013 10:03:06 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/12/parcourir-les-arguments-dune-fonction-variadique/</guid>
      <description>À l&amp;rsquo;approche de Noël et du déballage de cadeaux, faisons un tour sur le déballage des paramètres variadiques.
Fonction récursive La méthode habituelle pour utiliser chaque paramètre est la récursion jusqu&amp;rsquo;à plus d&amp;rsquo;argument ou jusqu&amp;rsquo;à un nombre défini, généralement 1.
Quelque chose dans ce goût-là:
#include &amp;lt;iostream&amp;gt; void f1() {} template&amp;lt;classT, class... Args&amp;gt; void f1(const T&amp;amp; first, const Args&amp;amp;... others) { std::cout &amp;lt;&amp;lt; first &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; f1(others...); } template&amp;lt;classT&amp;gt; void f2(const T&amp;amp; first) { std::cout &amp;lt;&amp;lt; first &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } template&amp;lt;classT, class.</description>
    </item>
    
    <item>
      <title>Tableau dans un std::vector</title>
      <link>https://jonathanpoelen.github.io/2013/09/tableau-dans-un-stdvector/</link>
      <pubDate>Wed, 18 Sep 2013 20:09:51 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/09/tableau-dans-un-stdvector/</guid>
      <description>Prenons le type suivant: std::vector&amp;lt;int[4]&amp;gt; . Qui peut se justifier. À priori, cela ne cause aucun problème ; et c&amp;rsquo;est vrai !
Ajoutons maintenant un élément à notre vector avec push_back.
std::vector&amp;lt;int[2]&amp;gt; v; int a[2]{}; v.push_back(a);  Patatras, rien ne va plus, il y a 2 erreurs. La première concerne la construction du tableau et la seconde sa destruction car un tableau n&amp;rsquo;a ni constructeur ni destructeur.
La manière la plus facile pour éliminer ces erreurs de compilation est de mettre un wrapper sur le tableau.</description>
    </item>
    
    <item>
      <title>Utilisation de swap et des fonctions utilitaires en général</title>
      <link>https://jonathanpoelen.github.io/2013/07/utilisation-de-swap-et-des-fonctions-utilitaires-en-g%C3%A9n%C3%A9ral/</link>
      <pubDate>Sat, 20 Jul 2013 11:18:49 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/07/utilisation-de-swap-et-des-fonctions-utilitaires-en-g%C3%A9n%C3%A9ral/</guid>
      <description>Une fonction utilitaire est une fonction libre qui n&amp;rsquo;étant pas attachée à une classe particulière comme une fonction de conversion (to_string, etc) ou un accesseur externe à une classe (get, begin, end, etc).
Toutes ces fonctions citées sont disponibles en C++11. La seule fonction utilitaire qui me vient à l&amp;rsquo;esprit en C++03 est std::swap (fonction qui échange le contenu de 2 variables). Pour info, l&amp;rsquo;en-tête de std::swap est passé de &amp;lt;algorithm&amp;gt; en C++03 à &amp;lt;utility&amp;gt; en C++11.</description>
    </item>
    
    <item>
      <title>make sans Makefile, utilisation des règles implicites</title>
      <link>https://jonathanpoelen.github.io/2013/06/make-sans-makefile-utilisation-des-r%C3%A8gles-implicites/</link>
      <pubDate>Wed, 26 Jun 2013 11:05:28 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/06/make-sans-makefile-utilisation-des-r%C3%A8gles-implicites/</guid>
      <description>La commande GNU make possède énormément de commandes implicites regroupées dans un Makefile &amp;laquo;&amp;nbsp;par défaut&amp;nbsp;&amp;raquo; avec plein de règles. Celui-ci est visible en tapant make -pf /dev/null dans un terminal.
Rien qu&amp;rsquo;avec ça, on peut compiler des fichiers C, C++, archive, latex, etc. Il y a de quoi faire en fait.
Par exemple, je crée un fichier C nommé test.c:
int main(int ac, char** av) { return ac; } Que je compile avec make test pour créer l&amp;rsquo;exécutable test.</description>
    </item>
    
    <item>
      <title>Optimisation de script bash en limitant l&#39;ouverture de processus</title>
      <link>https://jonathanpoelen.github.io/2013/05/optimisation-de-script-bash-en-limitant-louverture-de-processus/</link>
      <pubDate>Wed, 29 May 2013 00:23:12 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/05/optimisation-de-script-bash-en-limitant-louverture-de-processus/</guid>
      <description>Une des choses qui prend du temps dans l&amp;rsquo;exécution d&amp;rsquo;un script shell est le nombre de programmes appelés et par conséquent, le nombre de processus créés.
Le meilleur moyen d&amp;rsquo;accélérer un script est de passer par les builtins et limiter les boucles ouverture/fermeture de programme. En fait, dans certains cas, on pourrait avoir une commande qui lit sur l&amp;rsquo;entrée standard et retourne un résultat ; un peu comme bc. C&amp;rsquo;est là que les coprocessus viennent à la rescousse :).</description>
    </item>
    
    <item>
      <title>Référence constante sur référence</title>
      <link>https://jonathanpoelen.github.io/2013/05/r%C3%A9f%C3%A9rence-constante-sur-r%C3%A9f%C3%A9rence/</link>
      <pubDate>Mon, 13 May 2013 03:18:42 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/05/r%C3%A9f%C3%A9rence-constante-sur-r%C3%A9f%C3%A9rence/</guid>
      <description>Une petite note sur les références et le qualificatif const  en commençant par un exemple :).
using reference = int&amp;amp;; int i = 0; reference const r = i; r = 3;  Contrairement à ce que laisse croire le code, il est possible de modifier la valeur de r. En fait, ajouter const  sur une référence ne fait rien car cela ne s&amp;rsquo;applique pas sur le référé qui reste un int&amp;amp; .</description>
    </item>
    
    <item>
      <title>Placement new, allocateur et conteneur</title>
      <link>https://jonathanpoelen.github.io/2013/04/placement-new-allocateur-et-conteneur/</link>
      <pubDate>Mon, 22 Apr 2013 22:17:22 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/04/placement-new-allocateur-et-conteneur/</guid>
      <description>new  est généralement utilisé pour allouer un bloc mémoire et &amp;ndash; où il diffère de malloc(), &amp;ndash; appelle le constructeur de la classe demandée (si constructeur il y a). Il fait donc deux choses en une.
Mais new  fait une troisième chose: il lance une exception std::bad_alloc si l&amp;rsquo;espace mémoire est insuffisant.
Ou pas. Car new  est un opérateur surchargeable qui prend des paramètres. Le standard définit dans l&amp;rsquo;en-tête &amp;lt;new&amp;gt; un type (std::nothrow_t) et une variable (std::nothrow) qui permettent de retourner un pointeur nul plutôt que lancer une exception.</description>
    </item>
    
    <item>
      <title>Ne pas empêcher la NRVO</title>
      <link>https://jonathanpoelen.github.io/2013/03/ne-pas-emp%C3%AAcher-la-nrvo/</link>
      <pubDate>Sun, 17 Mar 2013 17:12:57 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/03/ne-pas-emp%C3%AAcher-la-nrvo/</guid>
      <description>La NRVO et la RVO sont des optimisations des compilateurs pour retourner un objet sans le copier. Je renvoie directement sur la FAQ C++ developpez.com.
Cependant, ces optimisations ne s&amp;rsquo;appliquent que sur une variable de type T sans référence. Ce qui veut dire qu&amp;rsquo;une référence ne sera pas optimisée.
iterator operator+(const iterator&amp;amp; other, int n) { return iterator(other) += n; // pas de RVO }  Alors qu&amp;rsquo;une décomposition de la fonction active la NRVO.</description>
    </item>
    
    <item>
      <title>Sqlite, reconstruire la bdd pour l&#39;alléger</title>
      <link>https://jonathanpoelen.github.io/2013/03/sqlite-reconstruire-la-bdd-pour-lall%C3%A9ger/</link>
      <pubDate>Mon, 04 Mar 2013 23:36:14 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/03/sqlite-reconstruire-la-bdd-pour-lall%C3%A9ger/</guid>
      <description>Il existe sur les bases de données SQLite une commande pour réduire la fragmentation des tables et optimiser l&amp;rsquo;espace disque. J&amp;rsquo;ai nommé: VACUUM.
Cette commande reconstruit la bdd pour éliminer les lignes vides et réorganise les index (plus de détails dans la doc en lien).
Comme certains logiciels se servent de sqlite comme BDD, il peut être intéressant d&amp;rsquo;utiliser cette commande de temps en temps. La première fois que je l&amp;rsquo;ai fait pour firefox (fichier ~/.</description>
    </item>
    
    <item>
      <title>Différence entre $@, $*, &#34;$@&#34; et &#34;$*&#34;</title>
      <link>https://jonathanpoelen.github.io/2013/02/diff%C3%A9rence-entre----et-/</link>
      <pubDate>Sun, 17 Feb 2013 10:42:27 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/02/diff%C3%A9rence-entre----et-/</guid>
      <description>Dans un script shell, il existe 2 variables pour accéder aux paramètres de la commande (aussi nommées argv dans pas mal d&amp;rsquo;autres langages): $* et $@.
 $* est une variable ce qu&amp;rsquo;il y a de plus normale et ne diffère pas d&amp;rsquo;une autre variable. Cependant, le comportement des variables diffère en fonction du shell, notamment sur zsh (j&amp;rsquo;y reviens après). $@ est une variable au comportement différent entre les shells basés sur sh (bash, dash, &amp;hellip;) et les autres (ksh, zsh).</description>
    </item>
    
    <item>
      <title>Délégation d&#39;événement en js</title>
      <link>https://jonathanpoelen.github.io/2013/01/d%C3%A9l%C3%A9gation-d%C3%A9v%C3%A9nement-en-js/</link>
      <pubDate>Fri, 18 Jan 2013 15:16:12 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/01/d%C3%A9l%C3%A9gation-d%C3%A9v%C3%A9nement-en-js/</guid>
      <description>En règle générale les événements sont attachés à l&amp;rsquo;élément qui va le traiter.
Par exemple en javascript, un menu (ul) contenant 10 entrées (li) où chaque entrée est associée à une action crée, au total, 10 événements. 10 événements attachés à la même action.
Pour dire vrai, cette méthode est peu performante et peut la plupart du temps être remplacée par un seul événement sur le parent. À ce moment le parent vérifie si l&amp;rsquo;événement est généré par un de ses fils et fait le traitement en conséquence.</description>
    </item>
    
    <item>
      <title>La vis cachée de getopt</title>
      <link>https://jonathanpoelen.github.io/2012/12/la-vis-cach%C3%A9e-de-getopt/</link>
      <pubDate>Tue, 25 Dec 2012 12:58:55 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2012/12/la-vis-cach%C3%A9e-de-getopt/</guid>
      <description>Voici une petite information très mal connue et peu utilisée du getopt de la lib C et de la commande shell. Ainsi que Boost.Program_options. Parce que boost c&amp;rsquo;est bien :p.
Les noms des options longues n&amp;rsquo;ont pas besoin d&amp;rsquo;être écrites entièrement.
function parsecmd() { getopt -o &amp;#39;&amp;#39; --long \  option-longue,option-encore-plus-longue,une-autre-option: \  -n &amp;#39;example&amp;#39; -- &amp;#34;$@&amp;#34; } parsecmd --option-l --u plop bidule Donne
--option-longue --une-autre-option &#39;plop&#39; -- &#39;bidule&#39;  La commande shell getopt est un peu plus souple que les autres.</description>
    </item>
    
    <item>
      <title>Taguer vos classes, cataloguées-les</title>
      <link>https://jonathanpoelen.github.io/2012/12/taguer-vos-classes-catalogu%C3%A9es-les/</link>
      <pubDate>Thu, 20 Dec 2012 01:22:50 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2012/12/taguer-vos-classes-catalogu%C3%A9es-les/</guid>
      <description>Le C++ a l&amp;rsquo;avantage de faire de la surcharge de fonction et permet ainsi de spécifier des algorithmes selon des critères. Ici ce seront des &amp;laquo;&amp;nbsp;tags&amp;nbsp;&amp;raquo;.
Comme exemple je vais utiliser les tags présents dans les itérateurs de la stl et une implémentation de la fonction std::advance().
Première implémentation La fonction std::advance() permet d&amp;rsquo;incrémenter un itérateur de N éléments (ou décrémenter si N est négatif). D&amp;rsquo;après cette description, un premier algorithme peut être émis:</description>
    </item>
    
    <item>
      <title>Zsh et le danger des modificateurs</title>
      <link>https://jonathanpoelen.github.io/2012/10/zsh-et-le-danger-des-modificateurs/</link>
      <pubDate>Sun, 14 Oct 2012 19:46:36 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2012/10/zsh-et-le-danger-des-modificateurs/</guid>
      <description>Zsh est très bien comme shell, mais fait plus de choses que bash ce qui peut engendrer des bugs quand celui-ci est le shell par défaut et que des scripts ne définissent pas l&amp;rsquo;interpréteur utilisé. J&amp;rsquo;ai eu le coup une fois lorsqu&amp;rsquo;il fallait charger le module canberra-gtk pour les programmes java.
Une variable $GTK_MODULES est définie et contient tous les modules gtk séparés par des deux points (:). Visiblement, j&amp;rsquo;ai 2 modules gtk.</description>
    </item>
    
    <item>
      <title>La récursivité et le mauvais exemple de Fibonacci</title>
      <link>https://jonathanpoelen.github.io/2012/08/la-r%C3%A9cursivit%C3%A9-et-le-mauvais-exemple-de-fibonacci/</link>
      <pubDate>Thu, 16 Aug 2012 02:22:24 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2012/08/la-r%C3%A9cursivit%C3%A9-et-le-mauvais-exemple-de-fibonacci/</guid>
      <description>Quasiment toute personne ayant suivi un cours sur la récursivité a eu un exercice de la forme:
 Coder la suite de Fibonacci en récursive et en itérative.
 Mais partout où j&amp;rsquo;ai vu une implémentation récursive, je suis tombé sur un algorithme inefficace. Voici ce qu&amp;rsquo;on peut trouver.
//itérative long long fib(unsigned n) { if (n == 0) return n; long long a = 0, b = 1, tmp; while (--n) { tmp = a + b; a = b; b = tmp; } return b; } // récursive long long fib_r(unsigned n) { if (0 == n || 1 == n) return n; return fib_r(n-1) + fib_r(n-2); } Sauf que cet algorithme récursif est pourri.</description>
    </item>
    
    <item>
      <title>Sed tout puissant</title>
      <link>https://jonathanpoelen.github.io/2012/06/sed-tout-puissant/</link>
      <pubDate>Mon, 11 Jun 2012 10:11:50 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2012/06/sed-tout-puissant/</guid>
      <description>Il y a 3 semaines environ je cherchais le moyen d&amp;rsquo;utiliser la commande sed avec une regex sur plusieurs lignes. Je voulais transformer tous les /\+\n\s+&amp;quot;&amp;quot;/ en rien du tout (oui, les supprimer…). Sauf que comme tel, ça ne fonctionne pas, sed comme beaucoup de commandes unix fonctionne par ligne. Après de lourdes et pompeuses recherches d&amp;rsquo;au moins 7 secondes montre en main, je suis tombé sur la solution.
Pour ce faire, il suffit d&amp;rsquo;un identifiant, un petit label, une information de multi-ligne au milieu et 3 autres bricoles ; rien que ça :D.</description>
    </item>
    
    <item>
      <title>Rendre accessible le chargement de lien avec AJAX</title>
      <link>https://jonathanpoelen.github.io/2011/12/rendre-accessible-le-chargement-de-lien-avec-ajax/</link>
      <pubDate>Sat, 31 Dec 2011 12:05:43 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2011/12/rendre-accessible-le-chargement-de-lien-avec-ajax/</guid>
      <description>Le but d&amp;rsquo;un site chargeant ces pages avec AJAX est double:
 Diminuer la charge du serveur en ne demandant que le contenu à modifier (ce qui peut potentiellement réduire le nombre de requêtes à la base de données et les données transférées). Avoir une navigation plus fluide et réactive puisque le navigateur travaille moins.  Toutefois, si mal fait, des problèmes apparaissent au niveau de l&amp;rsquo;historique qui n&amp;rsquo;est plus utilisable.</description>
    </item>
    
  </channel>
</rss>