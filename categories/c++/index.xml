<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Jonathan Poelen&#39;s Blog</title>
    <link>https://jonathanpoelen.github.io/categories/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Jonathan Poelen&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-FR</language>
    <managingEditor>jonathan.poelen@gmail.com (Jonathan Poelen)</managingEditor>
    <webMaster>jonathan.poelen@gmail.com (Jonathan Poelen)</webMaster>
    <lastBuildDate>Sun, 02 Sep 2018 14:45:55 +0200</lastBuildDate>
    
	<atom:link href="https://jonathanpoelen.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Au cœur d&#39;un variant</title>
      <link>https://jonathanpoelen.github.io/2018/09/au-c%C5%93ur-dun-variant/</link>
      <pubDate>Sun, 02 Sep 2018 14:45:55 +0200</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2018/09/au-c%C5%93ur-dun-variant/</guid>
      <description>Cet article va être consacré à la réalisation d&amp;rsquo;une classe variant comme on peut la trouver dans la stl, boost et autres. Il existe de nombreuses techniques plus ou moins simples à réaliser et plus ou moins coûteuses à l&amp;rsquo;exécution. Je vais faire un petit tour de ce que j&amp;rsquo;ai pu voir et comment les implémenter.
Rappel sur ce qu&amp;rsquo;est un variant Un variant est une union sécurisée comme on peut le trouver dans les langages fonctionnels.</description>
    </item>
    
    <item>
      <title>Faites parler votre compilateur</title>
      <link>https://jonathanpoelen.github.io/2018/02/faites-parler-votre-compilateur/</link>
      <pubDate>Tue, 13 Feb 2018 03:00:28 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2018/02/faites-parler-votre-compilateur/</guid>
      <description>En C++, notre meilleur ami est le compilateur. Encore faut-il bien le configurer pour qu&amp;rsquo;il nous crache un maximum d&amp;rsquo;avertissements en pleine poire. Hélas, il s&amp;rsquo;avère que les options dépendent grandement du compilateur et de la version.
Du côté de Clang, il y a un -Weverything qui active absolument tous les warnings &amp;ndash; dont certains que je qualifie de douteux &amp;ndash;, alors que pour Gcc, -Wall et -Wextra n&amp;rsquo;activent pas tout.</description>
    </item>
    
    <item>
      <title>comparaison de différentes implémentations de mp_index_of</title>
      <link>https://jonathanpoelen.github.io/2018/01/comparaison-de-diff%C3%A9rentes-impl%C3%A9mentations-de-mp_index_of/</link>
      <pubDate>Wed, 10 Jan 2018 18:28:21 +0200</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2018/01/comparaison-de-diff%C3%A9rentes-impl%C3%A9mentations-de-mp_index_of/</guid>
      <description>Dans l&amp;rsquo;article précédent sur les variants, j&amp;rsquo;ai fait une implémentation un peu spéciale de index_of. Je vais présenter une quinzaine d&amp;rsquo;implémentations possibles et le coût de chacune sur le compilateur.
Info : L&amp;rsquo;implémentation citée précédemment ne se retrouve pas ici car une forme récursive plus &amp;laquo;&amp;nbsp;classique&amp;nbsp;&amp;raquo; a les mêmes conséquences.
 Avant-propos Toutes les implémentations de mp_index_of&amp;lt;T, Ts...&amp;gt; retournent un std::integral_constant&amp;lt;int, i&amp;gt; correspondant à l&amp;rsquo;indice de T dans Ts ou -1 si T n&amp;rsquo;existe pas.</description>
    </item>
    
    <item>
      <title>Minimiser les copies dans operator&#43;</title>
      <link>https://jonathanpoelen.github.io/2017/07/minimiser-les-copies-dans-operator-/</link>
      <pubDate>Wed, 05 Jul 2017 22:02:11 +0200</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2017/07/minimiser-les-copies-dans-operator-/</guid>
      <description>Je vais me baser sur un classique: une classe de matrice contenant un std::vector&amp;lt;int&amp;gt; . Cette classe va implémenter 2 opérateurs mathématiques: +  et += . Le premier en fonction libre, le second en fonction membre.
Pour rigoler un peu, on ajoute une petite contrainte qui est &amp;laquo;&amp;nbsp;l&amp;rsquo;efficacité&amp;nbsp;&amp;raquo;. Petit mot qui englobe un peu tout et n&amp;rsquo;importe quoi tel que la performance en mémoire et en temps.
À vrai dire, il y a énormément de choses possibles rien que sur la structure du code: instruction vectorisée, alignement mémoire, expression template, etc.</description>
    </item>
    
    <item>
      <title>Comment se passer de std::forward</title>
      <link>https://jonathanpoelen.github.io/2016/04/comment-se-passer-de-stdforward/</link>
      <pubDate>Mon, 04 Apr 2016 23:09:41 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2016/04/comment-se-passer-de-stdforward/</guid>
      <description>Actuellement en pleine écriture d&amp;rsquo;une fonction match (petit projet de 200 lignes actuellement), je me retrouve, pour respecter le perfect forwarding, avec une armée de std::forward utilisée à chaque appel de fonction. J&amp;rsquo;en compte 21 pour un total de 6 niveaux d&amp;rsquo;imbrications. Autant dire qu&amp;rsquo;oublier de le mettre est plutôt facile.
C&amp;rsquo;est d&amp;rsquo;ailleurs la raison de ce billet, puisque bien sûr, j&amp;rsquo;en ai oubliés.
Pour réduire leur nombre et alléger le code, je me suis fait un petit wrapper qui sauvegarde le type de référence.</description>
    </item>
    
    <item>
      <title>if constexpr avant C&#43;&#43;17</title>
      <link>https://jonathanpoelen.github.io/2015/09/if-constexpr-avant-c--17/</link>
      <pubDate>Mon, 21 Sep 2015 00:33:38 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2015/09/if-constexpr-avant-c--17/</guid>
      <description>Le but de if constexpr  est d&amp;rsquo;interpréter le code uniquement si celui-ci respecte la condition. Il doit être syntaxiquement valide, mais n&amp;rsquo;a pas l&amp;rsquo;obligation de pouvoir être compilé.
Plutôt étrange, n&amp;rsquo;est-ce pas ? Cette propriété se révèle pourtant fort pratique dans les fonctions templates.
Prenons comme exemple une fonction invoke qui s&amp;rsquo;utilise de 3 manières:
 foncteur + paramètres fonction membre + objet + paramètres fonction membre + pointeur d&amp;rsquo;objet + paramètres  // x et y sont des std::string invoke(std::equal_to&amp;lt;&amp;gt;{}, x, y); // foncteur invoke(&amp;amp;std::string::size, x, y); // fonction membre et référence invoke(&amp;amp;std::string::size, &amp;amp;x, y); // fonction membre et pointeur  En C++17, tout peut se faire en une seule fonction, alors qu&amp;rsquo;avant C++17, il fallait faire plusieurs surcharges pour les différentes situations et jouer avec std::enable_if.</description>
    </item>
    
    <item>
      <title>Paramètres de fonction nommés en C&#43;&#43;</title>
      <link>https://jonathanpoelen.github.io/2015/07/param%C3%A8tres-de-fonction-nomm%C3%A9s-en-c--/</link>
      <pubDate>Tue, 28 Jul 2015 00:43:22 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2015/07/param%C3%A8tres-de-fonction-nomm%C3%A9s-en-c--/</guid>
      <description>Cet article est la démonstration de l&amp;rsquo;article précédent. La problématique présentée est la suivante: &amp;laquo;&amp;nbsp;Comment, dans une fonction avec plusieurs paramètres optionnels, initialiser un paramètre précis sans indiquer les valeurs optionnelles qui précèdent ?&amp;nbsp;&amp;raquo;
La fonction de référence sera la suivante:
void draw_rect( unsigned w, unsigned h , char border_top = &amp;#39;-&amp;#39;, char border_bottom = &amp;#39;-&amp;#39; , char border_left = &amp;#39;&amp;lt;&amp;#39;, char border_right = &amp;#39;&amp;gt;&amp;#39; , char fill = &amp;#39;#&amp;#39; ) { std::cout &amp;lt;&amp;lt; std::setfill(border_top) &amp;lt;&amp;lt; std::setw(w+2) &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; while (h--) { std::cout &amp;lt;&amp;lt; border_left &amp;lt;&amp;lt; std::setfill(fill) &amp;lt;&amp;lt; std::setw(w) &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; border_right &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } std::cout &amp;lt;&amp;lt; std::setfill(border_bottom) &amp;lt;&amp;lt; std::setw(w+2) &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; }  Comment faire un appel proche de draw_rect(4,3, fill=&amp;#39;@&amp;#39;)  ?</description>
    </item>
    
    <item>
      <title>Implémentation d&#39;un magasin de type</title>
      <link>https://jonathanpoelen.github.io/2015/07/impl%C3%A9mentation-dun-magasin-de-type/</link>
      <pubDate>Thu, 02 Jul 2015 01:49:41 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2015/07/impl%C3%A9mentation-dun-magasin-de-type/</guid>
      <description>Ce que j&amp;rsquo;appelle ici un magasin de type n&amp;rsquo;est autre qu&amp;rsquo;un std::tuple où les types ne sont présents qu&amp;rsquo;une seule fois. Une espèce de set version tuple en somme.
Je me suis servi de ce type de structure à 2 reprises.
Une fois pour manipuler de façon similaire des types hétérogènes sans la lourdeur de std::tuple. Il faut dire aussi que j&amp;rsquo;étais en C++11 et que dans cette norme std::get&amp;lt;Type&amp;gt;() n&amp;rsquo;existe pas.</description>
    </item>
    
    <item>
      <title>Appel conditionnel de fonction selon la validité d&#39;une expression</title>
      <link>https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validit%C3%A9-dune-expression/</link>
      <pubDate>Sun, 30 Nov 2014 19:17:52 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2014/11/appel-conditionnel-de-fonction-selon-la-validit%C3%A9-dune-expression/</guid>
      <description>L&amp;rsquo;approche suivante consiste à vérifier qu&amp;rsquo;une fonction (membre ou statique) est appelable dans le but de l&amp;rsquo;utiliser, ou, à défaut, fournir implémentation générique. De manière plus générale, la méthode présentée ici s&amp;rsquo;applique à toutes expressions.
Appeler T::sort si possible, sinon std::sort(begin(T), end(T)) L&amp;rsquo;exemple va se faire sur la classe std::list qui n&amp;rsquo;est pas triable avec std::sort, mais possède une fonction membre sort(). Ainsi que sur std::vector qui, inversement, n&amp;rsquo;a pas de fonction membre sort(), mais fonctionne avec std::sort.</description>
    </item>
    
    <item>
      <title>Réduire l&#39;empreinte mémoire d&#39;une agglomération de types</title>
      <link>https://jonathanpoelen.github.io/2014/06/r%C3%A9duire-lempreinte-m%C3%A9moire-dune-agglom%C3%A9ration-de-types/</link>
      <pubDate>Sat, 28 Jun 2014 14:10:11 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2014/06/r%C3%A9duire-lempreinte-m%C3%A9moire-dune-agglom%C3%A9ration-de-types/</guid>
      <description>Un petit article pour parler d&amp;rsquo;optimisation mémoire (si on peut appeler ça comme ça) avec comme exemple la structure de donnée utilisée par std::unique_ptr.
Implémentation naïve de std::unique_ptr Pour rappel, std::unique_ptr prend 2 paramètres template: T et Deleter (qui par défaut égal std::default_delete&amp;lt;T&amp;gt;).
Naïvement, l&amp;rsquo;implémentation serait:
template&amp;lt;T, Deleter = std::default_delete&amp;lt;T&amp;gt;&amp;gt; classmy_unique_ptr { T* m_pointer; Deleter m_deleter; // … };  Rien d&amp;rsquo;extraordinaire.
Cependant, même si Deleter est une classe sans attribut, sa taille est de 1 octet.</description>
    </item>
    
    <item>
      <title>Valeur, référence ou pointeur ? (2/2)</title>
      <link>https://jonathanpoelen.github.io/2014/05/valeur-r%C3%A9f%C3%A9rence-ou-pointeur--2/2/</link>
      <pubDate>Sat, 31 May 2014 21:18:10 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2014/05/valeur-r%C3%A9f%C3%A9rence-ou-pointeur--2/2/</guid>
      <description>Dans le précédent billet, j&amp;rsquo;opposai les paramètres par références constantes à ceux par valeurs.
Sans plus attendre entamons la seconde question.
Référence ou pointeur ? Si je dois faire court je dirai: pointeur jamais ; référence quand possible. Sans autre forme de procès :D
Mais on me dit dans l&amp;rsquo;oreillette qu&amp;rsquo;il faut argumenter&amp;hellip; Alors c&amp;rsquo;est parti.
Les références possèdent un contrat beaucoup plus fort que les pointeurs: elles ne peuvent être nulles et référencent toujours la même variable.</description>
    </item>
    
    <item>
      <title>Valeur, référence ou pointeur ? (1/2)</title>
      <link>https://jonathanpoelen.github.io/2014/05/valeur-r%C3%A9f%C3%A9rence-ou-pointeur--1/2/</link>
      <pubDate>Thu, 22 May 2014 09:51:53 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2014/05/valeur-r%C3%A9f%C3%A9rence-ou-pointeur--1/2/</guid>
      <description>Quand utiliser une variable par valeur, référence ou pointeur ?
 Telle fut la question qui m&amp;rsquo;a été posée :p.
Comme je ne suis pas entièrement satisfait de la réponse que j&amp;rsquo;ai donné, je fais un article. Pour tout dire, la réponse n&amp;rsquo;est pas aussi triviale que l&amp;rsquo;on pourrait le croire depuis l&amp;rsquo;arrivée du C++11 et la sémantique de déplacement.
Tout d&amp;rsquo;abord, décomposons cette question en 2 parties:</description>
    </item>
    
    <item>
      <title>Parcourir les arguments d&#39;une fonction variadique</title>
      <link>https://jonathanpoelen.github.io/2013/12/parcourir-les-arguments-dune-fonction-variadique/</link>
      <pubDate>Sun, 22 Dec 2013 10:03:06 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/12/parcourir-les-arguments-dune-fonction-variadique/</guid>
      <description>À l&amp;rsquo;approche de Noël et du déballage de cadeaux, faisons un tour sur le déballage des paramètres variadiques.
Fonction récursive La méthode habituelle pour utiliser chaque paramètre est la récursion jusqu&amp;rsquo;à plus d&amp;rsquo;argument ou jusqu&amp;rsquo;à un nombre défini, généralement 1.
Quelque chose dans ce goût-là:
#include &amp;lt;iostream&amp;gt; void f1() {} template&amp;lt;classT, class... Args&amp;gt; void f1(const T&amp;amp; first, const Args&amp;amp;... others) { std::cout &amp;lt;&amp;lt; first &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; f1(others...); } template&amp;lt;classT&amp;gt; void f2(const T&amp;amp; first) { std::cout &amp;lt;&amp;lt; first &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } template&amp;lt;classT, class.</description>
    </item>
    
    <item>
      <title>Tableau dans un std::vector</title>
      <link>https://jonathanpoelen.github.io/2013/09/tableau-dans-un-stdvector/</link>
      <pubDate>Wed, 18 Sep 2013 20:09:51 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/09/tableau-dans-un-stdvector/</guid>
      <description>Prenons le type suivant: std::vector&amp;lt;int[4]&amp;gt; . Qui peut se justifier. À priori, cela ne cause aucun problème ; et c&amp;rsquo;est vrai !
Ajoutons maintenant un élément à notre vector avec push_back.
std::vector&amp;lt;int[2]&amp;gt; v; int a[2]{}; v.push_back(a);  Patatras, rien ne va plus, il y a 2 erreurs. La première concerne la construction du tableau et la seconde sa destruction car un tableau n&amp;rsquo;a ni constructeur ni destructeur.
La manière la plus facile pour éliminer ces erreurs de compilation est de mettre un wrapper sur le tableau.</description>
    </item>
    
    <item>
      <title>Utilisation de swap et des fonctions utilitaires en général</title>
      <link>https://jonathanpoelen.github.io/2013/07/utilisation-de-swap-et-des-fonctions-utilitaires-en-g%C3%A9n%C3%A9ral/</link>
      <pubDate>Sat, 20 Jul 2013 11:18:49 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/07/utilisation-de-swap-et-des-fonctions-utilitaires-en-g%C3%A9n%C3%A9ral/</guid>
      <description>Une fonction utilitaire est une fonction libre qui n&amp;rsquo;étant pas attachée à une classe particulière comme une fonction de conversion (to_string, etc) ou un accesseur externe à une classe (get, begin, end, etc).
Toutes ces fonctions citées sont disponibles en C++11. La seule fonction utilitaire qui me vient à l&amp;rsquo;esprit en C++03 est std::swap (fonction qui échange le contenu de 2 variables). Pour info, l&amp;rsquo;en-tête de std::swap est passé de &amp;lt;algorithm&amp;gt; en C++03 à &amp;lt;utility&amp;gt; en C++11.</description>
    </item>
    
    <item>
      <title>Référence constante sur référence</title>
      <link>https://jonathanpoelen.github.io/2013/05/r%C3%A9f%C3%A9rence-constante-sur-r%C3%A9f%C3%A9rence/</link>
      <pubDate>Mon, 13 May 2013 03:18:42 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/05/r%C3%A9f%C3%A9rence-constante-sur-r%C3%A9f%C3%A9rence/</guid>
      <description>Une petite note sur les références et le qualificatif const  en commençant par un exemple :).
using reference = int&amp;amp;; int i = 0; reference const r = i; r = 3;  Contrairement à ce que laisse croire le code, il est possible de modifier la valeur de r. En fait, ajouter const  sur une référence ne fait rien car cela ne s&amp;rsquo;applique pas sur le référé qui reste un int&amp;amp; .</description>
    </item>
    
    <item>
      <title>Placement new, allocateur et conteneur</title>
      <link>https://jonathanpoelen.github.io/2013/04/placement-new-allocateur-et-conteneur/</link>
      <pubDate>Mon, 22 Apr 2013 22:17:22 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/04/placement-new-allocateur-et-conteneur/</guid>
      <description>new  est généralement utilisé pour allouer un bloc mémoire et &amp;ndash; où il diffère de malloc(), &amp;ndash; appelle le constructeur de la classe demandée (si constructeur il y a). Il fait donc deux choses en une.
Mais new  fait une troisième chose: il lance une exception std::bad_alloc si l&amp;rsquo;espace mémoire est insuffisant.
Ou pas. Car new  est un opérateur surchargeable qui prend des paramètres. Le standard définit dans l&amp;rsquo;en-tête &amp;lt;new&amp;gt; un type (std::nothrow_t) et une variable (std::nothrow) qui permettent de retourner un pointeur nul plutôt que lancer une exception.</description>
    </item>
    
    <item>
      <title>Ne pas empêcher la NRVO</title>
      <link>https://jonathanpoelen.github.io/2013/03/ne-pas-emp%C3%AAcher-la-nrvo/</link>
      <pubDate>Sun, 17 Mar 2013 17:12:57 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2013/03/ne-pas-emp%C3%AAcher-la-nrvo/</guid>
      <description>La NRVO et la RVO sont des optimisations des compilateurs pour retourner un objet sans le copier. Je renvoie directement sur la FAQ C++ developpez.com.
Cependant, ces optimisations ne s&amp;rsquo;appliquent que sur une variable de type T sans référence. Ce qui veut dire qu&amp;rsquo;une référence ne sera pas optimisée.
iterator operator+(const iterator&amp;amp; other, int n) { return iterator(other) += n; // pas de RVO }  Alors qu&amp;rsquo;une décomposition de la fonction active la NRVO.</description>
    </item>
    
    <item>
      <title>Taguer vos classes, cataloguées-les</title>
      <link>https://jonathanpoelen.github.io/2012/12/taguer-vos-classes-catalogu%C3%A9es-les/</link>
      <pubDate>Thu, 20 Dec 2012 01:22:50 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2012/12/taguer-vos-classes-catalogu%C3%A9es-les/</guid>
      <description>Le C++ a l&amp;rsquo;avantage de faire de la surcharge de fonction et permet ainsi de spécifier des algorithmes selon des critères. Ici ce seront des &amp;laquo;&amp;nbsp;tags&amp;nbsp;&amp;raquo;.
Comme exemple je vais utiliser les tags présents dans les itérateurs de la stl et une implémentation de la fonction std::advance().
Première implémentation La fonction std::advance() permet d&amp;rsquo;incrémenter un itérateur de N éléments (ou décrémenter si N est négatif). D&amp;rsquo;après cette description, un premier algorithme peut être émis:</description>
    </item>
    
    <item>
      <title>La récursivité et le mauvais exemple de Fibonacci</title>
      <link>https://jonathanpoelen.github.io/2012/08/la-r%C3%A9cursivit%C3%A9-et-le-mauvais-exemple-de-fibonacci/</link>
      <pubDate>Thu, 16 Aug 2012 02:22:24 +0100</pubDate>
      <author>jonathan.poelen@gmail.com (Jonathan Poelen)</author>
      <guid>https://jonathanpoelen.github.io/2012/08/la-r%C3%A9cursivit%C3%A9-et-le-mauvais-exemple-de-fibonacci/</guid>
      <description>Quasiment toute personne ayant suivi un cours sur la récursivité a eu un exercice de la forme:
 Coder la suite de Fibonacci en récursive et en itérative.
 Mais partout où j&amp;rsquo;ai vu une implémentation récursive, je suis tombé sur un algorithme inefficace. Voici ce qu&amp;rsquo;on peut trouver.
//itérative long long fib(unsigned n) { if (n == 0) return n; long long a = 0, b = 1, tmp; while (--n) { tmp = a + b; a = b; b = tmp; } return b; } // récursive long long fib_r(unsigned n) { if (0 == n || 1 == n) return n; return fib_r(n-1) + fib_r(n-2); } Sauf que cet algorithme récursif est pourri.</description>
    </item>
    
  </channel>
</rss>