<!DOCTYPE html>
<html lang="fr-FR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Minimiser les copies dans operator&#43;</title>
<meta name="generator" content="Hugo 0.53" />



<link rel="stylesheet" type="text/css" media="all" href="https://fonts.googleapis.com/css?family=Droid+Serif" crossorigin="anonymous" />
<link rel="stylesheet" type="text/css" media="all" href="https://fonts.googleapis.com/css?family=Noto+Sans" crossorigin="anonymous" />

<link rel="stylesheet" type="text/css" media="all" href="https://jonathanpoelen.github.io/css/style.min.45ee239dece7b254e05290f1efc66e1c5639e4de2556397e3915d9f4af662696.css">
<link rel="stylesheet" type="text/css" media="all" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous" />
<link rel="shortcut icon" href="/favicon.jpg"/>
<link rel="icon" sizes="32x32" href="/favicon-32.jpg" type="image/jpeg">
<link rel="icon" sizes="64x64" href="/favicon-64.jpg" type="image/jpeg">
<link rel="icon" sizes="96x96" href="/favicon-96.jpg" type="image/jpeg"> 
<link rel="icon" sizes="128x128" href="/favicon-128.jpg" type="image/jpeg">
<meta property="og:site_name" content="Jonathan Poelen&#39;s Blog">
<meta property="og:title" content="Minimiser les copies dans operator&#43;">
<meta property="og:url" content="https://jonathanpoelen.github.io/2017/07/minimiser-les-copies-dans-operator-/">
<meta property="og:language" content="fr-FR">
<meta property="twitter:domain" content="https://jonathanpoelen.github.io/">
<meta property="twitter:card" content="summary">
<meta property="twitter:url" content="https://jonathanpoelen.github.io/2017/07/minimiser-les-copies-dans-operator-/">
<meta property="twitter:title" content="Minimiser les copies dans operator&#43;">
<meta name="description" content="Je vais me baser sur un classique: une classe de matrice contenant un std::vector&lt;int&gt; . Cette classe va implémenter 2 opérateurs mathématiques: &#43;  et &#43;= . Le premier en fonction libre, le second en fonction membre.
Pour rigoler un peu, on ajoute une petite contrainte qui est &laquo;&nbsp;l&rsquo;efficacité&nbsp;&raquo;. Petit mot qui englobe un peu tout et n&rsquo;importe quoi tel que la performance en mémoire et en temps.
À vrai dire, il y a énormément de choses possibles rien que sur la structure du code: instruction vectorisée, alignement mémoire, expression template, etc.">
<meta property="twitter:description" content="Je vais me baser sur un classique: une classe de matrice contenant un std::vector&lt;int&gt; . Cette classe va implémenter 2 opérateurs mathématiques: &#43;  et &#43;= . Le premier en fonction libre, le second en fonction membre.
Pour rigoler un peu, on ajoute une petite contrainte qui est &laquo;&nbsp;l&rsquo;efficacité&nbsp;&raquo;. Petit mot qui englobe un peu tout et n&rsquo;importe quoi tel que la performance en mémoire et en temps.
À vrai dire, il y a énormément de choses possibles rien que sur la structure du code: instruction vectorisée, alignement mémoire, expression template, etc.">

</head>
<body class="body body-right-sidebar mobile" itemscope="itemscope" itemtype="http://schema.org/WebPage">
  <div id="avoidance-link">
    <a class="evitement" href="#main-content" title="Aller au contenu">Aller au contenu</a>
    <a class="evitement" href="#main-menu" title="Aller au menu">Aller au menu</a>
  </div>
  <div class="container container-outer">
    <header class="header" itemscope="itemscope" itemtype="http://schema.org/WPHeader">
      <div class="container-inner">
        <div class="logo" role="banner" itemscope="itemscope" itemtype="http://schema.org/Brand">
          <a class="logo__link" href="/" title="Jonathan Poelen&#39;s Blog" rel="home">
            <h1 class="logo__title">Le blog de Jonathan Poelen</h1>
            <h2 class="logo__tagline">Mon petit mémo sur tout ce qui touche à la programmation =)</h2>
          </a>
        </div>
        <nav class="menu" itemscope="itemscope" itemtype="http://schema.org/SiteNavigationElement">
  <ul class="menu__list">
    <li class="menu__item"><a class="menu__link" title="GitHub" rel="noopener noreferrer" href="https://github.com/jonathanpoelen">
      <i class="fab fa-github" aria-hidden="true"></i> Github
    </a></li>
    <li class="menu__item "><a class="menu__link" title="Archives" href="/archives">
      <i class="fas fa-archive" aria-hidden="true"></i> Archives</a>
    </li>
    <li class="menu__item"><a class="menu__link" title="Flux RSS" href="/index.xml">
      <i class="fas fa-rss" aria-hidden="true"></i> RSS</a>
    </li>
  </ul>
</nav>


      </div>
    </header>
    <div class="wrapper clearfix">

<aside class="sidebar" itemscope="itemscope" itemtype="http://schema.org/WPSideBar">
	
<div class="widget-search widget">
  <form class="widget-search__form" role="search" method="get" action="https://duckduckgo.com">
    <label>
      <span class="screen-reader-text">Search for:</span>
      <input class="widget-search__field" type="search" placeholder="SEARCH..." value="" name="q">
    </label>
    <input class="widget-search__submit" type="submit" value="Search">
    <input type="hidden" name="sites" value="https://jonathanpoelen.github.io/" />
  </form>
</div>

	
<div class="widget-recent widget" id="main-menu">
  <h4 class="widget__title"><i class="fas fa-file-text-o" aria-hidden="true"></i> Articles récents</h4>
  <div class="widget__content">
    <ul class="widget__list">
      <li class="widget__item"><a class="widget__link" href="/2019/01/grep-sed-awk-sort...-non-zsh/">Grep, sed, awk, sort... Non ! Zsh</a></li>
      <li class="widget__item"><a class="widget__link" href="/2018/12/presque-toujours-stdmove/">Presque toujours std::move</a></li>
      <li class="widget__item"><a class="widget__link" href="/2018/11/meta-function-et-continuation/">Méta-function et continuation</a></li>
      <li class="widget__item"><a class="widget__link" href="/2018/11/simuler-une-vtable-sans-fonction-virtuelle/">Simuler une vtable sans fonction virtuelle</a></li>
      
      <li class="widget__item"><a class="widget__link widget__link__other" href="/archives">32 autres…</a></li>
    </ul>
  </div>
</div>
<div class="widget-recent widget">
  <h4 class="widget__title"><i class="fas fa-clock-o" aria-hidden="true"></i> Articles récemment mis à jour</h4>
  <div class="widget__content">
    <ul class="widget__list">

    </ul>
  </div>
</div>

	
<div class="widget-categories widget">
  <h4 class="widget__title"><i class="fas fa-folder-o" aria-hidden="true"></i> Catégories</h4>
  <div class="widget__content">
    <ul class="widget__list">
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour C&#43;&#43;">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/c&#43;&#43;">C&#43;&#43; (23)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Script-Shell">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/script-shell">Script-Shell (7)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Accessibilite-Web">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/accessibilite-web">Accessibilite-Web (2)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Javascript">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/javascript">Javascript (2)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Zsh">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/zsh">Zsh (2)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Make">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/make">Make (1)</a>
      </li>
      <li class="widget__item">
        <a class="rss-link" href="/categories/index.xml" type="application/rss+xml" title="Flux RSS pour Sqlite">
          &nbsp;
          <i class="fas fa-rss" aria-hidden="true"></i>
          <span class="sr-only link-alt">Flux RSS</span>&nbsp;
        </a>
        <a class="widget__link" href="/categories/sqlite">Sqlite (1)</a>
      </li>
    </ul>
  </div>
</div>

	
	

</aside>
<main class="main-content content" role="main" itemprop="mainContentOfPage" id="main-content">
  
<article class="post">
  <header class="post__header clearfix">
    <div class="post__title-nextprev" id="minimiser-les-copies-dans-operator&#43;"><span>
        <a href="https://jonathanpoelen.github.io/2017/07/de-blogspot-a-hugo-il-a-change-de-peau/"><i class="fas fa-caret-square-up" aria-hidden="true" title="Article précédent: De Blogspot à Hugo, il a changé de peau"></i></a>
        <a href="https://jonathanpoelen.github.io/2016/04/comment-se-passer-de-stdforward/"><i class="fas fa-caret-square-down" aria-hidden="true" title="Article suivant: Comment se passer de std::forward"></i></a>
    </span></div>
    <h1 class="post__title"><a href="https://jonathanpoelen.github.io/2017/07/minimiser-les-copies-dans-operator-/">Minimiser les copies dans operator&#43;</a></h1>
    <div class="post__title-nextprev-text sr-only">
        <a href="https://jonathanpoelen.github.io/2017/07/de-blogspot-a-hugo-il-a-change-de-peau/">Article suivant: De Blogspot à Hugo, il a changé de peau</a><br/>
        <a href="https://jonathanpoelen.github.io/2016/04/comment-se-passer-de-stdforward/">Article précédent: Comment se passer de std::forward</a><br/>
    </div>
    
<p class="post__meta meta">
    <i class="fas fa-clock-o fa-fw" aria-hidden="true"></i>
    <time class="post__meta-date" datetime="2017-07-05T22:02:11">05 juillet 2017
</time>
    
    ;
  

  

<a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category"><i class="fas fa-folder fa-fw" aria-hidden="true"></i><span class="sr-only text-alt">Catégories&nbsp;:</span>c&#43;&#43;</a>
;


  <i class="fas fa-hourglass-start fa-fw" aria-hidden="true"></i><span class="sr-only text-alt fa-fw">Durée de lecture éstimée&nbsp;:</span>9 minutes ;
  <a href="https://jonathanpoelen.github.io/2017/07/minimiser-les-copies-dans-operator-/#gh-comments" onclick="DoGithubComments( 1 )"><i class="fas fa-comments fa-fw" aria-hidden="true"></i>Commentaires</a> ;
  <a href="#8d66709af0c9e47357d2fae8b9c175bd-share"><i class="fas fa-share-alt fa-fw" aria-hidden="true"></i>Partager</a>
</p>


  </header>
  <div class="post__content">
        <aside id="toc"><div id="tocInner">
          <h2 id="tocHeading">Sommaire</h2><nav id="TableOfContents">
<ul>
<li><a href="#plein-de-surcharges-de-operator">Plein de surcharges de operator+</a></li>
<li><a href="#un-prototype-multi-fonction">Un prototype multi-fonction</a></li>
<li><a href="#n-écrivez-pas-operator-vous-même-c-est-trop-compliqué-nbsp">N&rsquo;écrivez pas operator+ vous-même, c&rsquo;est trop compliqué&nbsp;!</a></li>
</ul></nav>
        </div></aside>
      

<p>Je vais me baser sur un classique: une classe de matrice contenant un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
</code></span>. Cette classe va implémenter 2 opérateurs mathématiques: <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="o">+</span>
</code></span> et <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="o">+=</span>
</code></span>. Le premier en fonction libre, le second en fonction membre.</p>

<p>Pour rigoler un peu, on ajoute une petite contrainte qui est &laquo;&nbsp;l&rsquo;efficacité&nbsp;&raquo;. Petit mot qui englobe un peu tout et n&rsquo;importe quoi tel que la performance en mémoire et en temps.</p>

<p>À vrai dire, il y a énormément de choses possibles rien que sur la structure du code: instruction vectorisée, alignement mémoire, expression template, etc. Des bibliothèques comme uBLAS, Eigen, Blitz implémentent une tripotée de choses. Ici, on va uniquement s&rsquo;intéresser à la manière d&rsquo;implémenter <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">operator</span><span class="o">+</span>
</code></span> pour recycler les variables temporaires dans le but d&rsquo;avoir le moins d&rsquo;allocations possibles dûes aux copies.</p>

<p>Grosso-modo, des rvalues à droite, des rvalues à gauche, des rvalues partout et pour finir, pas de rvalue.</p>

<p>En réalité, il y a plusieurs approches possibles que je mets ici en opposition sans qu&rsquo;elles le soient réellement.</p>

<ol>
<li>une surcharge pour tous les prototypes possibles.</li>
<li>un opérator unique pour les gouverner tous.</li>
</ol>

<a class="headline-hash" href="#plein-de-surcharges-de-operator"><h2 id="plein-de-surcharges-de-operator">Plein de surcharges de operator+</h2></a>

<p>Faire 4 prototypes pour distinguer les rvalues des lvalues est un choix assez naturel. Si un prototype contient une rvalue, alors il y a moyen de recycler une valeur. On pourrait même ajouter <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">noexcept</span>
</code></span> sur de tels prototypes.</p>

<p>Voici ce que donne l&rsquo;implémentation:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Matrix</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Matrix</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Matrix</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Matrix</span> <span class="n">ret</span> <span class="p">{</span><span class="n">lhs</span><span class="p">};</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">// et non pas return `ret += rhs`, ce qui empêcherait la NRVO.
</span><span class="c1"></span><span class="p">}</span>

<span class="n">Matrix</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Matrix</span><span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Matrix</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">lhs</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span> <span class="c1">// ne pas oublier std::move, sinon il y a aura copie en sortie
</span><span class="c1"></span><span class="p">}</span>

<span class="n">Matrix</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Matrix</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Matrix</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">rhs</span> <span class="o">+=</span> <span class="n">lhs</span><span class="p">;</span> <span class="c1">// commutativité: x+y = y+x
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Matrix</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Matrix</span><span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Matrix</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">rhs</span> <span class="o">+=</span> <span class="n">lhs</span><span class="p">;</span> <span class="c1">// éventuellement `rhs += std::move(lhs)`
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Petite note sur la dernière implémentation. Utiliser <code>rhs</code> comme valeur de retour permet de gagner un <code>mov</code> (asm). <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,source:'%23include+%3Cutility%3E%0A%23include+%3Cvector%3E%0A%0Astruct+Matrix%0A%7B%0A++++++std::vector%3Cint%3E+v%3B%0A++++++Matrix%26+operator+%2B%3D(Matrix+const%26)+%3B%0A%7D%3B%0A%0AMatrix+operator%2B+(Matrix+%26%26+lhs,+Matrix+const+%26+rhs)%0A%7B%0A++++std::move(lhs)+%2B%3D+rhs%3B%0A++++//+ne+pas+oublier+std::move,+sinon+il+y+a+aura+copie+en+sortie+puisque+que+lhs+est+une+r%C3%A9f%C3%A9rence%0A++++return+std::move(lhs)%3B%0A%7D%0A%0AMatrix+operator+%2B+(Matrix+const+%26+lhs,+Matrix+%26%26+rhs)%0A%7B%0A++++std::move(rhs)+%2B%3D+lhs%3B+//+commutativit%C3%A9:+x%2By+%3D+y%2Bx%0A++++return+std::move(rhs)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:31.812073713509285,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:g71,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'-O3+-std%3Dc%2B%2B14+-fverbose-asm+',source:1),l:'5',n:'0',o:'x86-64+gcc+7.1+(Editor+%231,+Compiler+%231)',t:'0')),k:34.07627444894807,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:g71,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'+-std%3Dc%2B%2B14+-O3+-fverbose-asm+',source:1),l:'5',n:'0',o:'x86-64+gcc+7.1+(Editor+%231,+Compiler+%232)',t:'0')),k:34.11165183754265,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">ici</a>.</p>

<p>Bon, c&rsquo;est bien joli, mais on peut quasiment faire la même avec seulement 2 prototypes. Seulement, pour une raison que j&rsquo;ignore, ni clang, ni gcc n&rsquo;applique la RVO correctement. Le constructeur de déplacement est systèmatiquement utilisé.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Matrix</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Matrix</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Matrix</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">lhs</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">lhs</span><span class="p">;</span> <span class="c1">// pas de RVO ???
</span><span class="c1"></span><span class="p">}</span>

<span class="n">Matrix</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Matrix</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Matrix</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">rhs</span> <span class="o">+=</span> <span class="n">lhs</span><span class="p">;</span> <span class="c1">// commutativité: x+y = y+x
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Les prototypes ne sont pas symétriques pour éviter les ambiguïtés. Le prototype prenant un paramètre par copie sera moins prioritaire que celui avec une rvalue, mais il accepte toutes les formes de référence.</p>

<p>Ainsi, si dans l&rsquo;expression <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></span>, <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">b</span>
</code></span> une rvalue, la seconde fonction sera utilisée. Dans les autres cas, la première fonction sera utilisée. On peut facilement vérifier quelle expression correspond à quelle fonction avec un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__PRETTY_FUNCTION__</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span>
</code></span> dans les implémentations et le test qui suit.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">Lhs</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">Rhs</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Matrix &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_const</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span><span class="p">{}</span> <span class="o">?</span> <span class="s">&#34;const&#34;</span> <span class="o">:</span> <span class="s">&#34;     &#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; a; &#34;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Matrix &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_const</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="p">{}</span> <span class="o">?</span> <span class="s">&#34;const&#34;</span> <span class="o">:</span> <span class="s">&#34;     &#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; b;</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>

  <span class="n">Lhs</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">Rhs</span> <span class="n">b</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">left</span><span class="p">;</span>
  <span class="cp">#define C(a,b) std::cout &lt;&lt; std::setw(13) &lt;&lt; #a &lt;&lt; &#34;+ &#34; &lt;&lt; std::setw(15) &lt;&lt; #b; a+b
</span><span class="cp"></span>  <span class="n">C</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>            <span class="n">b</span><span class="p">);</span>
  <span class="n">C</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
  <span class="n">C</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">C</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
  <span class="cp">#undef C
</span><span class="cp"></span><span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">test</span><span class="o">&lt;</span>      <span class="n">Matrix</span><span class="p">,</span>       <span class="n">Matrix</span><span class="o">&gt;</span><span class="p">();</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="n">test</span><span class="o">&lt;</span>      <span class="n">Matrix</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matrix</span><span class="o">&gt;</span><span class="p">();</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="n">test</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Matrix</span><span class="p">,</span>       <span class="n">Matrix</span><span class="o">&gt;</span><span class="p">();</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="n">test</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Matrix</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matrix</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>Résultat:</p>

<div class="highlight"><pre class="chroma"><code>Matrix       a; Matrix       b;

a            + b              Matrix operator+(Matrix, const Matrix&amp;)
a            + std::move(b)   Matrix operator+(const Matrix&amp;, Matrix&amp;&amp;)
std::move(a) + b              Matrix operator+(Matrix, const Matrix&amp;)
std::move(a) + std::move(b)   Matrix operator+(const Matrix&amp;, Matrix&amp;&amp;)


Matrix       a; Matrix const b;

a            + b              Matrix operator+(Matrix, const Matrix&amp;)
a            + std::move(b)   Matrix operator+(Matrix, const Matrix&amp;)
std::move(a) + b              Matrix operator+(Matrix, const Matrix&amp;)
std::move(a) + std::move(b)   Matrix operator+(Matrix, const Matrix&amp;)


Matrix const a; Matrix       b;

a            + b              Matrix operator+(Matrix, const Matrix&amp;)
a            + std::move(b)   Matrix operator+(const Matrix&amp;, Matrix&amp;&amp;)
std::move(a) + b              Matrix operator+(Matrix, const Matrix&amp;)
std::move(a) + std::move(b)   Matrix operator+(const Matrix&amp;, Matrix&amp;&amp;)


Matrix const a; Matrix const b;

a            + b              Matrix operator+(Matrix, const Matrix&amp;)
a            + std::move(b)   Matrix operator+(Matrix, const Matrix&amp;)
std::move(a) + b              Matrix operator+(Matrix, const Matrix&amp;)
std::move(a) + std::move(b)   Matrix operator+(Matrix, const Matrix&amp;)
</code></pre></div>

<p>Si on y tient vraiment, on peut ajouter <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">Matrix</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Matrix</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">Matrix</span><span class="o">&amp;&amp;</span><span class="p">)</span>
</code></span>. Mais comme dit précédemment le besoin est très faible.</p>

<a class="headline-hash" href="#un-prototype-multi-fonction"><h2 id="un-prototype-multi-fonction">Un prototype multi-fonction</h2></a>

<p>Une autre solution pour la surcharge d&rsquo;opérateur est de ne faire qu&rsquo;un seul et unique prototype template qui s&rsquo;active en présence d&rsquo;un certain type. Ce n&rsquo;est pas une approche opposée à la précédente (elle peut servir de complément), mais je vais présenter ici comment le faire avec seulement un prototype.</p>

<p>Pour filtrer les types compatibles, on va utiliser la bonne vieille méthode à base de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">enable_if</span>
</code></span>. Ce qui donne:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">MatrixLhs</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">MatrixRhs</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">MatrixLhs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Matrix</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">MatrixRhs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Matrix</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
  <span class="n">Matrix</span><span class="o">&gt;</span>
<span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">MatrixLhs</span><span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">MatrixRhs</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</code></pre></div>
<p>Dans la réalité, l&rsquo;addition d&rsquo;une matrice fonctionne aussi sur des entiers (cf: <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">+</span> <span class="n">Matrix</span>
</code></span>, <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">Matrix</span> <span class="o">+</span> <span class="kt">int</span>
</code></span>). Le filtre sera alors beaucoup plus compliqué puisqu&rsquo;il faut qu&rsquo;au moins une des opérandes soit un type <code>Matrix</code> et que les paramètres soient des types compatibles (en prenant en compte la présence des références et des <code>const</code>). La condition devient alors quelque chose comme:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">is_matrix_operand</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
<span class="n">is_matrix_operand</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
<span class="p">(</span><span class="n">is_matrix</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">is_matrix</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div>
<p>Il devient alors très facile d&rsquo;ajouter un nouveau type à prendre en compte, comme par exemple un conteneur de la SL, un tableau C, un autre type matriciel d&rsquo;une autre bibliothèque, etc. Faire comme dans le premier chapitre avec un prototype pour chaque cas devient vite infernal.</p>

<p>Il est également envisageable de faire des prototypes par catégorie de variable: Sequence et Matrix, Integer et Matrix.</p>

<p>Revenons-en à notre <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">operator</span><span class="o">+</span>
</code></span> et son implémentation. Celle-ci va être plus compliqué car elle doit être équivalente aux 4 implémentations du début ; sachant que la première possède une variable et les opérandes sont inversés dans la troisième et la quatrième.</p>

<p>Une solution possible est de mettre 2 valeurs intermédiaires qui représentent l&rsquo;opérande de gauche et l&rsquo;opérande de droite et dont le type s&rsquo;adapte en fonction des types en entrée.</p>

<p>Ci-dessous un tableau récapitulatif des types et valeurs de nos 2 nouvelles variables <code>Lhs</code> et <code>Rhs</code>. Les <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">const</span>
</code></span> sont supprimés car seule la référence importe.</p>

<table>
<thead>
<tr>
<th>Prototype</th>
<th>NewLhs</th>
<th>NewRhs</th>
</tr>
</thead>

<tbody>
<tr>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;</span> 
</code></span>, <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;</span> 
</code></span></td>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span>   
</code></span> = lhs</td>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;</span> 
</code></span> = rhs</td>
</tr>

<tr>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;&amp;</span>
</code></span>, <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;</span> 
</code></span></td>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;&amp;</span>
</code></span> = lhs</td>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;</span> 
</code></span> = rhs</td>
</tr>

<tr>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;</span> 
</code></span>, <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;&amp;</span>
</code></span></td>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;&amp;</span>
</code></span> = rhs</td>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;</span> 
</code></span> = lhs</td>
</tr>

<tr>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;&amp;</span>
</code></span>, <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;&amp;</span>
</code></span></td>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;&amp;</span>
</code></span> = rhs</td>
<td><span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="o">&amp;&amp;</span>
</code></span> = lhs</td>
</tr>
</tbody>
</table>

<p>Et l&rsquo;implémentation:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">rvalue_wrapper</span>
<span class="p">{</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">;</span>

  <span class="k">operator</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
  <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">unwrap</span><span class="p">(</span><span class="n">rvalue_wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">unwrap</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">Lhs</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">Rhs</span><span class="o">&gt;</span>
<span class="n">Matrix</span> <span class="k">operator</span> <span class="o">+</span><span class="p">(</span><span class="n">Lhs</span><span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">NewLhs</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional_t</span><span class="o">&lt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
    <span class="n">Matrix</span><span class="p">,</span>
    <span class="n">rvalue_wrapper</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">NewRhs</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional_t</span><span class="o">&lt;</span>
    <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
    <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
    <span class="n">Matrix</span><span class="o">&amp;</span><span class="p">,</span>
    <span class="n">Matrix</span><span class="o">&amp;&amp;&gt;</span><span class="p">;</span>

  <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">swap_arg</span> <span class="o">=</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>

  <span class="n">NewLhs</span> <span class="n">new_lhs</span><span class="p">{</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">swap_arg</span> <span class="o">?</span> <span class="nl">rhs</span> <span class="p">:</span> <span class="n">lhs</span><span class="p">)};</span>
  <span class="n">NewRhs</span> <span class="n">new_rhs</span><span class="p">{</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">NewRhs</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">swap_arg</span> <span class="o">?</span> <span class="nl">lhs</span> <span class="p">:</span> <span class="n">rhs</span><span class="p">))};</span>

  <span class="n">unwrap</span><span class="p">(</span><span class="n">new_lhs</span><span class="p">)</span> <span class="o">+=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">NewRhs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new_rhs</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">new_lhs</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Le code mérite quelques explications. Pour commencer, parlons de <code>rvalue_reference</code> qui est un palliatif pour une optimisation au niveau de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">return</span>
</code></span>. Au niveau du retour, si <code>NewLhs</code> est une rvalue, il faut utiliser <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">move</span>
</code></span>, sauf que l&rsquo;utiliser sur une variable locale à la fonction bloque le RVO. Hélas, même avec un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_rvalue_reference</span><span class="o">&lt;</span><span class="n">NewLhs</span><span class="o">&gt;</span><span class="p">{})</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
</code></span> avant <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">return</span> <span class="n">new_lhs</span>
</code></span> l&rsquo;optimisation n&rsquo;est pas faite. Cela fonctionne néanmoins avec <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="k">constexpr</span>
</code></span> de c++17. Le but de <code>rvalue_reference</code>  est finalement de rendre automatique un retour par rvalue grâce à l&rsquo;opérateur de cast interne.</p>

<p>Concernant ce curieux enchaînement de cast, celui-ci s&rsquo;explique par la difficulté de contrôler le type retourné par une ternaire. Une ternaire sur deux variables de même type va retourner une référence (une variable est toujours une lvalue). La référence sera considérée constante si une des deux valeurs est une référence constante. Du coup, on vire le const pour ensuite construire les types <code>NewLhs</code> et <code>NewRhs</code>.</p>

<p>Ici, le constructeur de la matrice (quand <code>NewLhs = Matrix</code>) va recevoir un type non const. À moins qu&rsquo;un constructeur existe pour les références non const, cela ne cause pas de problème. On peut très bien ajouter un <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">conditional</span>
</code></span> pour forcer le const.</p>

<p>En première impression <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">NewRhs</span><span class="o">&gt;</span>
</code></span> pourrait être optionnel, mais celui-ci permet de forcer la rvalue pour construire NewRhs. Une lvalue (le retour de <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&amp;&gt;</span>
</code></span>) ne pouvant être affectée à une rvalue sans cela.</p>

<p>Les casts présents fonctionnent bien parce que <code>lhs</code> et <code>rhs</code> sont tous deux du même type. Dans le cas contraire, il faut faire un branchement à la compilation via de la surcharge de fonction (dispatch de type) tel que font <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">falcon</span><span class="o">::</span><span class="n">cif</span>
</code></span> ou <span class="inlinecode highlight"><code class="language-cpp" data-lang="cpp"><span class="n">boost</span><span class="o">::</span><span class="n">hana</span><span class="o">::</span><span class="n">if_</span>
</code></span>. Plusieurs de mes articles en parlent.</p>

<a class="headline-hash" href="#n-écrivez-pas-operator-vous-même-c-est-trop-compliqué-nbsp"><h2 id="n-écrivez-pas-operator-vous-même-c-est-trop-compliqué-nbsp">N&rsquo;écrivez pas operator+ vous-même, c&rsquo;est trop compliqué&nbsp;!</h2></a>

<p>Sérieusement, qui veut écrire une 20taine de lignes pour chaque opérateur ? Ne le faites pas, le code est alourdi, la lisibilité réduite. Il y a moyen d&rsquo;implémenter la plupart des opérateurs en quelques lignes pour le même résultat.</p>

<p>De plus, l&rsquo;implémentation des opérateurs peuvent varier. Par exemple, pas de commutativité. Ses variantes sont difficiles à détecter dans une grande masse de code, il devient facile de faire une erreur aussi bien à l&rsquo;écriture qu&rsquo;à la lecture.</p>

<p>Autre point, les types des opérandes peuvent être nombreux, faire tous les prototypes necessaires vous vaudra des heures de souffrances :).</p>

<p>Du coup, comment faire ? Une solution facile est d&rsquo;utiliser une macro pour implémenter les opérateurs voulus. C&rsquo;est simple et rapide, mais l&rsquo;utiliser avec des types template est un peu délicat. Cela reste néanmoins la solution la plus simple.</p>

<p>Une autre manière passe par du CRTP pour que la classe de base implémente les opérateurs voulus sous forme de fonction amie. C&rsquo;est la solution de <a href="http://www.boost.org/doc/libs/1_64_0/libs/utility/operators.htm">boost/operators.hpp</a>. Malheureusement, elle ne prend pas en compte les optimisations possibles sur les rvalues écrits dans cet article. Il faut la ré-écrire.</p>

<p>La dernière solution consiste à se servir des traits pour activer ou non certains prototypes comme dans le chapitre précédent. Une mise en oeuvre poussée peut être extrêmement extensible et s&rsquo;adapte très facilement aux catégories de valeur (séquence, intégrale), mais c&rsquo;est un poil complexe à mettre en place. Je ne connais pas de bibliothèque qui le fasse.</p>

<p>Au final, il n&rsquo;existe actuellement pas d&rsquo;outil satisfaisant pour générer les opérateurs alors qu&rsquo;il est presque aussi rapide d&rsquo;écrire une lib ou des macros pour le faire. Le temps perdu sera largement compensé par le nombre d&rsquo;opérateurs à implémenter par la suite. Avec un peu de jugeote, il est même possible de mutualiser l&rsquo;écriture des opérateurs <code>@=</code>. Pensez-y la prochaine fois qu&rsquo;il faudra écrire des opérateurs ;).</p>

  </div>
  <footer class="post__footer">
    <p class="post__meta meta">
  Le <time class="post__meta-date" datetime="2017-07-05T22:02:11">05 juillet 2017
</time> par Jonathan Poelen dans <a class="meta-categories__link" href="/categories/c&#43;&#43;" rel="category">c&#43;&#43;</a>
 ;
  

  <br/><a href="https://jonathanpoelen.github.io/2017/07/minimiser-les-copies-dans-operator-/"><i class="fas fa-link fa-fw" aria-hidden="true"></i>Lien permanent.</a>
</p>
<p class="post__meta meta share" id="8d66709af0c9e47357d2fae8b9c175bd-share">
  
  Partager Par
  <a title="Partager par email" href="mailto:?subject=minimiser-les-copies-dans-operator%2b&amp;Body=https%3a%2f%2fjonathanpoelen.github.io%2f2017%2f07%2fminimiser-les-copies-dans-operator-%2f"><i class="fas fa-envelope-square fa-fw" aria-hidden="true"></i><span class="sr-only">Mail</span></a>
  <a title="Partager sur Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonathanpoelen.github.io%2f2017%2f07%2fminimiser-les-copies-dans-operator-%2f&amp;title=minimiser-les-copies-dans-operator%2b" rel="noopener noreferrer"><i class="fab fa-linkedin fa-fw" aria-hidden="true" style="color: #0077B5"></i><span class="sr-only">Linkedin</span></a>
  <a title="Partager sur Twitter" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjonathanpoelen.github.io%2f2017%2f07%2fminimiser-les-copies-dans-operator-%2f" rel="noopener noreferrer"><i class="fab fa-twitter-square fa-fw" aria-hidden="true" style="color: #1DA1F2"></i><span class="sr-only">Twitter</span></a>
  <a title="Partager sur Google+" href="https://plus.google.com/share?url=https%3a%2f%2fjonathanpoelen.github.io%2f2017%2f07%2fminimiser-les-copies-dans-operator-%2f" rel="noopener noreferrer"><i class="fab fa-google-plus-square fa-fw" aria-hidden="true" style="color: #DE5549"></i><span class="sr-only">Google+</span></a>
  <a title="Partager sur Facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathanpoelen.github.io%2f2017%2f07%2fminimiser-les-copies-dans-operator-%2f" rel="noopener noreferrer"><i class="fab fa-facebook-square fa-fw" aria-hidden="true" style="color: #4869b2"></i><span class="sr-only">Facebook</span></a>
  <a title="Partager sur Tumblr" href="https://www.tumblr.com/share/link?url=https%3a%2f%2fjonathanpoelen.github.io%2f2017%2f07%2fminimiser-les-copies-dans-operator-%2f&amp;name=minimiser-les-copies-dans-operator%2b" rel="noopener noreferrer"><i class="fab fa-tumblr-square fa-fw" aria-hidden="true" style="color: #349099"></i><span class="sr-only">Tumblr</span></a>
</p>

  </footer>
</article>

  
  
<nav class="post-nav row" itemscope="itemscope" itemtype="http://schema.org/SiteNavigationElement">
  <div class="post-nav__item post-nav__item--prev">
    <a class="post-nav__link" href="/2016/04/comment-se-passer-de-stdforward/" rel="prev"><span class="post-nav__caption">«Précédent</span><span class="post-nav__post-title">Comment se passer de std::forward</span></a>
  </div>
  <div class="post-nav__item post-nav__item--next">
    <a class="post-nav__link" href="/2017/07/de-blogspot-a-hugo-il-a-change-de-peau/" rel="next"><span class="post-nav__caption">Suivant»</span><span class="post-nav__post-title">De Blogspot à Hugo, il a changé de peau</span></a>
  </div>
</nav>

  <section id="gh-comments">
  <h1>Commentaires</h1>
<p>Le système de commentaire passe par <a href="https://github.com/jonathanpoelen/jonathanpoelen.github.io/issues/1">les issues de github</a>.
  <article id="gh-comments-list"></article>
  <a href="#" id="gh-load-comments" class="btn" onclick="DoGithubComments( 1 ); return false">Charger les commentaires</a>
</section>

<script type="text/javascript" src="https://jonathanpoelen.github.io/js/github-comment.min.2c84eb79c794ac94a9bed1928e6af0bcce5aaeba7e88129d987d47ebe81ab19e.js"></script>
<script type="text/javascript">
if (document.URL.split('#')[1] === 'gh-comments')
{
  DoGithubComments( 1 );
}
</script>
</section>

</main>
</div>
  <footer class="footer" itemscope="itemscope" itemtype="http://schema.org/WPFooter">
    <p class="footer-archive"><a href="/archives" title="Archives">Archives</a></p>
    <p class="footer__copyright">
       Jonathan Poelen&#39;s Blog. <span class="footer__copyright-credits">
      Généré avec <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a>
      et <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad theme</a>.
      Utilise <a href="http://fontawesome.io" rel="nofollow noopener" target="_blank">Font Awesome</a> de Dave Gandy pour les icônes.
      </span>
    </p>
  </footer>
</div>
<a id="backtop" href="#avoidance-link"><i class="fas fa-arrow-circle-up fa-3x" aria-hidden="true"></i><span class="sr-only">Revenir en haut</span></a>

</body>
</html>

